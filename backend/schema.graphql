# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

type ChangeEmailOutput {
    email: String!
}

type CohortRef {
    course: CourseRef
}

type CourseRef {
    academic: String
    name: String
    subject: SubjectRef
}

type DeleteTeacherOutput {
    courses: Int!
    id: uuid!
}

type EnrollOutput {
    enrollment: student_enrollments
    id: uuid!
}

type EntityOrderUpdateOutput {
    entityId: StringOrInt!
    order: Int!
}

type Mutation {
    cancelAllSubscriptions: String
    cancelSubscription(subscriptionId: uuid!): String
    changeEmail(currentEmail: String!, newEmail: String!): ChangeEmailOutput
    createCohort(input: NewCohortInput): uuid
    createSchool(input: CreateSchoolInput!): uuid
    deleteCohort(id: uuid!): uuid
    deleteTeacher(id: uuid!, transferTo: uuid): DeleteTeacherOutput
    editSchedule(id: uuid!, startTime: timestamptz!, timeZone: String!): ScheduleRef
    initiateUpload(contentType: String!, id: uuid, name: String!): SignedUpload
    purchasePlan(planId: String!, promoCode: String, studentId: uuid!): String!
    resendInvite(id: uuid!): String
    unenrollStudent(id: uuid!): uuid
    updateEntityOrder(entityType: EntityUpdateType, updates: [UpdateEntityOrderInput!]!): [EntityOrderUpdateOutput]!
    updatePaymentInfo(paymentMethodId: String): PaymentMethod
    updatePlan(input: UpdatePlanInput!): String
    updateUnitOrder(updates: [UpdateUnitOrderInput!]!): [UnitOrderUpdateOutput]!
    uploadStudents(file: String!, schoolId: uuid!): UploadStudentOutput
    waitlistSignup(input: WaitlistSignupInput): String
}

type PaymentMethod {
    card: PaymentMethodCard
    details: PaymentMethodDetails
    id: String!
    saved: Boolean
}

type PaymentMethodAddress {
    city: String
    country: String
    line1: String
    line2: String
    postalCode: String
    state: String
}

type PaymentMethodCard {
    last4: String
}

type PaymentMethodDetails {
    address: PaymentMethodAddress
    name: String!
}

type Query {
    listPaymentMethods: [PaymentMethod]!
    ping: String
    plans: [SubscriptionPlans]!
    subscriptionOverview: SubscriptionOverviewOutput
    thinkificLink: ThinkificLink!
    validateCoupon(code: String!): ValidateCouponResponse!
}

type RetryPaymentOutput {
    ok: Boolean!
}

type ScheduleRef {
    endTime: timestamptz!
    id: uuid!
    startTime: timestamptz!
}

type SignUpUserOutput {
    id: uuid!
    profile: profile
}

type SignedUpload {
    id: uuid!
    signedUploadUrl: String!
}

type SingupUserOutput {
    id: uuid!
    student: students
    user: users
}

type SubjectRef {
    name: String
}

type SubscriptionOverviewOutput {
    createdAt: String
    expiresOn: String
    invoiceAmount: Int!
    pastDueAmount: Int!
    paymentMethods: [PaymentMethod]!
    proratedAmount: Int
}

type SubscriptionPlans {
    details: [String!]!
    id: String
    interval: plan_internval_types
    isSubscription: Boolean!
    name: String!
    price: Float!
    title: String
}

type ThinkificLink {
    url: String
}

type UnenrollOuput {
    id: uuid!
    studentId: uuid!
}

type UnitOrderUpdateOutput {
    order: Int!
    unitId: uuid!
}

type UploadStudentOutput {
    rules: Int!
    students: Int!
}

type ValidateCouponResponse {
    amount: Float!
    code: String!
    discount: String!
}

"columns and relationships of \"ages\""
type ages {
    id: Int!
    name: String!
    value: numeric!
}

"aggregated selection of \"ages\""
type ages_aggregate {
    aggregate: ages_aggregate_fields
    nodes: [ages!]!
}

"aggregate fields of \"ages\""
type ages_aggregate_fields {
    avg: ages_avg_fields
    count(columns: [ages_select_column!], distinct: Boolean): Int
    max: ages_max_fields
    min: ages_min_fields
    stddev: ages_stddev_fields
    stddev_pop: ages_stddev_pop_fields
    stddev_samp: ages_stddev_samp_fields
    sum: ages_sum_fields
    var_pop: ages_var_pop_fields
    var_samp: ages_var_samp_fields
    variance: ages_variance_fields
}

"aggregate avg on columns"
type ages_avg_fields {
    id: Float
    value: Float
}

"aggregate max on columns"
type ages_max_fields {
    id: Int
    name: String
    value: numeric
}

"aggregate min on columns"
type ages_min_fields {
    id: Int
    name: String
    value: numeric
}

"response of any mutation on the table \"ages\""
type ages_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [ages!]!
}

"aggregate stddev on columns"
type ages_stddev_fields {
    id: Float
    value: Float
}

"aggregate stddev_pop on columns"
type ages_stddev_pop_fields {
    id: Float
    value: Float
}

"aggregate stddev_samp on columns"
type ages_stddev_samp_fields {
    id: Float
    value: Float
}

"aggregate sum on columns"
type ages_sum_fields {
    id: Int
    value: numeric
}

"aggregate var_pop on columns"
type ages_var_pop_fields {
    id: Float
    value: Float
}

"aggregate var_samp on columns"
type ages_var_samp_fields {
    id: Float
    value: Float
}

"aggregate variance on columns"
type ages_variance_fields {
    id: Float
    value: Float
}

"columns and relationships of \"application_config\""
type application_config {
    id: uuid!
    immersiveDiscount: Int!
}

"aggregated selection of \"application_config\""
type application_config_aggregate {
    aggregate: application_config_aggregate_fields
    nodes: [application_config!]!
}

"aggregate fields of \"application_config\""
type application_config_aggregate_fields {
    avg: application_config_avg_fields
    count(columns: [application_config_select_column!], distinct: Boolean): Int
    max: application_config_max_fields
    min: application_config_min_fields
    stddev: application_config_stddev_fields
    stddev_pop: application_config_stddev_pop_fields
    stddev_samp: application_config_stddev_samp_fields
    sum: application_config_sum_fields
    var_pop: application_config_var_pop_fields
    var_samp: application_config_var_samp_fields
    variance: application_config_variance_fields
}

"aggregate avg on columns"
type application_config_avg_fields {
    immersiveDiscount: Float
}

"aggregate max on columns"
type application_config_max_fields {
    id: uuid
    immersiveDiscount: Int
}

"aggregate min on columns"
type application_config_min_fields {
    id: uuid
    immersiveDiscount: Int
}

"response of any mutation on the table \"application_config\""
type application_config_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [application_config!]!
}

"aggregate stddev on columns"
type application_config_stddev_fields {
    immersiveDiscount: Float
}

"aggregate stddev_pop on columns"
type application_config_stddev_pop_fields {
    immersiveDiscount: Float
}

"aggregate stddev_samp on columns"
type application_config_stddev_samp_fields {
    immersiveDiscount: Float
}

"aggregate sum on columns"
type application_config_sum_fields {
    immersiveDiscount: Int
}

"aggregate var_pop on columns"
type application_config_var_pop_fields {
    immersiveDiscount: Float
}

"aggregate var_samp on columns"
type application_config_var_samp_fields {
    immersiveDiscount: Float
}

"aggregate variance on columns"
type application_config_variance_fields {
    immersiveDiscount: Float
}

"columns and relationships of \"coupons\""
type coupons {
    id: String!
    name: String!
    stripeObject(
        "JSON select path"
        path: String
    ): json!
}

"aggregated selection of \"coupons\""
type coupons_aggregate {
    aggregate: coupons_aggregate_fields
    nodes: [coupons!]!
}

"aggregate fields of \"coupons\""
type coupons_aggregate_fields {
    count(columns: [coupons_select_column!], distinct: Boolean): Int
    max: coupons_max_fields
    min: coupons_min_fields
}

"aggregate max on columns"
type coupons_max_fields {
    id: String
    name: String
}

"aggregate min on columns"
type coupons_min_fields {
    id: String
    name: String
}

"response of any mutation on the table \"coupons\""
type coupons_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [coupons!]!
}

"columns and relationships of \"course_ages\""
type course_ages {
    "An object relationship"
    age: ages!
    ageId: Int!
    "An object relationship"
    course: courses!
    courseId: uuid!
}

"aggregated selection of \"course_ages\""
type course_ages_aggregate {
    aggregate: course_ages_aggregate_fields
    nodes: [course_ages!]!
}

"aggregate fields of \"course_ages\""
type course_ages_aggregate_fields {
    avg: course_ages_avg_fields
    count(columns: [course_ages_select_column!], distinct: Boolean): Int
    max: course_ages_max_fields
    min: course_ages_min_fields
    stddev: course_ages_stddev_fields
    stddev_pop: course_ages_stddev_pop_fields
    stddev_samp: course_ages_stddev_samp_fields
    sum: course_ages_sum_fields
    var_pop: course_ages_var_pop_fields
    var_samp: course_ages_var_samp_fields
    variance: course_ages_variance_fields
}

"aggregate avg on columns"
type course_ages_avg_fields {
    ageId: Float
}

"aggregate max on columns"
type course_ages_max_fields {
    ageId: Int
    courseId: uuid
}

"aggregate min on columns"
type course_ages_min_fields {
    ageId: Int
    courseId: uuid
}

"response of any mutation on the table \"course_ages\""
type course_ages_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [course_ages!]!
}

"aggregate stddev on columns"
type course_ages_stddev_fields {
    ageId: Float
}

"aggregate stddev_pop on columns"
type course_ages_stddev_pop_fields {
    ageId: Float
}

"aggregate stddev_samp on columns"
type course_ages_stddev_samp_fields {
    ageId: Float
}

"aggregate sum on columns"
type course_ages_sum_fields {
    ageId: Int
}

"aggregate var_pop on columns"
type course_ages_var_pop_fields {
    ageId: Float
}

"aggregate var_samp on columns"
type course_ages_var_samp_fields {
    ageId: Float
}

"aggregate variance on columns"
type course_ages_variance_fields {
    ageId: Float
}

"columns and relationships of \"course_grades\""
type course_grades {
    "An object relationship"
    course: courses!
    courseId: uuid!
    "An object relationship"
    grade: grades!
    gradeId: Int!
}

"aggregated selection of \"course_grades\""
type course_grades_aggregate {
    aggregate: course_grades_aggregate_fields
    nodes: [course_grades!]!
}

"aggregate fields of \"course_grades\""
type course_grades_aggregate_fields {
    avg: course_grades_avg_fields
    count(columns: [course_grades_select_column!], distinct: Boolean): Int
    max: course_grades_max_fields
    min: course_grades_min_fields
    stddev: course_grades_stddev_fields
    stddev_pop: course_grades_stddev_pop_fields
    stddev_samp: course_grades_stddev_samp_fields
    sum: course_grades_sum_fields
    var_pop: course_grades_var_pop_fields
    var_samp: course_grades_var_samp_fields
    variance: course_grades_variance_fields
}

"aggregate avg on columns"
type course_grades_avg_fields {
    gradeId: Float
}

"aggregate max on columns"
type course_grades_max_fields {
    courseId: uuid
    gradeId: Int
}

"aggregate min on columns"
type course_grades_min_fields {
    courseId: uuid
    gradeId: Int
}

"response of any mutation on the table \"course_grades\""
type course_grades_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [course_grades!]!
}

"aggregate stddev on columns"
type course_grades_stddev_fields {
    gradeId: Float
}

"aggregate stddev_pop on columns"
type course_grades_stddev_pop_fields {
    gradeId: Float
}

"aggregate stddev_samp on columns"
type course_grades_stddev_samp_fields {
    gradeId: Float
}

"aggregate sum on columns"
type course_grades_sum_fields {
    gradeId: Int
}

"aggregate var_pop on columns"
type course_grades_var_pop_fields {
    gradeId: Float
}

"aggregate var_samp on columns"
type course_grades_var_samp_fields {
    gradeId: Float
}

"aggregate variance on columns"
type course_grades_variance_fields {
    gradeId: Float
}

"columns and relationships of \"course_materials\""
type course_materials {
    courseId: uuid
    id: Int!
    kind: String!
    link: String!
    name: String
    unit: Int!
    unitId: uuid
    week: Int!
}

"aggregated selection of \"course_materials\""
type course_materials_aggregate {
    aggregate: course_materials_aggregate_fields
    nodes: [course_materials!]!
}

"aggregate fields of \"course_materials\""
type course_materials_aggregate_fields {
    avg: course_materials_avg_fields
    count(columns: [course_materials_select_column!], distinct: Boolean): Int
    max: course_materials_max_fields
    min: course_materials_min_fields
    stddev: course_materials_stddev_fields
    stddev_pop: course_materials_stddev_pop_fields
    stddev_samp: course_materials_stddev_samp_fields
    sum: course_materials_sum_fields
    var_pop: course_materials_var_pop_fields
    var_samp: course_materials_var_samp_fields
    variance: course_materials_variance_fields
}

"aggregate avg on columns"
type course_materials_avg_fields {
    id: Float
    unit: Float
    week: Float
}

"aggregate max on columns"
type course_materials_max_fields {
    courseId: uuid
    id: Int
    kind: String
    link: String
    name: String
    unit: Int
    unitId: uuid
    week: Int
}

"aggregate min on columns"
type course_materials_min_fields {
    courseId: uuid
    id: Int
    kind: String
    link: String
    name: String
    unit: Int
    unitId: uuid
    week: Int
}

"response of any mutation on the table \"course_materials\""
type course_materials_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [course_materials!]!
}

"aggregate stddev on columns"
type course_materials_stddev_fields {
    id: Float
    unit: Float
    week: Float
}

"aggregate stddev_pop on columns"
type course_materials_stddev_pop_fields {
    id: Float
    unit: Float
    week: Float
}

"aggregate stddev_samp on columns"
type course_materials_stddev_samp_fields {
    id: Float
    unit: Float
    week: Float
}

"aggregate sum on columns"
type course_materials_sum_fields {
    id: Int
    unit: Int
    week: Int
}

"aggregate var_pop on columns"
type course_materials_var_pop_fields {
    id: Float
    unit: Float
    week: Float
}

"aggregate var_samp on columns"
type course_materials_var_samp_fields {
    id: Float
    unit: Float
    week: Float
}

"aggregate variance on columns"
type course_materials_variance_fields {
    id: Float
    unit: Float
    week: Float
}

"columns and relationships of \"course_types\""
type course_types {
    description: String!
    sortOrder: Int!
    value: String!
}

"aggregated selection of \"course_types\""
type course_types_aggregate {
    aggregate: course_types_aggregate_fields
    nodes: [course_types!]!
}

"aggregate fields of \"course_types\""
type course_types_aggregate_fields {
    avg: course_types_avg_fields
    count(columns: [course_types_select_column!], distinct: Boolean): Int
    max: course_types_max_fields
    min: course_types_min_fields
    stddev: course_types_stddev_fields
    stddev_pop: course_types_stddev_pop_fields
    stddev_samp: course_types_stddev_samp_fields
    sum: course_types_sum_fields
    var_pop: course_types_var_pop_fields
    var_samp: course_types_var_samp_fields
    variance: course_types_variance_fields
}

"aggregate avg on columns"
type course_types_avg_fields {
    sortOrder: Float
}

"aggregate max on columns"
type course_types_max_fields {
    description: String
    sortOrder: Int
    value: String
}

"aggregate min on columns"
type course_types_min_fields {
    description: String
    sortOrder: Int
    value: String
}

"response of any mutation on the table \"course_types\""
type course_types_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [course_types!]!
}

"aggregate stddev on columns"
type course_types_stddev_fields {
    sortOrder: Float
}

"aggregate stddev_pop on columns"
type course_types_stddev_pop_fields {
    sortOrder: Float
}

"aggregate stddev_samp on columns"
type course_types_stddev_samp_fields {
    sortOrder: Float
}

"aggregate sum on columns"
type course_types_sum_fields {
    sortOrder: Int
}

"aggregate var_pop on columns"
type course_types_var_pop_fields {
    sortOrder: Float
}

"aggregate var_samp on columns"
type course_types_var_samp_fields {
    sortOrder: Float
}

"aggregate variance on columns"
type course_types_variance_fields {
    sortOrder: Float
}

"columns and relationships of \"courses\""
type courses {
    "A computed field, executes function \"get_ages_display\""
    academic: String
    "An array relationship"
    ages(
        "distinct select on columns"
        distinct_on: [course_ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_ages_order_by!],
        "filter the rows returned"
        where: course_ages_bool_exp
    ): [course_ages!]!
    "An aggregated array relationship"
    ages_aggregate(
        "distinct select on columns"
        distinct_on: [course_ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_ages_order_by!],
        "filter the rows returned"
        where: course_ages_bool_exp
    ): course_ages_aggregate!
    capacity: Int!
    "An array relationship"
    cohorts(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): [instructor_enrollments!]!
    "An aggregated array relationship"
    cohorts_aggregate(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): instructor_enrollments_aggregate!
    "An object relationship"
    courseType: course_types!
    description: String!
    "An object relationship"
    duration: durations!
    durationId: Int!
    "An array relationship"
    enrollments(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): [student_enrollments!]!
    "An aggregated array relationship"
    enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): student_enrollments_aggregate!
    featured: Boolean!
    "An object relationship"
    frequency: frequency_types!
    frequencyType: frequency_types_enum!
    "An array relationship"
    grades(
        "distinct select on columns"
        distinct_on: [course_grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_grades_order_by!],
        "filter the rows returned"
        where: course_grades_bool_exp
    ): [course_grades!]!
    "An aggregated array relationship"
    grades_aggregate(
        "distinct select on columns"
        distinct_on: [course_grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_grades_order_by!],
        "filter the rows returned"
        where: course_grades_bool_exp
    ): course_grades_aggregate!
    headline: String
    "An object relationship"
    hero: uploads
    heroId: uuid
    id: uuid!
    kind: String!
    name: String!
    price: numeric
    "A computed field, executes function \"get_course_pricing_info\""
    pricing(
        "JSON select path"
        path: String
    ): json
    "An array relationship"
    schedules(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): [schedules!]!
    "An aggregated array relationship"
    schedules_aggregate(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): schedules_aggregate!
    slug: String
    "An object relationship"
    subject: subjects!
    subjectId: uuid!
    "An array relationship"
    testimonials(
        "distinct select on columns"
        distinct_on: [testimonials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [testimonials_order_by!],
        "filter the rows returned"
        where: testimonials_bool_exp
    ): [testimonials!]!
    "An aggregated array relationship"
    testimonials_aggregate(
        "distinct select on columns"
        distinct_on: [testimonials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [testimonials_order_by!],
        "filter the rows returned"
        where: testimonials_bool_exp
    ): testimonials_aggregate!
    "An object relationship"
    thumb: uploads
    thumbId: uuid
    totalClasses: Int!
    "An array relationship"
    units(
        "distinct select on columns"
        distinct_on: [units_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [units_order_by!],
        "filter the rows returned"
        where: units_bool_exp
    ): [units!]!
    "An aggregated array relationship"
    units_aggregate(
        "distinct select on columns"
        distinct_on: [units_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [units_order_by!],
        "filter the rows returned"
        where: units_bool_exp
    ): units_aggregate!
    "youtube video link"
    videoLink: String
    "An array relationship"
    zoomMeetings(
        "distinct select on columns"
        distinct_on: [zoom_meetings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [zoom_meetings_order_by!],
        "filter the rows returned"
        where: zoom_meetings_bool_exp
    ): [zoom_meetings!]!
    "An aggregated array relationship"
    zoomMeetings_aggregate(
        "distinct select on columns"
        distinct_on: [zoom_meetings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [zoom_meetings_order_by!],
        "filter the rows returned"
        where: zoom_meetings_bool_exp
    ): zoom_meetings_aggregate!
}

"aggregated selection of \"courses\""
type courses_aggregate {
    aggregate: courses_aggregate_fields
    nodes: [courses!]!
}

"aggregate fields of \"courses\""
type courses_aggregate_fields {
    avg: courses_avg_fields
    count(columns: [courses_select_column!], distinct: Boolean): Int
    max: courses_max_fields
    min: courses_min_fields
    stddev: courses_stddev_fields
    stddev_pop: courses_stddev_pop_fields
    stddev_samp: courses_stddev_samp_fields
    sum: courses_sum_fields
    var_pop: courses_var_pop_fields
    var_samp: courses_var_samp_fields
    variance: courses_variance_fields
}

"aggregate avg on columns"
type courses_avg_fields {
    capacity: Float
    durationId: Float
    price: Float
    totalClasses: Float
}

"aggregate max on columns"
type courses_max_fields {
    capacity: Int
    description: String
    durationId: Int
    headline: String
    heroId: uuid
    id: uuid
    kind: String
    name: String
    price: numeric
    slug: String
    subjectId: uuid
    thumbId: uuid
    totalClasses: Int
    videoLink: String
}

"aggregate min on columns"
type courses_min_fields {
    capacity: Int
    description: String
    durationId: Int
    headline: String
    heroId: uuid
    id: uuid
    kind: String
    name: String
    price: numeric
    slug: String
    subjectId: uuid
    thumbId: uuid
    totalClasses: Int
    videoLink: String
}

"response of any mutation on the table \"courses\""
type courses_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [courses!]!
}

"aggregate stddev on columns"
type courses_stddev_fields {
    capacity: Float
    durationId: Float
    price: Float
    totalClasses: Float
}

"aggregate stddev_pop on columns"
type courses_stddev_pop_fields {
    capacity: Float
    durationId: Float
    price: Float
    totalClasses: Float
}

"aggregate stddev_samp on columns"
type courses_stddev_samp_fields {
    capacity: Float
    durationId: Float
    price: Float
    totalClasses: Float
}

"aggregate sum on columns"
type courses_sum_fields {
    capacity: Int
    durationId: Int
    price: numeric
    totalClasses: Int
}

"aggregate var_pop on columns"
type courses_var_pop_fields {
    capacity: Float
    durationId: Float
    price: Float
    totalClasses: Float
}

"aggregate var_samp on columns"
type courses_var_samp_fields {
    capacity: Float
    durationId: Float
    price: Float
    totalClasses: Float
}

"aggregate variance on columns"
type courses_variance_fields {
    capacity: Float
    durationId: Float
    price: Float
    totalClasses: Float
}

"columns and relationships of \"durations\""
type durations {
    id: Int!
    minutes: Int!
    name: String!
}

"aggregated selection of \"durations\""
type durations_aggregate {
    aggregate: durations_aggregate_fields
    nodes: [durations!]!
}

"aggregate fields of \"durations\""
type durations_aggregate_fields {
    avg: durations_avg_fields
    count(columns: [durations_select_column!], distinct: Boolean): Int
    max: durations_max_fields
    min: durations_min_fields
    stddev: durations_stddev_fields
    stddev_pop: durations_stddev_pop_fields
    stddev_samp: durations_stddev_samp_fields
    sum: durations_sum_fields
    var_pop: durations_var_pop_fields
    var_samp: durations_var_samp_fields
    variance: durations_variance_fields
}

"aggregate avg on columns"
type durations_avg_fields {
    id: Float
    minutes: Float
}

"aggregate max on columns"
type durations_max_fields {
    id: Int
    minutes: Int
    name: String
}

"aggregate min on columns"
type durations_min_fields {
    id: Int
    minutes: Int
    name: String
}

"response of any mutation on the table \"durations\""
type durations_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [durations!]!
}

"aggregate stddev on columns"
type durations_stddev_fields {
    id: Float
    minutes: Float
}

"aggregate stddev_pop on columns"
type durations_stddev_pop_fields {
    id: Float
    minutes: Float
}

"aggregate stddev_samp on columns"
type durations_stddev_samp_fields {
    id: Float
    minutes: Float
}

"aggregate sum on columns"
type durations_sum_fields {
    id: Int
    minutes: Int
}

"aggregate var_pop on columns"
type durations_var_pop_fields {
    id: Float
    minutes: Float
}

"aggregate var_samp on columns"
type durations_var_samp_fields {
    id: Float
    minutes: Float
}

"aggregate variance on columns"
type durations_variance_fields {
    id: Float
    minutes: Float
}

"columns and relationships of \"enrollment_info\""
type enrollment_info {
    check: String
    comparison: String
    data(
        "JSON select path"
        path: String
    ): json
    entities: _json
    entityids(
        "JSON select path"
        path: String
    ): json
    id: Int
    "An object relationship"
    organization: schools
    organizationId: uuid
    "An object relationship"
    student: students
    studentId: uuid
    studentInternalId: String
}

"aggregated selection of \"enrollment_info\""
type enrollment_info_aggregate {
    aggregate: enrollment_info_aggregate_fields
    nodes: [enrollment_info!]!
}

"aggregate fields of \"enrollment_info\""
type enrollment_info_aggregate_fields {
    avg: enrollment_info_avg_fields
    count(columns: [enrollment_info_select_column!], distinct: Boolean): Int
    max: enrollment_info_max_fields
    min: enrollment_info_min_fields
    stddev: enrollment_info_stddev_fields
    stddev_pop: enrollment_info_stddev_pop_fields
    stddev_samp: enrollment_info_stddev_samp_fields
    sum: enrollment_info_sum_fields
    var_pop: enrollment_info_var_pop_fields
    var_samp: enrollment_info_var_samp_fields
    variance: enrollment_info_variance_fields
}

"aggregate avg on columns"
type enrollment_info_avg_fields {
    id: Float
}

"aggregate max on columns"
type enrollment_info_max_fields {
    check: String
    comparison: String
    id: Int
    organizationId: uuid
    studentId: uuid
    studentInternalId: String
}

"aggregate min on columns"
type enrollment_info_min_fields {
    check: String
    comparison: String
    id: Int
    organizationId: uuid
    studentId: uuid
    studentInternalId: String
}

"response of any mutation on the table \"enrollment_info\""
type enrollment_info_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [enrollment_info!]!
}

"aggregate stddev on columns"
type enrollment_info_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type enrollment_info_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type enrollment_info_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type enrollment_info_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type enrollment_info_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type enrollment_info_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type enrollment_info_variance_fields {
    id: Float
}

"columns and relationships of \"enrollment_rules\""
type enrollment_rules {
    data(
        "JSON select path"
        path: String
    ): json!
    id: Int!
    "An object relationship"
    info: enrollment_info
    "An object relationship"
    organization: schools
    organizationId: uuid
    "An object relationship"
    student: students
    studentInternalId: String
}

"aggregated selection of \"enrollment_rules\""
type enrollment_rules_aggregate {
    aggregate: enrollment_rules_aggregate_fields
    nodes: [enrollment_rules!]!
}

"aggregate fields of \"enrollment_rules\""
type enrollment_rules_aggregate_fields {
    avg: enrollment_rules_avg_fields
    count(columns: [enrollment_rules_select_column!], distinct: Boolean): Int
    max: enrollment_rules_max_fields
    min: enrollment_rules_min_fields
    stddev: enrollment_rules_stddev_fields
    stddev_pop: enrollment_rules_stddev_pop_fields
    stddev_samp: enrollment_rules_stddev_samp_fields
    sum: enrollment_rules_sum_fields
    var_pop: enrollment_rules_var_pop_fields
    var_samp: enrollment_rules_var_samp_fields
    variance: enrollment_rules_variance_fields
}

"aggregate avg on columns"
type enrollment_rules_avg_fields {
    id: Float
}

"aggregate max on columns"
type enrollment_rules_max_fields {
    id: Int
    organizationId: uuid
    studentInternalId: String
}

"aggregate min on columns"
type enrollment_rules_min_fields {
    id: Int
    organizationId: uuid
    studentInternalId: String
}

"response of any mutation on the table \"enrollment_rules\""
type enrollment_rules_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [enrollment_rules!]!
}

"aggregate stddev on columns"
type enrollment_rules_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type enrollment_rules_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type enrollment_rules_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type enrollment_rules_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type enrollment_rules_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type enrollment_rules_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type enrollment_rules_variance_fields {
    id: Float
}

"columns and relationships of \"frequency_types\""
type frequency_types {
    "An array relationship"
    courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "An aggregated array relationship"
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    description: String!
    value: String!
}

"aggregated selection of \"frequency_types\""
type frequency_types_aggregate {
    aggregate: frequency_types_aggregate_fields
    nodes: [frequency_types!]!
}

"aggregate fields of \"frequency_types\""
type frequency_types_aggregate_fields {
    count(columns: [frequency_types_select_column!], distinct: Boolean): Int
    max: frequency_types_max_fields
    min: frequency_types_min_fields
}

"aggregate max on columns"
type frequency_types_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type frequency_types_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"frequency_types\""
type frequency_types_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [frequency_types!]!
}

"columns and relationships of \"gender_types\""
type gender_types {
    description: String!
    "An array relationship"
    students(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): [students!]!
    "An aggregated array relationship"
    students_aggregate(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): students_aggregate!
    value: String!
}

"aggregated selection of \"gender_types\""
type gender_types_aggregate {
    aggregate: gender_types_aggregate_fields
    nodes: [gender_types!]!
}

"aggregate fields of \"gender_types\""
type gender_types_aggregate_fields {
    count(columns: [gender_types_select_column!], distinct: Boolean): Int
    max: gender_types_max_fields
    min: gender_types_min_fields
}

"aggregate max on columns"
type gender_types_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type gender_types_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"gender_types\""
type gender_types_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [gender_types!]!
}

"columns and relationships of \"grades\""
type grades {
    "An array relationship"
    courses(
        "distinct select on columns"
        distinct_on: [course_grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_grades_order_by!],
        "filter the rows returned"
        where: course_grades_bool_exp
    ): [course_grades!]!
    "An aggregated array relationship"
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [course_grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_grades_order_by!],
        "filter the rows returned"
        where: course_grades_bool_exp
    ): course_grades_aggregate!
    id: Int!
    name: String!
    "An array relationship"
    students(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): [students!]!
    "An aggregated array relationship"
    students_aggregate(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): students_aggregate!
}

"aggregated selection of \"grades\""
type grades_aggregate {
    aggregate: grades_aggregate_fields
    nodes: [grades!]!
}

"aggregate fields of \"grades\""
type grades_aggregate_fields {
    avg: grades_avg_fields
    count(columns: [grades_select_column!], distinct: Boolean): Int
    max: grades_max_fields
    min: grades_min_fields
    stddev: grades_stddev_fields
    stddev_pop: grades_stddev_pop_fields
    stddev_samp: grades_stddev_samp_fields
    sum: grades_sum_fields
    var_pop: grades_var_pop_fields
    var_samp: grades_var_samp_fields
    variance: grades_variance_fields
}

"aggregate avg on columns"
type grades_avg_fields {
    id: Float
}

"aggregate max on columns"
type grades_max_fields {
    id: Int
    name: String
}

"aggregate min on columns"
type grades_min_fields {
    id: Int
    name: String
}

"response of any mutation on the table \"grades\""
type grades_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [grades!]!
}

"aggregate stddev on columns"
type grades_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type grades_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type grades_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type grades_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type grades_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type grades_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type grades_variance_fields {
    id: Float
}

"columns and relationships of \"instructor_enrollments\""
type instructor_enrollments {
    canEnroll: Boolean!
    capacity: Int!
    "An object relationship"
    course: courses!
    courseId: uuid!
    "A computed field, executes function \"get_enrollment_days\""
    days: String
    "An object relationship"
    duration: durations!
    durationId: Int!
    endTime: timestamptz
    frequencyType: frequency_types_enum!
    id: uuid!
    "An object relationship"
    instructor: users
    instructorId: uuid
    lookupId: String
    "A computed field, executes function \"get_instructor_enrollment_course_materials\""
    materials(
        "JSON select path"
        path: String
    ): json
    "An array relationship"
    meetingEnrollments(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): [student_meeting_enrollments!]!
    "An aggregated array relationship"
    meetingEnrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): student_meeting_enrollments_aggregate!
    "A computed field, executes function \"get_instructor_enrollment_occurrence_breakdown\""
    occurrences(
        "JSON select path"
        path: String
    ): json
    published: Boolean!
    "An array relationship"
    schedules(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): [schedules!]!
    "An aggregated array relationship"
    schedules_aggregate(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): schedules_aggregate!
    seatsAvailable: Int
    startTime: timestamptz
    "An array relationship"
    studentEnrollments(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): [student_enrollments!]!
    "An aggregated array relationship"
    studentEnrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): student_enrollments_aggregate!
    totalSessions: Int
    "An object relationship"
    unit: units
    unitId: uuid
    "An array relationship"
    zoomMeetings(
        "distinct select on columns"
        distinct_on: [zoom_meetings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [zoom_meetings_order_by!],
        "filter the rows returned"
        where: zoom_meetings_bool_exp
    ): [zoom_meetings!]!
    "An aggregated array relationship"
    zoomMeetings_aggregate(
        "distinct select on columns"
        distinct_on: [zoom_meetings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [zoom_meetings_order_by!],
        "filter the rows returned"
        where: zoom_meetings_bool_exp
    ): zoom_meetings_aggregate!
}

"aggregated selection of \"instructor_enrollments\""
type instructor_enrollments_aggregate {
    aggregate: instructor_enrollments_aggregate_fields
    nodes: [instructor_enrollments!]!
}

"aggregate fields of \"instructor_enrollments\""
type instructor_enrollments_aggregate_fields {
    avg: instructor_enrollments_avg_fields
    count(columns: [instructor_enrollments_select_column!], distinct: Boolean): Int
    max: instructor_enrollments_max_fields
    min: instructor_enrollments_min_fields
    stddev: instructor_enrollments_stddev_fields
    stddev_pop: instructor_enrollments_stddev_pop_fields
    stddev_samp: instructor_enrollments_stddev_samp_fields
    sum: instructor_enrollments_sum_fields
    var_pop: instructor_enrollments_var_pop_fields
    var_samp: instructor_enrollments_var_samp_fields
    variance: instructor_enrollments_variance_fields
}

"aggregate avg on columns"
type instructor_enrollments_avg_fields {
    capacity: Float
    durationId: Float
    seatsAvailable: Float
    totalSessions: Float
}

"aggregate max on columns"
type instructor_enrollments_max_fields {
    capacity: Int
    courseId: uuid
    durationId: Int
    endTime: timestamptz
    id: uuid
    instructorId: uuid
    lookupId: String
    seatsAvailable: Int
    startTime: timestamptz
    totalSessions: Int
    unitId: uuid
}

"aggregate min on columns"
type instructor_enrollments_min_fields {
    capacity: Int
    courseId: uuid
    durationId: Int
    endTime: timestamptz
    id: uuid
    instructorId: uuid
    lookupId: String
    seatsAvailable: Int
    startTime: timestamptz
    totalSessions: Int
    unitId: uuid
}

"response of any mutation on the table \"instructor_enrollments\""
type instructor_enrollments_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [instructor_enrollments!]!
}

"aggregate stddev on columns"
type instructor_enrollments_stddev_fields {
    capacity: Float
    durationId: Float
    seatsAvailable: Float
    totalSessions: Float
}

"aggregate stddev_pop on columns"
type instructor_enrollments_stddev_pop_fields {
    capacity: Float
    durationId: Float
    seatsAvailable: Float
    totalSessions: Float
}

"aggregate stddev_samp on columns"
type instructor_enrollments_stddev_samp_fields {
    capacity: Float
    durationId: Float
    seatsAvailable: Float
    totalSessions: Float
}

"aggregate sum on columns"
type instructor_enrollments_sum_fields {
    capacity: Int
    durationId: Int
    seatsAvailable: Int
    totalSessions: Int
}

"aggregate var_pop on columns"
type instructor_enrollments_var_pop_fields {
    capacity: Float
    durationId: Float
    seatsAvailable: Float
    totalSessions: Float
}

"aggregate var_samp on columns"
type instructor_enrollments_var_samp_fields {
    capacity: Float
    durationId: Float
    seatsAvailable: Float
    totalSessions: Float
}

"aggregate variance on columns"
type instructor_enrollments_variance_fields {
    capacity: Float
    durationId: Float
    seatsAvailable: Float
    totalSessions: Float
}

"mutation root"
type mutation_root {
    cancelAllSubscriptions: String
    cancelSubscription(subscriptionId: uuid!): String
    changeEmail(currentEmail: String!, newEmail: String!): ChangeEmailOutput
    createCohort(input: NewCohortInput): uuid
    createSchool(input: CreateSchoolInput!): uuid
    deleteCohort(id: uuid!): uuid
    deleteTeacher(id: uuid!, transferTo: uuid): DeleteTeacherOutput
    "delete data from the table: \"ages\""
    delete_ages(
        "filter the rows which have to be deleted"
        where: ages_bool_exp!
    ): ages_mutation_response
    "delete single row from the table: \"ages\""
    delete_ages_by_pk(id: Int!): ages
    "delete data from the table: \"application_config\""
    delete_application_config(
        "filter the rows which have to be deleted"
        where: application_config_bool_exp!
    ): application_config_mutation_response
    "delete single row from the table: \"application_config\""
    delete_application_config_by_pk(id: uuid!): application_config
    "delete single row from the table: \"coupons\""
    delete_coupon(id: String!): coupons
    "delete data from the table: \"coupons\""
    delete_coupons(
        "filter the rows which have to be deleted"
        where: coupons_bool_exp!
    ): coupons_mutation_response
    "delete single row from the table: \"courses\""
    delete_course(id: uuid!): courses
    "delete data from the table: \"course_ages\""
    delete_course_ages(
        "filter the rows which have to be deleted"
        where: course_ages_bool_exp!
    ): course_ages_mutation_response
    "delete single row from the table: \"course_ages\""
    delete_course_ages_by_pk(ageId: Int!, courseId: uuid!): course_ages
    "delete data from the table: \"course_grades\""
    delete_course_grades(
        "filter the rows which have to be deleted"
        where: course_grades_bool_exp!
    ): course_grades_mutation_response
    "delete single row from the table: \"course_grades\""
    delete_course_grades_by_pk(courseId: uuid!, gradeId: Int!): course_grades
    "delete single row from the table: \"course_materials\""
    delete_course_material(id: Int!): course_materials
    "delete data from the table: \"course_materials\""
    delete_course_materials(
        "filter the rows which have to be deleted"
        where: course_materials_bool_exp!
    ): course_materials_mutation_response
    "delete data from the table: \"course_types\""
    delete_course_types(
        "filter the rows which have to be deleted"
        where: course_types_bool_exp!
    ): course_types_mutation_response
    "delete single row from the table: \"course_types\""
    delete_course_types_by_pk(value: String!): course_types
    "delete data from the table: \"courses\""
    delete_courses(
        "filter the rows which have to be deleted"
        where: courses_bool_exp!
    ): courses_mutation_response
    "delete data from the table: \"durations\""
    delete_durations(
        "filter the rows which have to be deleted"
        where: durations_bool_exp!
    ): durations_mutation_response
    "delete single row from the table: \"durations\""
    delete_durations_by_pk(id: Int!): durations
    "delete data from the table: \"enrollment_info\""
    delete_enrollment_info(
        "filter the rows which have to be deleted"
        where: enrollment_info_bool_exp!
    ): enrollment_info_mutation_response
    "delete single row from the table: \"enrollment_rules\""
    delete_enrollment_rule(id: Int!): enrollment_rules
    "delete data from the table: \"enrollment_rules\""
    delete_enrollment_rules(
        "filter the rows which have to be deleted"
        where: enrollment_rules_bool_exp!
    ): enrollment_rules_mutation_response
    "delete data from the table: \"frequency_types\""
    delete_frequency_types(
        "filter the rows which have to be deleted"
        where: frequency_types_bool_exp!
    ): frequency_types_mutation_response
    "delete single row from the table: \"frequency_types\""
    delete_frequency_types_by_pk(value: String!): frequency_types
    "delete data from the table: \"gender_types\""
    delete_gender_types(
        "filter the rows which have to be deleted"
        where: gender_types_bool_exp!
    ): gender_types_mutation_response
    "delete single row from the table: \"gender_types\""
    delete_gender_types_by_pk(value: String!): gender_types
    "delete data from the table: \"grades\""
    delete_grades(
        "filter the rows which have to be deleted"
        where: grades_bool_exp!
    ): grades_mutation_response
    "delete single row from the table: \"grades\""
    delete_grades_by_pk(id: Int!): grades
    "delete single row from the table: \"instructor_enrollments\""
    delete_instructor_enrollment(id: uuid!): instructor_enrollments
    "delete data from the table: \"instructor_enrollments\""
    delete_instructor_enrollments(
        "filter the rows which have to be deleted"
        where: instructor_enrollments_bool_exp!
    ): instructor_enrollments_mutation_response
    "delete single row from the table: \"schools\""
    delete_organization(id: uuid!): schools
    "delete single row from the table: \"schools_domains\""
    delete_organization_domain(id: uuid!): schools_domains
    "delete data from the table: \"schools_domains\""
    delete_organization_domains(
        "filter the rows which have to be deleted"
        where: schools_domains_bool_exp!
    ): schools_domains_mutation_response
    "delete data from the table: \"schools\""
    delete_organizations(
        "filter the rows which have to be deleted"
        where: schools_bool_exp!
    ): schools_mutation_response
    "delete single row from the table: \"products\""
    delete_product(id: String!): products
    "delete single row from the table: \"product_prices\""
    delete_product_price(id: String!): product_prices
    "delete data from the table: \"product_prices\""
    delete_product_prices(
        "filter the rows which have to be deleted"
        where: product_prices_bool_exp!
    ): product_prices_mutation_response
    "delete data from the table: \"products\""
    delete_products(
        "filter the rows which have to be deleted"
        where: products_bool_exp!
    ): products_mutation_response
    "delete single row from the table: \"promo_codes\""
    delete_promo_code(id: String!): promo_codes
    "delete data from the table: \"promo_codes\""
    delete_promo_codes(
        "filter the rows which have to be deleted"
        where: promo_codes_bool_exp!
    ): promo_codes_mutation_response
    "delete data from the table: \"redirect_mapping\""
    delete_redirect_mapping(
        "filter the rows which have to be deleted"
        where: redirect_mapping_bool_exp!
    ): redirect_mapping_mutation_response
    "delete single row from the table: \"redirect_mapping\""
    delete_redirect_mapping_by_pk(from_slug: String!, to_slug: String!): redirect_mapping
    "delete data from the table: \"schedules\""
    delete_schedules(
        "filter the rows which have to be deleted"
        where: schedules_bool_exp!
    ): schedules_mutation_response
    "delete single row from the table: \"schedules\""
    delete_schedules_by_pk(id: uuid!): schedules
    "delete single row from the table: \"stripe_customers\""
    delete_stripe_customer(profileId: uuid!): stripe_customers
    "delete data from the table: \"stripe_customers\""
    delete_stripe_customers(
        "filter the rows which have to be deleted"
        where: stripe_customers_bool_exp!
    ): stripe_customers_mutation_response
    "delete single row from the table: \"students\""
    delete_student(id: uuid!): students
    "delete single row from the table: \"student_enrollments\""
    delete_student_enrollment(id: uuid!): student_enrollments
    "delete data from the table: \"student_enrollments\""
    delete_student_enrollments(
        "filter the rows which have to be deleted"
        where: student_enrollments_bool_exp!
    ): student_enrollments_mutation_response
    "delete data from the table: \"student_meeting_enrollments\""
    delete_student_meeting_enrollments(
        "filter the rows which have to be deleted"
        where: student_meeting_enrollments_bool_exp!
    ): student_meeting_enrollments_mutation_response
    "delete single row from the table: \"student_meeting_enrollments\""
    delete_student_meeting_enrollments_by_pk(id: uuid!): student_meeting_enrollments
    "delete data from the table: \"students\""
    delete_students(
        "filter the rows which have to be deleted"
        where: students_bool_exp!
    ): students_mutation_response
    "delete single row from the table: \"subjects\""
    delete_subject(id: uuid!): subjects
    "delete data from the table: \"subjects\""
    delete_subjects(
        "filter the rows which have to be deleted"
        where: subjects_bool_exp!
    ): subjects_mutation_response
    "delete single row from the table: \"subscriptions\""
    delete_subscription(id: uuid!): subscriptions
    "delete data from the table: \"subscription_status\""
    delete_subscription_status(
        "filter the rows which have to be deleted"
        where: subscription_status_bool_exp!
    ): subscription_status_mutation_response
    "delete single row from the table: \"subscription_status\""
    delete_subscription_status_by_pk(value: String!): subscription_status
    "delete data from the table: \"subscriptions\""
    delete_subscriptions(
        "filter the rows which have to be deleted"
        where: subscriptions_bool_exp!
    ): subscriptions_mutation_response
    "delete single row from the table: \"testimonials\""
    delete_testimonial(id: Int!): testimonials
    "delete data from the table: \"testimonials\""
    delete_testimonials(
        "filter the rows which have to be deleted"
        where: testimonials_bool_exp!
    ): testimonials_mutation_response
    "delete single row from the table: \"units\""
    delete_unit(id: uuid!): units
    "delete data from the table: \"units\""
    delete_units(
        "filter the rows which have to be deleted"
        where: units_bool_exp!
    ): units_mutation_response
    "delete data from the table: \"uploads\""
    delete_uploads(
        "filter the rows which have to be deleted"
        where: uploads_bool_exp!
    ): uploads_mutation_response
    "delete single row from the table: \"uploads\""
    delete_uploads_by_pk(id: uuid!): uploads
    "delete single row from the table: \"users\""
    delete_user(id: uuid!): users
    "delete data from the table: \"user_roles\""
    delete_user_roles(
        "filter the rows which have to be deleted"
        where: user_roles_bool_exp!
    ): user_roles_mutation_response
    "delete single row from the table: \"user_roles\""
    delete_user_roles_by_pk(value: String!): user_roles
    "delete data from the table: \"users\""
    delete_users(
        "filter the rows which have to be deleted"
        where: users_bool_exp!
    ): users_mutation_response
    "delete single row from the table: \"waitlists\""
    delete_waitlist(id: uuid!): waitlists
    "delete data from the table: \"waitlists\""
    delete_waitlists(
        "filter the rows which have to be deleted"
        where: waitlists_bool_exp!
    ): waitlists_mutation_response
    "delete single row from the table: \"zoom_meetings\""
    delete_zoom_meeting(id: uuid!): zoom_meetings
    "delete data from the table: \"zoom_meetings\""
    delete_zoom_meetings(
        "filter the rows which have to be deleted"
        where: zoom_meetings_bool_exp!
    ): zoom_meetings_mutation_response
    editSchedule(id: uuid!, startTime: timestamptz!, timeZone: String!): ScheduleRef
    "perform the action: \"enroll\""
    enroll(cohortId: uuid!, paymentMethodId: String, productId: String, promoCode: String, studentId: uuid): EnrollOutput
    initiateUpload(contentType: String!, id: uuid, name: String!): SignedUpload
    "insert data into the table: \"ages\""
    insert_ages(
        "the rows to be inserted"
        objects: [ages_insert_input!]!,
        "on conflict condition"
        on_conflict: ages_on_conflict
    ): ages_mutation_response
    "insert a single row into the table: \"ages\""
    insert_ages_one(
        "the row to be inserted"
        object: ages_insert_input!,
        "on conflict condition"
        on_conflict: ages_on_conflict
    ): ages
    "insert data into the table: \"application_config\""
    insert_application_config(
        "the rows to be inserted"
        objects: [application_config_insert_input!]!,
        "on conflict condition"
        on_conflict: application_config_on_conflict
    ): application_config_mutation_response
    "insert a single row into the table: \"application_config\""
    insert_application_config_one(
        "the row to be inserted"
        object: application_config_insert_input!,
        "on conflict condition"
        on_conflict: application_config_on_conflict
    ): application_config
    "insert a single row into the table: \"coupons\""
    insert_coupon(
        "the row to be inserted"
        object: coupons_insert_input!,
        "on conflict condition"
        on_conflict: coupons_on_conflict
    ): coupons
    "insert data into the table: \"coupons\""
    insert_coupons(
        "the rows to be inserted"
        objects: [coupons_insert_input!]!,
        "on conflict condition"
        on_conflict: coupons_on_conflict
    ): coupons_mutation_response
    "insert a single row into the table: \"courses\""
    insert_course(
        "the row to be inserted"
        object: courses_insert_input!,
        "on conflict condition"
        on_conflict: courses_on_conflict
    ): courses
    "insert data into the table: \"course_ages\""
    insert_course_ages(
        "the rows to be inserted"
        objects: [course_ages_insert_input!]!,
        "on conflict condition"
        on_conflict: course_ages_on_conflict
    ): course_ages_mutation_response
    "insert a single row into the table: \"course_ages\""
    insert_course_ages_one(
        "the row to be inserted"
        object: course_ages_insert_input!,
        "on conflict condition"
        on_conflict: course_ages_on_conflict
    ): course_ages
    "insert data into the table: \"course_grades\""
    insert_course_grades(
        "the rows to be inserted"
        objects: [course_grades_insert_input!]!,
        "on conflict condition"
        on_conflict: course_grades_on_conflict
    ): course_grades_mutation_response
    "insert a single row into the table: \"course_grades\""
    insert_course_grades_one(
        "the row to be inserted"
        object: course_grades_insert_input!,
        "on conflict condition"
        on_conflict: course_grades_on_conflict
    ): course_grades
    "insert a single row into the table: \"course_materials\""
    insert_course_material(
        "the row to be inserted"
        object: course_materials_insert_input!,
        "on conflict condition"
        on_conflict: course_materials_on_conflict
    ): course_materials
    "insert data into the table: \"course_materials\""
    insert_course_materials(
        "the rows to be inserted"
        objects: [course_materials_insert_input!]!,
        "on conflict condition"
        on_conflict: course_materials_on_conflict
    ): course_materials_mutation_response
    "insert data into the table: \"course_types\""
    insert_course_types(
        "the rows to be inserted"
        objects: [course_types_insert_input!]!,
        "on conflict condition"
        on_conflict: course_types_on_conflict
    ): course_types_mutation_response
    "insert a single row into the table: \"course_types\""
    insert_course_types_one(
        "the row to be inserted"
        object: course_types_insert_input!,
        "on conflict condition"
        on_conflict: course_types_on_conflict
    ): course_types
    "insert data into the table: \"courses\""
    insert_courses(
        "the rows to be inserted"
        objects: [courses_insert_input!]!,
        "on conflict condition"
        on_conflict: courses_on_conflict
    ): courses_mutation_response
    "insert data into the table: \"durations\""
    insert_durations(
        "the rows to be inserted"
        objects: [durations_insert_input!]!,
        "on conflict condition"
        on_conflict: durations_on_conflict
    ): durations_mutation_response
    "insert a single row into the table: \"durations\""
    insert_durations_one(
        "the row to be inserted"
        object: durations_insert_input!,
        "on conflict condition"
        on_conflict: durations_on_conflict
    ): durations
    "insert data into the table: \"enrollment_info\""
    insert_enrollment_info(
        "the rows to be inserted"
        objects: [enrollment_info_insert_input!]!
    ): enrollment_info_mutation_response
    "insert a single row into the table: \"enrollment_info\""
    insert_enrollment_info_one(
        "the row to be inserted"
        object: enrollment_info_insert_input!
    ): enrollment_info
    "insert a single row into the table: \"enrollment_rules\""
    insert_enrollment_rule(
        "the row to be inserted"
        object: enrollment_rules_insert_input!,
        "on conflict condition"
        on_conflict: enrollment_rules_on_conflict
    ): enrollment_rules
    "insert data into the table: \"enrollment_rules\""
    insert_enrollment_rules(
        "the rows to be inserted"
        objects: [enrollment_rules_insert_input!]!,
        "on conflict condition"
        on_conflict: enrollment_rules_on_conflict
    ): enrollment_rules_mutation_response
    "insert data into the table: \"frequency_types\""
    insert_frequency_types(
        "the rows to be inserted"
        objects: [frequency_types_insert_input!]!,
        "on conflict condition"
        on_conflict: frequency_types_on_conflict
    ): frequency_types_mutation_response
    "insert a single row into the table: \"frequency_types\""
    insert_frequency_types_one(
        "the row to be inserted"
        object: frequency_types_insert_input!,
        "on conflict condition"
        on_conflict: frequency_types_on_conflict
    ): frequency_types
    "insert data into the table: \"gender_types\""
    insert_gender_types(
        "the rows to be inserted"
        objects: [gender_types_insert_input!]!,
        "on conflict condition"
        on_conflict: gender_types_on_conflict
    ): gender_types_mutation_response
    "insert a single row into the table: \"gender_types\""
    insert_gender_types_one(
        "the row to be inserted"
        object: gender_types_insert_input!,
        "on conflict condition"
        on_conflict: gender_types_on_conflict
    ): gender_types
    "insert data into the table: \"grades\""
    insert_grades(
        "the rows to be inserted"
        objects: [grades_insert_input!]!,
        "on conflict condition"
        on_conflict: grades_on_conflict
    ): grades_mutation_response
    "insert a single row into the table: \"grades\""
    insert_grades_one(
        "the row to be inserted"
        object: grades_insert_input!,
        "on conflict condition"
        on_conflict: grades_on_conflict
    ): grades
    "insert a single row into the table: \"instructor_enrollments\""
    insert_instructor_enrollment(
        "the row to be inserted"
        object: instructor_enrollments_insert_input!,
        "on conflict condition"
        on_conflict: instructor_enrollments_on_conflict
    ): instructor_enrollments
    "insert data into the table: \"instructor_enrollments\""
    insert_instructor_enrollments(
        "the rows to be inserted"
        objects: [instructor_enrollments_insert_input!]!,
        "on conflict condition"
        on_conflict: instructor_enrollments_on_conflict
    ): instructor_enrollments_mutation_response
    "insert a single row into the table: \"schools\""
    insert_organization(
        "the row to be inserted"
        object: schools_insert_input!,
        "on conflict condition"
        on_conflict: schools_on_conflict
    ): schools
    "insert a single row into the table: \"schools_domains\""
    insert_organization_domain(
        "the row to be inserted"
        object: schools_domains_insert_input!,
        "on conflict condition"
        on_conflict: schools_domains_on_conflict
    ): schools_domains
    "insert data into the table: \"schools_domains\""
    insert_organization_domains(
        "the rows to be inserted"
        objects: [schools_domains_insert_input!]!,
        "on conflict condition"
        on_conflict: schools_domains_on_conflict
    ): schools_domains_mutation_response
    "insert data into the table: \"schools\""
    insert_organizations(
        "the rows to be inserted"
        objects: [schools_insert_input!]!,
        "on conflict condition"
        on_conflict: schools_on_conflict
    ): schools_mutation_response
    "insert a single row into the table: \"products\""
    insert_product(
        "the row to be inserted"
        object: products_insert_input!,
        "on conflict condition"
        on_conflict: products_on_conflict
    ): products
    "insert a single row into the table: \"product_prices\""
    insert_product_price(
        "the row to be inserted"
        object: product_prices_insert_input!,
        "on conflict condition"
        on_conflict: product_prices_on_conflict
    ): product_prices
    "insert data into the table: \"product_prices\""
    insert_product_prices(
        "the rows to be inserted"
        objects: [product_prices_insert_input!]!,
        "on conflict condition"
        on_conflict: product_prices_on_conflict
    ): product_prices_mutation_response
    "insert data into the table: \"products\""
    insert_products(
        "the rows to be inserted"
        objects: [products_insert_input!]!,
        "on conflict condition"
        on_conflict: products_on_conflict
    ): products_mutation_response
    "insert a single row into the table: \"promo_codes\""
    insert_promo_code(
        "the row to be inserted"
        object: promo_codes_insert_input!,
        "on conflict condition"
        on_conflict: promo_codes_on_conflict
    ): promo_codes
    "insert data into the table: \"promo_codes\""
    insert_promo_codes(
        "the rows to be inserted"
        objects: [promo_codes_insert_input!]!,
        "on conflict condition"
        on_conflict: promo_codes_on_conflict
    ): promo_codes_mutation_response
    "insert data into the table: \"redirect_mapping\""
    insert_redirect_mapping(
        "the rows to be inserted"
        objects: [redirect_mapping_insert_input!]!,
        "on conflict condition"
        on_conflict: redirect_mapping_on_conflict
    ): redirect_mapping_mutation_response
    "insert a single row into the table: \"redirect_mapping\""
    insert_redirect_mapping_one(
        "the row to be inserted"
        object: redirect_mapping_insert_input!,
        "on conflict condition"
        on_conflict: redirect_mapping_on_conflict
    ): redirect_mapping
    "insert data into the table: \"schedules\""
    insert_schedules(
        "the rows to be inserted"
        objects: [schedules_insert_input!]!,
        "on conflict condition"
        on_conflict: schedules_on_conflict
    ): schedules_mutation_response
    "insert a single row into the table: \"schedules\""
    insert_schedules_one(
        "the row to be inserted"
        object: schedules_insert_input!,
        "on conflict condition"
        on_conflict: schedules_on_conflict
    ): schedules
    "insert a single row into the table: \"stripe_customers\""
    insert_stripe_customer(
        "the row to be inserted"
        object: stripe_customers_insert_input!,
        "on conflict condition"
        on_conflict: stripe_customers_on_conflict
    ): stripe_customers
    "insert data into the table: \"stripe_customers\""
    insert_stripe_customers(
        "the rows to be inserted"
        objects: [stripe_customers_insert_input!]!,
        "on conflict condition"
        on_conflict: stripe_customers_on_conflict
    ): stripe_customers_mutation_response
    "insert a single row into the table: \"students\""
    insert_student(
        "the row to be inserted"
        object: students_insert_input!,
        "on conflict condition"
        on_conflict: students_on_conflict
    ): students
    "insert data into the table: \"student_enrollments\""
    insert_student_enrollments(
        "the rows to be inserted"
        objects: [student_enrollments_insert_input!]!,
        "on conflict condition"
        on_conflict: student_enrollments_on_conflict
    ): student_enrollments_mutation_response
    "insert a single row into the table: \"student_enrollments\""
    insert_student_enrollments_one(
        "the row to be inserted"
        object: student_enrollments_insert_input!,
        "on conflict condition"
        on_conflict: student_enrollments_on_conflict
    ): student_enrollments
    "insert data into the table: \"student_meeting_enrollments\""
    insert_student_meeting_enrollments(
        "the rows to be inserted"
        objects: [student_meeting_enrollments_insert_input!]!,
        "on conflict condition"
        on_conflict: student_meeting_enrollments_on_conflict
    ): student_meeting_enrollments_mutation_response
    "insert a single row into the table: \"student_meeting_enrollments\""
    insert_student_meeting_enrollments_one(
        "the row to be inserted"
        object: student_meeting_enrollments_insert_input!,
        "on conflict condition"
        on_conflict: student_meeting_enrollments_on_conflict
    ): student_meeting_enrollments
    "insert data into the table: \"students\""
    insert_students(
        "the rows to be inserted"
        objects: [students_insert_input!]!,
        "on conflict condition"
        on_conflict: students_on_conflict
    ): students_mutation_response
    "insert a single row into the table: \"subjects\""
    insert_subject(
        "the row to be inserted"
        object: subjects_insert_input!,
        "on conflict condition"
        on_conflict: subjects_on_conflict
    ): subjects
    "insert data into the table: \"subjects\""
    insert_subjects(
        "the rows to be inserted"
        objects: [subjects_insert_input!]!,
        "on conflict condition"
        on_conflict: subjects_on_conflict
    ): subjects_mutation_response
    "insert a single row into the table: \"subscriptions\""
    insert_subscription(
        "the row to be inserted"
        object: subscriptions_insert_input!,
        "on conflict condition"
        on_conflict: subscriptions_on_conflict
    ): subscriptions
    "insert data into the table: \"subscription_status\""
    insert_subscription_status(
        "the rows to be inserted"
        objects: [subscription_status_insert_input!]!,
        "on conflict condition"
        on_conflict: subscription_status_on_conflict
    ): subscription_status_mutation_response
    "insert a single row into the table: \"subscription_status\""
    insert_subscription_status_one(
        "the row to be inserted"
        object: subscription_status_insert_input!,
        "on conflict condition"
        on_conflict: subscription_status_on_conflict
    ): subscription_status
    "insert data into the table: \"subscriptions\""
    insert_subscriptions(
        "the rows to be inserted"
        objects: [subscriptions_insert_input!]!,
        "on conflict condition"
        on_conflict: subscriptions_on_conflict
    ): subscriptions_mutation_response
    "insert a single row into the table: \"testimonials\""
    insert_testimonial(
        "the row to be inserted"
        object: testimonials_insert_input!,
        "on conflict condition"
        on_conflict: testimonials_on_conflict
    ): testimonials
    "insert data into the table: \"testimonials\""
    insert_testimonials(
        "the rows to be inserted"
        objects: [testimonials_insert_input!]!,
        "on conflict condition"
        on_conflict: testimonials_on_conflict
    ): testimonials_mutation_response
    "insert a single row into the table: \"units\""
    insert_unit(
        "the row to be inserted"
        object: units_insert_input!,
        "on conflict condition"
        on_conflict: units_on_conflict
    ): units
    "insert data into the table: \"units\""
    insert_units(
        "the rows to be inserted"
        objects: [units_insert_input!]!,
        "on conflict condition"
        on_conflict: units_on_conflict
    ): units_mutation_response
    "insert a single row into the table: \"uploads\""
    insert_upload(
        "the row to be inserted"
        object: uploads_insert_input!,
        "on conflict condition"
        on_conflict: uploads_on_conflict
    ): uploads
    "insert data into the table: \"uploads\""
    insert_uploads(
        "the rows to be inserted"
        objects: [uploads_insert_input!]!,
        "on conflict condition"
        on_conflict: uploads_on_conflict
    ): uploads_mutation_response
    "insert a single row into the table: \"users\""
    insert_user(
        "the row to be inserted"
        object: users_insert_input!,
        "on conflict condition"
        on_conflict: users_on_conflict
    ): users
    "insert data into the table: \"user_roles\""
    insert_user_roles(
        "the rows to be inserted"
        objects: [user_roles_insert_input!]!,
        "on conflict condition"
        on_conflict: user_roles_on_conflict
    ): user_roles_mutation_response
    "insert a single row into the table: \"user_roles\""
    insert_user_roles_one(
        "the row to be inserted"
        object: user_roles_insert_input!,
        "on conflict condition"
        on_conflict: user_roles_on_conflict
    ): user_roles
    "insert data into the table: \"users\""
    insert_users(
        "the rows to be inserted"
        objects: [users_insert_input!]!,
        "on conflict condition"
        on_conflict: users_on_conflict
    ): users_mutation_response
    "insert a single row into the table: \"waitlists\""
    insert_waitlist(
        "the row to be inserted"
        object: waitlists_insert_input!,
        "on conflict condition"
        on_conflict: waitlists_on_conflict
    ): waitlists
    "insert data into the table: \"waitlists\""
    insert_waitlists(
        "the rows to be inserted"
        objects: [waitlists_insert_input!]!,
        "on conflict condition"
        on_conflict: waitlists_on_conflict
    ): waitlists_mutation_response
    "insert a single row into the table: \"zoom_meetings\""
    insert_zoom_meeting(
        "the row to be inserted"
        object: zoom_meetings_insert_input!,
        "on conflict condition"
        on_conflict: zoom_meetings_on_conflict
    ): zoom_meetings
    "insert data into the table: \"zoom_meetings\""
    insert_zoom_meetings(
        "the rows to be inserted"
        objects: [zoom_meetings_insert_input!]!,
        "on conflict condition"
        on_conflict: zoom_meetings_on_conflict
    ): zoom_meetings_mutation_response
    purchasePlan(planId: String!, promoCode: String, studentId: uuid!): String!
    resendInvite(id: uuid!): String
    "perform the action: \"retryPayment\""
    retryPayment: RetryPaymentOutput
    "perform the action: \"signUp\""
    signUp(input: SignUpUserInput!): SignUpUserOutput
    unenrollStudent(id: uuid!): uuid
    updateEntityOrder(entityType: EntityUpdateType, updates: [UpdateEntityOrderInput!]!): [EntityOrderUpdateOutput]!
    updatePaymentInfo(paymentMethodId: String): PaymentMethod
    updatePlan(input: UpdatePlanInput!): String
    updateUnitOrder(updates: [UpdateUnitOrderInput!]!): [UnitOrderUpdateOutput]!
    "update data of the table: \"ages\""
    update_ages(
        "increments the integer columns with given value of the filtered values"
        _inc: ages_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: ages_set_input,
        "filter the rows which have to be updated"
        where: ages_bool_exp!
    ): ages_mutation_response
    "update single row of the table: \"ages\""
    update_ages_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: ages_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: ages_set_input,
        pk_columns: ages_pk_columns_input!
    ): ages
    "update data of the table: \"application_config\""
    update_application_config(
        "increments the integer columns with given value of the filtered values"
        _inc: application_config_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: application_config_set_input,
        "filter the rows which have to be updated"
        where: application_config_bool_exp!
    ): application_config_mutation_response
    "update single row of the table: \"application_config\""
    update_application_config_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: application_config_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: application_config_set_input,
        pk_columns: application_config_pk_columns_input!
    ): application_config
    "update single row of the table: \"coupons\""
    update_coupon(
        "sets the columns of the filtered rows to the given values"
        _set: coupons_set_input,
        pk_columns: coupons_pk_columns_input!
    ): coupons
    "update data of the table: \"coupons\""
    update_coupons(
        "sets the columns of the filtered rows to the given values"
        _set: coupons_set_input,
        "filter the rows which have to be updated"
        where: coupons_bool_exp!
    ): coupons_mutation_response
    "update single row of the table: \"courses\""
    update_course(
        "increments the integer columns with given value of the filtered values"
        _inc: courses_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: courses_set_input,
        pk_columns: courses_pk_columns_input!
    ): courses
    "update data of the table: \"course_ages\""
    update_course_ages(
        "increments the integer columns with given value of the filtered values"
        _inc: course_ages_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: course_ages_set_input,
        "filter the rows which have to be updated"
        where: course_ages_bool_exp!
    ): course_ages_mutation_response
    "update single row of the table: \"course_ages\""
    update_course_ages_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: course_ages_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: course_ages_set_input,
        pk_columns: course_ages_pk_columns_input!
    ): course_ages
    "update data of the table: \"course_grades\""
    update_course_grades(
        "increments the integer columns with given value of the filtered values"
        _inc: course_grades_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: course_grades_set_input,
        "filter the rows which have to be updated"
        where: course_grades_bool_exp!
    ): course_grades_mutation_response
    "update single row of the table: \"course_grades\""
    update_course_grades_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: course_grades_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: course_grades_set_input,
        pk_columns: course_grades_pk_columns_input!
    ): course_grades
    "update single row of the table: \"course_materials\""
    update_course_material(
        "increments the integer columns with given value of the filtered values"
        _inc: course_materials_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: course_materials_set_input,
        pk_columns: course_materials_pk_columns_input!
    ): course_materials
    "update data of the table: \"course_materials\""
    update_course_materials(
        "increments the integer columns with given value of the filtered values"
        _inc: course_materials_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: course_materials_set_input,
        "filter the rows which have to be updated"
        where: course_materials_bool_exp!
    ): course_materials_mutation_response
    "update data of the table: \"course_types\""
    update_course_types(
        "increments the integer columns with given value of the filtered values"
        _inc: course_types_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: course_types_set_input,
        "filter the rows which have to be updated"
        where: course_types_bool_exp!
    ): course_types_mutation_response
    "update single row of the table: \"course_types\""
    update_course_types_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: course_types_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: course_types_set_input,
        pk_columns: course_types_pk_columns_input!
    ): course_types
    "update data of the table: \"courses\""
    update_courses(
        "increments the integer columns with given value of the filtered values"
        _inc: courses_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: courses_set_input,
        "filter the rows which have to be updated"
        where: courses_bool_exp!
    ): courses_mutation_response
    "update data of the table: \"durations\""
    update_durations(
        "increments the integer columns with given value of the filtered values"
        _inc: durations_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: durations_set_input,
        "filter the rows which have to be updated"
        where: durations_bool_exp!
    ): durations_mutation_response
    "update single row of the table: \"durations\""
    update_durations_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: durations_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: durations_set_input,
        pk_columns: durations_pk_columns_input!
    ): durations
    "update data of the table: \"enrollment_info\""
    update_enrollment_info(
        "increments the integer columns with given value of the filtered values"
        _inc: enrollment_info_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: enrollment_info_set_input,
        "filter the rows which have to be updated"
        where: enrollment_info_bool_exp!
    ): enrollment_info_mutation_response
    "update single row of the table: \"enrollment_rules\""
    update_enrollment_rule(
        "increments the integer columns with given value of the filtered values"
        _inc: enrollment_rules_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: enrollment_rules_set_input,
        pk_columns: enrollment_rules_pk_columns_input!
    ): enrollment_rules
    "update data of the table: \"enrollment_rules\""
    update_enrollment_rules(
        "increments the integer columns with given value of the filtered values"
        _inc: enrollment_rules_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: enrollment_rules_set_input,
        "filter the rows which have to be updated"
        where: enrollment_rules_bool_exp!
    ): enrollment_rules_mutation_response
    "update data of the table: \"frequency_types\""
    update_frequency_types(
        "sets the columns of the filtered rows to the given values"
        _set: frequency_types_set_input,
        "filter the rows which have to be updated"
        where: frequency_types_bool_exp!
    ): frequency_types_mutation_response
    "update single row of the table: \"frequency_types\""
    update_frequency_types_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: frequency_types_set_input,
        pk_columns: frequency_types_pk_columns_input!
    ): frequency_types
    "update data of the table: \"gender_types\""
    update_gender_types(
        "sets the columns of the filtered rows to the given values"
        _set: gender_types_set_input,
        "filter the rows which have to be updated"
        where: gender_types_bool_exp!
    ): gender_types_mutation_response
    "update single row of the table: \"gender_types\""
    update_gender_types_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: gender_types_set_input,
        pk_columns: gender_types_pk_columns_input!
    ): gender_types
    "update data of the table: \"grades\""
    update_grades(
        "increments the integer columns with given value of the filtered values"
        _inc: grades_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: grades_set_input,
        "filter the rows which have to be updated"
        where: grades_bool_exp!
    ): grades_mutation_response
    "update single row of the table: \"grades\""
    update_grades_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: grades_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: grades_set_input,
        pk_columns: grades_pk_columns_input!
    ): grades
    "update single row of the table: \"instructor_enrollments\""
    update_instructor_enrollment(
        "increments the integer columns with given value of the filtered values"
        _inc: instructor_enrollments_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: instructor_enrollments_set_input,
        pk_columns: instructor_enrollments_pk_columns_input!
    ): instructor_enrollments
    "update data of the table: \"instructor_enrollments\""
    update_instructor_enrollments(
        "increments the integer columns with given value of the filtered values"
        _inc: instructor_enrollments_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: instructor_enrollments_set_input,
        "filter the rows which have to be updated"
        where: instructor_enrollments_bool_exp!
    ): instructor_enrollments_mutation_response
    "update single row of the table: \"schools\""
    update_organization(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: schools_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: schools_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: schools_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: schools_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: schools_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: schools_set_input,
        pk_columns: schools_pk_columns_input!
    ): schools
    "update single row of the table: \"schools_domains\""
    update_organization_domain(
        "sets the columns of the filtered rows to the given values"
        _set: schools_domains_set_input,
        pk_columns: schools_domains_pk_columns_input!
    ): schools_domains
    "update data of the table: \"schools_domains\""
    update_organization_domains(
        "sets the columns of the filtered rows to the given values"
        _set: schools_domains_set_input,
        "filter the rows which have to be updated"
        where: schools_domains_bool_exp!
    ): schools_domains_mutation_response
    "update data of the table: \"schools\""
    update_organizations(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: schools_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: schools_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: schools_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: schools_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: schools_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: schools_set_input,
        "filter the rows which have to be updated"
        where: schools_bool_exp!
    ): schools_mutation_response
    "update single row of the table: \"products\""
    update_product(
        "sets the columns of the filtered rows to the given values"
        _set: products_set_input,
        pk_columns: products_pk_columns_input!
    ): products
    "update single row of the table: \"product_prices\""
    update_product_price(
        "increments the integer columns with given value of the filtered values"
        _inc: product_prices_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: product_prices_set_input,
        pk_columns: product_prices_pk_columns_input!
    ): product_prices
    "update data of the table: \"product_prices\""
    update_product_prices(
        "increments the integer columns with given value of the filtered values"
        _inc: product_prices_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: product_prices_set_input,
        "filter the rows which have to be updated"
        where: product_prices_bool_exp!
    ): product_prices_mutation_response
    "update data of the table: \"products\""
    update_products(
        "sets the columns of the filtered rows to the given values"
        _set: products_set_input,
        "filter the rows which have to be updated"
        where: products_bool_exp!
    ): products_mutation_response
    "update single row of the table: \"promo_codes\""
    update_promo_code(
        "sets the columns of the filtered rows to the given values"
        _set: promo_codes_set_input,
        pk_columns: promo_codes_pk_columns_input!
    ): promo_codes
    "update data of the table: \"promo_codes\""
    update_promo_codes(
        "sets the columns of the filtered rows to the given values"
        _set: promo_codes_set_input,
        "filter the rows which have to be updated"
        where: promo_codes_bool_exp!
    ): promo_codes_mutation_response
    "update data of the table: \"redirect_mapping\""
    update_redirect_mapping(
        "increments the integer columns with given value of the filtered values"
        _inc: redirect_mapping_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: redirect_mapping_set_input,
        "filter the rows which have to be updated"
        where: redirect_mapping_bool_exp!
    ): redirect_mapping_mutation_response
    "update single row of the table: \"redirect_mapping\""
    update_redirect_mapping_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: redirect_mapping_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: redirect_mapping_set_input,
        pk_columns: redirect_mapping_pk_columns_input!
    ): redirect_mapping
    "update single row of the table: \"schedules\""
    update_schedule(
        "increments the integer columns with given value of the filtered values"
        _inc: schedules_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: schedules_set_input,
        pk_columns: schedules_pk_columns_input!
    ): schedules
    "update data of the table: \"schedules\""
    update_schedules(
        "increments the integer columns with given value of the filtered values"
        _inc: schedules_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: schedules_set_input,
        "filter the rows which have to be updated"
        where: schedules_bool_exp!
    ): schedules_mutation_response
    "update single row of the table: \"stripe_customers\""
    update_stripe_customer(
        "sets the columns of the filtered rows to the given values"
        _set: stripe_customers_set_input,
        pk_columns: stripe_customers_pk_columns_input!
    ): stripe_customers
    "update data of the table: \"stripe_customers\""
    update_stripe_customers(
        "sets the columns of the filtered rows to the given values"
        _set: stripe_customers_set_input,
        "filter the rows which have to be updated"
        where: stripe_customers_bool_exp!
    ): stripe_customers_mutation_response
    "update single row of the table: \"students\""
    update_student(
        "increments the integer columns with given value of the filtered values"
        _inc: students_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: students_set_input,
        pk_columns: students_pk_columns_input!
    ): students
    "update data of the table: \"student_enrollments\""
    update_student_enrollments(
        "sets the columns of the filtered rows to the given values"
        _set: student_enrollments_set_input,
        "filter the rows which have to be updated"
        where: student_enrollments_bool_exp!
    ): student_enrollments_mutation_response
    "update single row of the table: \"student_enrollments\""
    update_student_enrollments_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: student_enrollments_set_input,
        pk_columns: student_enrollments_pk_columns_input!
    ): student_enrollments
    "update data of the table: \"student_meeting_enrollments\""
    update_student_meeting_enrollments(
        "sets the columns of the filtered rows to the given values"
        _set: student_meeting_enrollments_set_input,
        "filter the rows which have to be updated"
        where: student_meeting_enrollments_bool_exp!
    ): student_meeting_enrollments_mutation_response
    "update single row of the table: \"student_meeting_enrollments\""
    update_student_meeting_enrollments_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: student_meeting_enrollments_set_input,
        pk_columns: student_meeting_enrollments_pk_columns_input!
    ): student_meeting_enrollments
    "update data of the table: \"students\""
    update_students(
        "increments the integer columns with given value of the filtered values"
        _inc: students_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: students_set_input,
        "filter the rows which have to be updated"
        where: students_bool_exp!
    ): students_mutation_response
    "update single row of the table: \"subjects\""
    update_subject(
        "sets the columns of the filtered rows to the given values"
        _set: subjects_set_input,
        pk_columns: subjects_pk_columns_input!
    ): subjects
    "update data of the table: \"subjects\""
    update_subjects(
        "sets the columns of the filtered rows to the given values"
        _set: subjects_set_input,
        "filter the rows which have to be updated"
        where: subjects_bool_exp!
    ): subjects_mutation_response
    "update single row of the table: \"subscriptions\""
    update_subscription(
        "sets the columns of the filtered rows to the given values"
        _set: subscriptions_set_input,
        pk_columns: subscriptions_pk_columns_input!
    ): subscriptions
    "update data of the table: \"subscription_status\""
    update_subscription_status(
        "sets the columns of the filtered rows to the given values"
        _set: subscription_status_set_input,
        "filter the rows which have to be updated"
        where: subscription_status_bool_exp!
    ): subscription_status_mutation_response
    "update single row of the table: \"subscription_status\""
    update_subscription_status_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: subscription_status_set_input,
        pk_columns: subscription_status_pk_columns_input!
    ): subscription_status
    "update data of the table: \"subscriptions\""
    update_subscriptions(
        "sets the columns of the filtered rows to the given values"
        _set: subscriptions_set_input,
        "filter the rows which have to be updated"
        where: subscriptions_bool_exp!
    ): subscriptions_mutation_response
    "update single row of the table: \"testimonials\""
    update_testimonial(
        "increments the integer columns with given value of the filtered values"
        _inc: testimonials_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: testimonials_set_input,
        pk_columns: testimonials_pk_columns_input!
    ): testimonials
    "update data of the table: \"testimonials\""
    update_testimonials(
        "increments the integer columns with given value of the filtered values"
        _inc: testimonials_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: testimonials_set_input,
        "filter the rows which have to be updated"
        where: testimonials_bool_exp!
    ): testimonials_mutation_response
    "update single row of the table: \"units\""
    update_unit(
        "increments the integer columns with given value of the filtered values"
        _inc: units_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: units_set_input,
        pk_columns: units_pk_columns_input!
    ): units
    "update data of the table: \"units\""
    update_units(
        "increments the integer columns with given value of the filtered values"
        _inc: units_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: units_set_input,
        "filter the rows which have to be updated"
        where: units_bool_exp!
    ): units_mutation_response
    "update single row of the table: \"uploads\""
    update_upload(
        "increments the integer columns with given value of the filtered values"
        _inc: uploads_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: uploads_set_input,
        pk_columns: uploads_pk_columns_input!
    ): uploads
    "update data of the table: \"uploads\""
    update_uploads(
        "increments the integer columns with given value of the filtered values"
        _inc: uploads_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: uploads_set_input,
        "filter the rows which have to be updated"
        where: uploads_bool_exp!
    ): uploads_mutation_response
    "update single row of the table: \"users\""
    update_user(
        "increments the integer columns with given value of the filtered values"
        _inc: users_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input,
        pk_columns: users_pk_columns_input!
    ): users
    "update data of the table: \"user_roles\""
    update_user_roles(
        "sets the columns of the filtered rows to the given values"
        _set: user_roles_set_input,
        "filter the rows which have to be updated"
        where: user_roles_bool_exp!
    ): user_roles_mutation_response
    "update single row of the table: \"user_roles\""
    update_user_roles_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: user_roles_set_input,
        pk_columns: user_roles_pk_columns_input!
    ): user_roles
    "update data of the table: \"users\""
    update_users(
        "increments the integer columns with given value of the filtered values"
        _inc: users_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input,
        "filter the rows which have to be updated"
        where: users_bool_exp!
    ): users_mutation_response
    "update single row of the table: \"waitlists\""
    update_waitlist(
        "sets the columns of the filtered rows to the given values"
        _set: waitlists_set_input,
        pk_columns: waitlists_pk_columns_input!
    ): waitlists
    "update data of the table: \"waitlists\""
    update_waitlists(
        "sets the columns of the filtered rows to the given values"
        _set: waitlists_set_input,
        "filter the rows which have to be updated"
        where: waitlists_bool_exp!
    ): waitlists_mutation_response
    "update single row of the table: \"zoom_meetings\""
    update_zoom_meeting(
        "sets the columns of the filtered rows to the given values"
        _set: zoom_meetings_set_input,
        pk_columns: zoom_meetings_pk_columns_input!
    ): zoom_meetings
    "update data of the table: \"zoom_meetings\""
    update_zoom_meetings(
        "sets the columns of the filtered rows to the given values"
        _set: zoom_meetings_set_input,
        "filter the rows which have to be updated"
        where: zoom_meetings_bool_exp!
    ): zoom_meetings_mutation_response
    uploadStudents(file: String!, schoolId: uuid!): UploadStudentOutput
    waitlistSignup(input: WaitlistSignupInput): String
}

"columns and relationships of \"parent_email_survey\""
type parent_email_survey {
    cancelled: Boolean
    "An object relationship"
    cohort: instructor_enrollments
    "An object relationship"
    course: courses
    course_id: uuid
    end_time: timestamptz
    id: uuid
    instructor_enrollment_id: uuid
    instructor_id: uuid
    session: Int
    start_time: timestamptz
    "An object relationship"
    student: students
    student_id: uuid
    survey_sent: Boolean
    total_sessions: Int
    zoom_meeting_id: uuid
    zoom_occurrence_id: String
}

"aggregated selection of \"parent_email_survey\""
type parent_email_survey_aggregate {
    aggregate: parent_email_survey_aggregate_fields
    nodes: [parent_email_survey!]!
}

"aggregate fields of \"parent_email_survey\""
type parent_email_survey_aggregate_fields {
    avg: parent_email_survey_avg_fields
    count(columns: [parent_email_survey_select_column!], distinct: Boolean): Int
    max: parent_email_survey_max_fields
    min: parent_email_survey_min_fields
    stddev: parent_email_survey_stddev_fields
    stddev_pop: parent_email_survey_stddev_pop_fields
    stddev_samp: parent_email_survey_stddev_samp_fields
    sum: parent_email_survey_sum_fields
    var_pop: parent_email_survey_var_pop_fields
    var_samp: parent_email_survey_var_samp_fields
    variance: parent_email_survey_variance_fields
}

"aggregate avg on columns"
type parent_email_survey_avg_fields {
    session: Float
    total_sessions: Float
}

"aggregate max on columns"
type parent_email_survey_max_fields {
    course_id: uuid
    end_time: timestamptz
    id: uuid
    instructor_enrollment_id: uuid
    instructor_id: uuid
    session: Int
    start_time: timestamptz
    student_id: uuid
    total_sessions: Int
    zoom_meeting_id: uuid
    zoom_occurrence_id: String
}

"aggregate min on columns"
type parent_email_survey_min_fields {
    course_id: uuid
    end_time: timestamptz
    id: uuid
    instructor_enrollment_id: uuid
    instructor_id: uuid
    session: Int
    start_time: timestamptz
    student_id: uuid
    total_sessions: Int
    zoom_meeting_id: uuid
    zoom_occurrence_id: String
}

"aggregate stddev on columns"
type parent_email_survey_stddev_fields {
    session: Float
    total_sessions: Float
}

"aggregate stddev_pop on columns"
type parent_email_survey_stddev_pop_fields {
    session: Float
    total_sessions: Float
}

"aggregate stddev_samp on columns"
type parent_email_survey_stddev_samp_fields {
    session: Float
    total_sessions: Float
}

"aggregate sum on columns"
type parent_email_survey_sum_fields {
    session: Int
    total_sessions: Int
}

"aggregate var_pop on columns"
type parent_email_survey_var_pop_fields {
    session: Float
    total_sessions: Float
}

"aggregate var_samp on columns"
type parent_email_survey_var_samp_fields {
    session: Float
    total_sessions: Float
}

"aggregate variance on columns"
type parent_email_survey_variance_fields {
    session: Float
    total_sessions: Float
}

"columns and relationships of \"product_prices\""
type product_prices {
    active: Boolean!
    amount: Int!
    id: String!
    interval: String!
    "An object relationship"
    product: products!
    productId: String!
    stripeObject(
        "JSON select path"
        path: String
    ): json!
}

"aggregated selection of \"product_prices\""
type product_prices_aggregate {
    aggregate: product_prices_aggregate_fields
    nodes: [product_prices!]!
}

"aggregate fields of \"product_prices\""
type product_prices_aggregate_fields {
    avg: product_prices_avg_fields
    count(columns: [product_prices_select_column!], distinct: Boolean): Int
    max: product_prices_max_fields
    min: product_prices_min_fields
    stddev: product_prices_stddev_fields
    stddev_pop: product_prices_stddev_pop_fields
    stddev_samp: product_prices_stddev_samp_fields
    sum: product_prices_sum_fields
    var_pop: product_prices_var_pop_fields
    var_samp: product_prices_var_samp_fields
    variance: product_prices_variance_fields
}

"aggregate avg on columns"
type product_prices_avg_fields {
    amount: Float
}

"aggregate max on columns"
type product_prices_max_fields {
    amount: Int
    id: String
    interval: String
    productId: String
}

"aggregate min on columns"
type product_prices_min_fields {
    amount: Int
    id: String
    interval: String
    productId: String
}

"response of any mutation on the table \"product_prices\""
type product_prices_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [product_prices!]!
}

"aggregate stddev on columns"
type product_prices_stddev_fields {
    amount: Float
}

"aggregate stddev_pop on columns"
type product_prices_stddev_pop_fields {
    amount: Float
}

"aggregate stddev_samp on columns"
type product_prices_stddev_samp_fields {
    amount: Float
}

"aggregate sum on columns"
type product_prices_sum_fields {
    amount: Int
}

"aggregate var_pop on columns"
type product_prices_var_pop_fields {
    amount: Float
}

"aggregate var_samp on columns"
type product_prices_var_samp_fields {
    amount: Float
}

"aggregate variance on columns"
type product_prices_variance_fields {
    amount: Float
}

"columns and relationships of \"products\""
type products {
    details: String
    id: String!
    name: String!
    "An array relationship"
    prices(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!],
        "filter the rows returned"
        where: product_prices_bool_exp
    ): [product_prices!]!
    "An aggregated array relationship"
    prices_aggregate(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!],
        "filter the rows returned"
        where: product_prices_bool_exp
    ): product_prices_aggregate!
    stripeObject(
        "JSON select path"
        path: String
    ): json!
    title: String
}

"aggregated selection of \"products\""
type products_aggregate {
    aggregate: products_aggregate_fields
    nodes: [products!]!
}

"aggregate fields of \"products\""
type products_aggregate_fields {
    count(columns: [products_select_column!], distinct: Boolean): Int
    max: products_max_fields
    min: products_min_fields
}

"aggregate max on columns"
type products_max_fields {
    details: String
    id: String
    name: String
    title: String
}

"aggregate min on columns"
type products_min_fields {
    details: String
    id: String
    name: String
    title: String
}

"response of any mutation on the table \"products\""
type products_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [products!]!
}

"columns and relationships of \"profile\""
type profile {
    currentGradeId: Int
    dob: date
    email: String
    firstName: String
    "An object relationship"
    gender: gender_types
    genderType: String
    "An object relationship"
    grade: grades
    id: uuid
    lastName: String
    "An object relationship"
    organization: schools
    organizationId: uuid
    parentId: uuid
    paying: Boolean
    phone: String
    role: String
    searchName: String
    "An object relationship"
    subscription: subscriptions
}

"aggregated selection of \"profile\""
type profile_aggregate {
    aggregate: profile_aggregate_fields
    nodes: [profile!]!
}

"aggregate fields of \"profile\""
type profile_aggregate_fields {
    avg: profile_avg_fields
    count(columns: [profile_select_column!], distinct: Boolean): Int
    max: profile_max_fields
    min: profile_min_fields
    stddev: profile_stddev_fields
    stddev_pop: profile_stddev_pop_fields
    stddev_samp: profile_stddev_samp_fields
    sum: profile_sum_fields
    var_pop: profile_var_pop_fields
    var_samp: profile_var_samp_fields
    variance: profile_variance_fields
}

"aggregate avg on columns"
type profile_avg_fields {
    currentGradeId: Float
}

"aggregate max on columns"
type profile_max_fields {
    currentGradeId: Int
    dob: date
    email: String
    firstName: String
    genderType: String
    id: uuid
    lastName: String
    organizationId: uuid
    parentId: uuid
    phone: String
    role: String
    searchName: String
}

"aggregate min on columns"
type profile_min_fields {
    currentGradeId: Int
    dob: date
    email: String
    firstName: String
    genderType: String
    id: uuid
    lastName: String
    organizationId: uuid
    parentId: uuid
    phone: String
    role: String
    searchName: String
}

"aggregate stddev on columns"
type profile_stddev_fields {
    currentGradeId: Float
}

"aggregate stddev_pop on columns"
type profile_stddev_pop_fields {
    currentGradeId: Float
}

"aggregate stddev_samp on columns"
type profile_stddev_samp_fields {
    currentGradeId: Float
}

"aggregate sum on columns"
type profile_sum_fields {
    currentGradeId: Int
}

"aggregate var_pop on columns"
type profile_var_pop_fields {
    currentGradeId: Float
}

"aggregate var_samp on columns"
type profile_var_samp_fields {
    currentGradeId: Float
}

"aggregate variance on columns"
type profile_variance_fields {
    currentGradeId: Float
}

"columns and relationships of \"promo_codes\""
type promo_codes {
    active: Boolean!
    code: String!
    "An object relationship"
    coupon: coupons!
    couponId: String!
    id: String!
    stripeObject(
        "JSON select path"
        path: String
    ): json!
}

"aggregated selection of \"promo_codes\""
type promo_codes_aggregate {
    aggregate: promo_codes_aggregate_fields
    nodes: [promo_codes!]!
}

"aggregate fields of \"promo_codes\""
type promo_codes_aggregate_fields {
    count(columns: [promo_codes_select_column!], distinct: Boolean): Int
    max: promo_codes_max_fields
    min: promo_codes_min_fields
}

"aggregate max on columns"
type promo_codes_max_fields {
    code: String
    couponId: String
    id: String
}

"aggregate min on columns"
type promo_codes_min_fields {
    code: String
    couponId: String
    id: String
}

"response of any mutation on the table \"promo_codes\""
type promo_codes_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [promo_codes!]!
}

"query root"
type query_root {
    "fetch data from the table: \"ages\""
    ages(
        "distinct select on columns"
        distinct_on: [ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [ages_order_by!],
        "filter the rows returned"
        where: ages_bool_exp
    ): [ages!]!
    "fetch aggregated fields from the table: \"ages\""
    ages_aggregate(
        "distinct select on columns"
        distinct_on: [ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [ages_order_by!],
        "filter the rows returned"
        where: ages_bool_exp
    ): ages_aggregate!
    "fetch data from the table: \"ages\" using primary key columns"
    ages_by_pk(id: Int!): ages
    "fetch data from the table: \"application_config\""
    application_config(
        "distinct select on columns"
        distinct_on: [application_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_config_order_by!],
        "filter the rows returned"
        where: application_config_bool_exp
    ): [application_config!]!
    "fetch aggregated fields from the table: \"application_config\""
    application_config_aggregate(
        "distinct select on columns"
        distinct_on: [application_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_config_order_by!],
        "filter the rows returned"
        where: application_config_bool_exp
    ): application_config_aggregate!
    "fetch data from the table: \"application_config\" using primary key columns"
    application_config_by_pk(id: uuid!): application_config
    "fetch data from the table: \"coupons\" using primary key columns"
    coupon(id: String!): coupons
    "fetch data from the table: \"coupons\""
    coupons(
        "distinct select on columns"
        distinct_on: [coupons_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [coupons_order_by!],
        "filter the rows returned"
        where: coupons_bool_exp
    ): [coupons!]!
    "fetch aggregated fields from the table: \"coupons\""
    coupons_aggregate(
        "distinct select on columns"
        distinct_on: [coupons_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [coupons_order_by!],
        "filter the rows returned"
        where: coupons_bool_exp
    ): coupons_aggregate!
    "fetch data from the table: \"courses\" using primary key columns"
    course(id: uuid!): courses
    "fetch data from the table: \"course_ages\""
    course_ages(
        "distinct select on columns"
        distinct_on: [course_ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_ages_order_by!],
        "filter the rows returned"
        where: course_ages_bool_exp
    ): [course_ages!]!
    "fetch aggregated fields from the table: \"course_ages\""
    course_ages_aggregate(
        "distinct select on columns"
        distinct_on: [course_ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_ages_order_by!],
        "filter the rows returned"
        where: course_ages_bool_exp
    ): course_ages_aggregate!
    "fetch data from the table: \"course_ages\" using primary key columns"
    course_ages_by_pk(ageId: Int!, courseId: uuid!): course_ages
    "fetch data from the table: \"course_grades\""
    course_grades(
        "distinct select on columns"
        distinct_on: [course_grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_grades_order_by!],
        "filter the rows returned"
        where: course_grades_bool_exp
    ): [course_grades!]!
    "fetch aggregated fields from the table: \"course_grades\""
    course_grades_aggregate(
        "distinct select on columns"
        distinct_on: [course_grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_grades_order_by!],
        "filter the rows returned"
        where: course_grades_bool_exp
    ): course_grades_aggregate!
    "fetch data from the table: \"course_grades\" using primary key columns"
    course_grades_by_pk(courseId: uuid!, gradeId: Int!): course_grades
    "fetch data from the table: \"course_materials\" using primary key columns"
    course_material(id: Int!): course_materials
    "fetch data from the table: \"course_materials\""
    course_materials(
        "distinct select on columns"
        distinct_on: [course_materials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_materials_order_by!],
        "filter the rows returned"
        where: course_materials_bool_exp
    ): [course_materials!]!
    "fetch aggregated fields from the table: \"course_materials\""
    course_materials_aggregate(
        "distinct select on columns"
        distinct_on: [course_materials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_materials_order_by!],
        "filter the rows returned"
        where: course_materials_bool_exp
    ): course_materials_aggregate!
    "fetch data from the table: \"course_types\""
    course_types(
        "distinct select on columns"
        distinct_on: [course_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_types_order_by!],
        "filter the rows returned"
        where: course_types_bool_exp
    ): [course_types!]!
    "fetch aggregated fields from the table: \"course_types\""
    course_types_aggregate(
        "distinct select on columns"
        distinct_on: [course_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_types_order_by!],
        "filter the rows returned"
        where: course_types_bool_exp
    ): course_types_aggregate!
    "fetch data from the table: \"course_types\" using primary key columns"
    course_types_by_pk(value: String!): course_types
    "fetch data from the table: \"courses\""
    courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "fetch aggregated fields from the table: \"courses\""
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "fetch data from the table: \"durations\""
    durations(
        "distinct select on columns"
        distinct_on: [durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [durations_order_by!],
        "filter the rows returned"
        where: durations_bool_exp
    ): [durations!]!
    "fetch aggregated fields from the table: \"durations\""
    durations_aggregate(
        "distinct select on columns"
        distinct_on: [durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [durations_order_by!],
        "filter the rows returned"
        where: durations_bool_exp
    ): durations_aggregate!
    "fetch data from the table: \"durations\" using primary key columns"
    durations_by_pk(id: Int!): durations
    "fetch data from the table: \"enrollment_info\""
    enrollment_info(
        "distinct select on columns"
        distinct_on: [enrollment_info_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_info_order_by!],
        "filter the rows returned"
        where: enrollment_info_bool_exp
    ): [enrollment_info!]!
    "fetch aggregated fields from the table: \"enrollment_info\""
    enrollment_info_aggregate(
        "distinct select on columns"
        distinct_on: [enrollment_info_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_info_order_by!],
        "filter the rows returned"
        where: enrollment_info_bool_exp
    ): enrollment_info_aggregate!
    "fetch data from the table: \"enrollment_rules\" using primary key columns"
    enrollment_rule(id: Int!): enrollment_rules
    "fetch data from the table: \"enrollment_rules\""
    enrollment_rules(
        "distinct select on columns"
        distinct_on: [enrollment_rules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_rules_order_by!],
        "filter the rows returned"
        where: enrollment_rules_bool_exp
    ): [enrollment_rules!]!
    "fetch aggregated fields from the table: \"enrollment_rules\""
    enrollment_rules_aggregate(
        "distinct select on columns"
        distinct_on: [enrollment_rules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_rules_order_by!],
        "filter the rows returned"
        where: enrollment_rules_bool_exp
    ): enrollment_rules_aggregate!
    "execute function \"featured_courses\" which returns \"courses\""
    featured_courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "execute function \"featured_courses\" and query aggregates on result of table type \"courses\""
    featured_courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "fetch data from the table: \"frequency_types\""
    frequency_types(
        "distinct select on columns"
        distinct_on: [frequency_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [frequency_types_order_by!],
        "filter the rows returned"
        where: frequency_types_bool_exp
    ): [frequency_types!]!
    "fetch aggregated fields from the table: \"frequency_types\""
    frequency_types_aggregate(
        "distinct select on columns"
        distinct_on: [frequency_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [frequency_types_order_by!],
        "filter the rows returned"
        where: frequency_types_bool_exp
    ): frequency_types_aggregate!
    "fetch data from the table: \"frequency_types\" using primary key columns"
    frequency_types_by_pk(value: String!): frequency_types
    "fetch data from the table: \"gender_types\""
    gender_types(
        "distinct select on columns"
        distinct_on: [gender_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [gender_types_order_by!],
        "filter the rows returned"
        where: gender_types_bool_exp
    ): [gender_types!]!
    "fetch aggregated fields from the table: \"gender_types\""
    gender_types_aggregate(
        "distinct select on columns"
        distinct_on: [gender_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [gender_types_order_by!],
        "filter the rows returned"
        where: gender_types_bool_exp
    ): gender_types_aggregate!
    "fetch data from the table: \"gender_types\" using primary key columns"
    gender_types_by_pk(value: String!): gender_types
    "execute function \"get_application_config\" which returns \"application_config\""
    get_application_config(
        "distinct select on columns"
        distinct_on: [application_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_config_order_by!],
        "filter the rows returned"
        where: application_config_bool_exp
    ): [application_config!]!
    "execute function \"get_application_config\" and query aggregates on result of table type \"application_config\""
    get_application_config_aggregate(
        "distinct select on columns"
        distinct_on: [application_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_config_order_by!],
        "filter the rows returned"
        where: application_config_bool_exp
    ): application_config_aggregate!
    "fetch data from the table: \"grades\""
    grades(
        "distinct select on columns"
        distinct_on: [grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [grades_order_by!],
        "filter the rows returned"
        where: grades_bool_exp
    ): [grades!]!
    "fetch aggregated fields from the table: \"grades\""
    grades_aggregate(
        "distinct select on columns"
        distinct_on: [grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [grades_order_by!],
        "filter the rows returned"
        where: grades_bool_exp
    ): grades_aggregate!
    "fetch data from the table: \"grades\" using primary key columns"
    grades_by_pk(id: Int!): grades
    "fetch data from the table: \"instructor_enrollments\" using primary key columns"
    instructor_enrollment(id: uuid!): instructor_enrollments
    "fetch data from the table: \"instructor_enrollments\""
    instructor_enrollments(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): [instructor_enrollments!]!
    "fetch aggregated fields from the table: \"instructor_enrollments\""
    instructor_enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): instructor_enrollments_aggregate!
    listPaymentMethods: [PaymentMethod]!
    "fetch data from the table: \"schools\" using primary key columns"
    organization(id: uuid!): schools
    "fetch data from the table: \"schools_domains\" using primary key columns"
    organization_domain(id: uuid!): schools_domains
    "fetch data from the table: \"schools_domains\""
    organization_domains(
        "distinct select on columns"
        distinct_on: [schools_domains_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_domains_order_by!],
        "filter the rows returned"
        where: schools_domains_bool_exp
    ): [schools_domains!]!
    "fetch aggregated fields from the table: \"schools_domains\""
    organization_domains_aggregate(
        "distinct select on columns"
        distinct_on: [schools_domains_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_domains_order_by!],
        "filter the rows returned"
        where: schools_domains_bool_exp
    ): schools_domains_aggregate!
    "fetch data from the table: \"schools\""
    organizations(
        "distinct select on columns"
        distinct_on: [schools_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_order_by!],
        "filter the rows returned"
        where: schools_bool_exp
    ): [schools!]!
    "fetch aggregated fields from the table: \"schools\""
    organizations_aggregate(
        "distinct select on columns"
        distinct_on: [schools_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_order_by!],
        "filter the rows returned"
        where: schools_bool_exp
    ): schools_aggregate!
    "fetch data from the table: \"parent_email_survey\""
    parent_email_survey(
        "distinct select on columns"
        distinct_on: [parent_email_survey_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [parent_email_survey_order_by!],
        "filter the rows returned"
        where: parent_email_survey_bool_exp
    ): [parent_email_survey!]!
    "fetch aggregated fields from the table: \"parent_email_survey\""
    parent_email_survey_aggregate(
        "distinct select on columns"
        distinct_on: [parent_email_survey_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [parent_email_survey_order_by!],
        "filter the rows returned"
        where: parent_email_survey_bool_exp
    ): parent_email_survey_aggregate!
    ping: String
    plans: [SubscriptionPlans]!
    "fetch data from the table: \"products\" using primary key columns"
    product(id: String!): products
    "fetch data from the table: \"product_prices\" using primary key columns"
    product_price(id: String!): product_prices
    "fetch data from the table: \"product_prices\""
    product_prices(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!],
        "filter the rows returned"
        where: product_prices_bool_exp
    ): [product_prices!]!
    "fetch aggregated fields from the table: \"product_prices\""
    product_prices_aggregate(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!],
        "filter the rows returned"
        where: product_prices_bool_exp
    ): product_prices_aggregate!
    "fetch data from the table: \"products\""
    products(
        "distinct select on columns"
        distinct_on: [products_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [products_order_by!],
        "filter the rows returned"
        where: products_bool_exp
    ): [products!]!
    "fetch aggregated fields from the table: \"products\""
    products_aggregate(
        "distinct select on columns"
        distinct_on: [products_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [products_order_by!],
        "filter the rows returned"
        where: products_bool_exp
    ): products_aggregate!
    "fetch data from the table: \"profile\""
    profile(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): [profile!]!
    "fetch aggregated fields from the table: \"profile\""
    profile_aggregate(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): profile_aggregate!
    "fetch data from the table: \"promo_codes\" using primary key columns"
    promo_code(id: String!): promo_codes
    "fetch data from the table: \"promo_codes\""
    promo_codes(
        "distinct select on columns"
        distinct_on: [promo_codes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [promo_codes_order_by!],
        "filter the rows returned"
        where: promo_codes_bool_exp
    ): [promo_codes!]!
    "fetch aggregated fields from the table: \"promo_codes\""
    promo_codes_aggregate(
        "distinct select on columns"
        distinct_on: [promo_codes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [promo_codes_order_by!],
        "filter the rows returned"
        where: promo_codes_bool_exp
    ): promo_codes_aggregate!
    "fetch data from the table: \"redirect_mapping\""
    redirect_mapping(
        "distinct select on columns"
        distinct_on: [redirect_mapping_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [redirect_mapping_order_by!],
        "filter the rows returned"
        where: redirect_mapping_bool_exp
    ): [redirect_mapping!]!
    "fetch aggregated fields from the table: \"redirect_mapping\""
    redirect_mapping_aggregate(
        "distinct select on columns"
        distinct_on: [redirect_mapping_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [redirect_mapping_order_by!],
        "filter the rows returned"
        where: redirect_mapping_bool_exp
    ): redirect_mapping_aggregate!
    "fetch data from the table: \"redirect_mapping\" using primary key columns"
    redirect_mapping_by_pk(from_slug: String!, to_slug: String!): redirect_mapping
    "fetch data from the table: \"schedules\" using primary key columns"
    schedule(id: uuid!): schedules
    "fetch data from the table: \"schedules\""
    schedules(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): [schedules!]!
    "fetch aggregated fields from the table: \"schedules\""
    schedules_aggregate(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): schedules_aggregate!
    "execute function \"schedules_for_delighted_email_survey\" which returns \"parent_email_survey\""
    schedules_for_delighted_email_survey(
        "input parameters for function \"schedules_for_delighted_email_survey\""
        args: schedules_for_delighted_email_survey_args!,
        "distinct select on columns"
        distinct_on: [parent_email_survey_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [parent_email_survey_order_by!],
        "filter the rows returned"
        where: parent_email_survey_bool_exp
    ): [parent_email_survey!]!
    "execute function \"schedules_for_delighted_email_survey\" and query aggregates on result of table type \"parent_email_survey\""
    schedules_for_delighted_email_survey_aggregate(
        "input parameters for function \"schedules_for_delighted_email_survey\""
        args: schedules_for_delighted_email_survey_args!,
        "distinct select on columns"
        distinct_on: [parent_email_survey_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [parent_email_survey_order_by!],
        "filter the rows returned"
        where: parent_email_survey_bool_exp
    ): parent_email_survey_aggregate!
    "fetch data from the table: \"view_search_courses\""
    search_courses(
        "distinct select on columns"
        distinct_on: [view_search_courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [view_search_courses_order_by!],
        "filter the rows returned"
        where: view_search_courses_bool_exp
    ): [view_search_courses!]!
    "fetch aggregated fields from the table: \"view_search_courses\""
    search_courses_aggregate(
        "distinct select on columns"
        distinct_on: [view_search_courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [view_search_courses_order_by!],
        "filter the rows returned"
        where: view_search_courses_bool_exp
    ): view_search_courses_aggregate!
    "fetch data from the table: \"stripe_customers\" using primary key columns"
    stripe_customer(profileId: uuid!): stripe_customers
    "fetch data from the table: \"stripe_customers\""
    stripe_customers(
        "distinct select on columns"
        distinct_on: [stripe_customers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [stripe_customers_order_by!],
        "filter the rows returned"
        where: stripe_customers_bool_exp
    ): [stripe_customers!]!
    "fetch aggregated fields from the table: \"stripe_customers\""
    stripe_customers_aggregate(
        "distinct select on columns"
        distinct_on: [stripe_customers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [stripe_customers_order_by!],
        "filter the rows returned"
        where: stripe_customers_bool_exp
    ): stripe_customers_aggregate!
    "fetch data from the table: \"students\" using primary key columns"
    student(id: uuid!): students
    "fetch data from the table: \"student_enrollments\""
    student_enrollments(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): [student_enrollments!]!
    "fetch aggregated fields from the table: \"student_enrollments\""
    student_enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): student_enrollments_aggregate!
    "fetch data from the table: \"student_enrollments\" using primary key columns"
    student_enrollments_by_pk(id: uuid!): student_enrollments
    "fetch data from the table: \"student_meeting_enrollments\""
    student_meeting_enrollments(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): [student_meeting_enrollments!]!
    "fetch aggregated fields from the table: \"student_meeting_enrollments\""
    student_meeting_enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): student_meeting_enrollments_aggregate!
    "fetch data from the table: \"student_meeting_enrollments\" using primary key columns"
    student_meeting_enrollments_by_pk(id: uuid!): student_meeting_enrollments
    "fetch data from the table: \"student_sms_surveys\""
    student_sms_surveys(
        "distinct select on columns"
        distinct_on: [student_sms_surveys_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_sms_surveys_order_by!],
        "filter the rows returned"
        where: student_sms_surveys_bool_exp
    ): [student_sms_surveys!]!
    "fetch aggregated fields from the table: \"student_sms_surveys\""
    student_sms_surveys_aggregate(
        "distinct select on columns"
        distinct_on: [student_sms_surveys_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_sms_surveys_order_by!],
        "filter the rows returned"
        where: student_sms_surveys_bool_exp
    ): student_sms_surveys_aggregate!
    "fetch data from the table: \"students\""
    students(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): [students!]!
    "fetch aggregated fields from the table: \"students\""
    students_aggregate(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): students_aggregate!
    "fetch data from the table: \"subjects\" using primary key columns"
    subject(id: uuid!): subjects
    "fetch data from the table: \"subjects\""
    subjects(
        "distinct select on columns"
        distinct_on: [subjects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subjects_order_by!],
        "filter the rows returned"
        where: subjects_bool_exp
    ): [subjects!]!
    "fetch aggregated fields from the table: \"subjects\""
    subjects_aggregate(
        "distinct select on columns"
        distinct_on: [subjects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subjects_order_by!],
        "filter the rows returned"
        where: subjects_bool_exp
    ): subjects_aggregate!
    "fetch data from the table: \"subscriptions\" using primary key columns"
    subscription(id: uuid!): subscriptions
    subscriptionOverview: SubscriptionOverviewOutput
    "fetch data from the table: \"subscription_status\""
    subscription_status(
        "distinct select on columns"
        distinct_on: [subscription_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscription_status_order_by!],
        "filter the rows returned"
        where: subscription_status_bool_exp
    ): [subscription_status!]!
    "fetch aggregated fields from the table: \"subscription_status\""
    subscription_status_aggregate(
        "distinct select on columns"
        distinct_on: [subscription_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscription_status_order_by!],
        "filter the rows returned"
        where: subscription_status_bool_exp
    ): subscription_status_aggregate!
    "fetch data from the table: \"subscription_status\" using primary key columns"
    subscription_status_by_pk(value: String!): subscription_status
    "fetch data from the table: \"subscriptions\""
    subscriptions(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!],
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): [subscriptions!]!
    "fetch aggregated fields from the table: \"subscriptions\""
    subscriptions_aggregate(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!],
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): subscriptions_aggregate!
    "fetch data from the table: \"testimonials\" using primary key columns"
    testimonial(id: Int!): testimonials
    "fetch data from the table: \"testimonials\""
    testimonials(
        "distinct select on columns"
        distinct_on: [testimonials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [testimonials_order_by!],
        "filter the rows returned"
        where: testimonials_bool_exp
    ): [testimonials!]!
    "fetch aggregated fields from the table: \"testimonials\""
    testimonials_aggregate(
        "distinct select on columns"
        distinct_on: [testimonials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [testimonials_order_by!],
        "filter the rows returned"
        where: testimonials_bool_exp
    ): testimonials_aggregate!
    thinkificLink: ThinkificLink!
    "fetch data from the table: \"units\" using primary key columns"
    unit(id: uuid!): units
    "fetch data from the table: \"units\""
    units(
        "distinct select on columns"
        distinct_on: [units_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [units_order_by!],
        "filter the rows returned"
        where: units_bool_exp
    ): [units!]!
    "fetch aggregated fields from the table: \"units\""
    units_aggregate(
        "distinct select on columns"
        distinct_on: [units_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [units_order_by!],
        "filter the rows returned"
        where: units_bool_exp
    ): units_aggregate!
    "fetch data from the table: \"uploads\" using primary key columns"
    upload(id: uuid!): uploads
    "fetch data from the table: \"uploads\""
    uploads(
        "distinct select on columns"
        distinct_on: [uploads_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [uploads_order_by!],
        "filter the rows returned"
        where: uploads_bool_exp
    ): [uploads!]!
    "fetch aggregated fields from the table: \"uploads\""
    uploads_aggregate(
        "distinct select on columns"
        distinct_on: [uploads_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [uploads_order_by!],
        "filter the rows returned"
        where: uploads_bool_exp
    ): uploads_aggregate!
    "fetch data from the table: \"users\" using primary key columns"
    user(id: uuid!): users
    "fetch data from the table: \"user_roles\""
    user_roles(
        "distinct select on columns"
        distinct_on: [user_roles_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_roles_order_by!],
        "filter the rows returned"
        where: user_roles_bool_exp
    ): [user_roles!]!
    "fetch aggregated fields from the table: \"user_roles\""
    user_roles_aggregate(
        "distinct select on columns"
        distinct_on: [user_roles_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_roles_order_by!],
        "filter the rows returned"
        where: user_roles_bool_exp
    ): user_roles_aggregate!
    "fetch data from the table: \"user_roles\" using primary key columns"
    user_roles_by_pk(value: String!): user_roles
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    validateCoupon(code: String!): ValidateCouponResponse!
    "fetch data from the table: \"waitlists\" using primary key columns"
    waitlist(id: uuid!): waitlists
    "fetch data from the table: \"waitlists\""
    waitlists(
        "distinct select on columns"
        distinct_on: [waitlists_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [waitlists_order_by!],
        "filter the rows returned"
        where: waitlists_bool_exp
    ): [waitlists!]!
    "fetch aggregated fields from the table: \"waitlists\""
    waitlists_aggregate(
        "distinct select on columns"
        distinct_on: [waitlists_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [waitlists_order_by!],
        "filter the rows returned"
        where: waitlists_bool_exp
    ): waitlists_aggregate!
    "fetch data from the table: \"zoom_meetings\" using primary key columns"
    zoom_meeting(id: uuid!): zoom_meetings
    "fetch data from the table: \"zoom_meetings\""
    zoom_meetings(
        "distinct select on columns"
        distinct_on: [zoom_meetings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [zoom_meetings_order_by!],
        "filter the rows returned"
        where: zoom_meetings_bool_exp
    ): [zoom_meetings!]!
    "fetch aggregated fields from the table: \"zoom_meetings\""
    zoom_meetings_aggregate(
        "distinct select on columns"
        distinct_on: [zoom_meetings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [zoom_meetings_order_by!],
        "filter the rows returned"
        where: zoom_meetings_bool_exp
    ): zoom_meetings_aggregate!
}

"columns and relationships of \"redirect_mapping\""
type redirect_mapping {
    code: Int!
    from_slug: String!
    to_slug: String!
}

"aggregated selection of \"redirect_mapping\""
type redirect_mapping_aggregate {
    aggregate: redirect_mapping_aggregate_fields
    nodes: [redirect_mapping!]!
}

"aggregate fields of \"redirect_mapping\""
type redirect_mapping_aggregate_fields {
    avg: redirect_mapping_avg_fields
    count(columns: [redirect_mapping_select_column!], distinct: Boolean): Int
    max: redirect_mapping_max_fields
    min: redirect_mapping_min_fields
    stddev: redirect_mapping_stddev_fields
    stddev_pop: redirect_mapping_stddev_pop_fields
    stddev_samp: redirect_mapping_stddev_samp_fields
    sum: redirect_mapping_sum_fields
    var_pop: redirect_mapping_var_pop_fields
    var_samp: redirect_mapping_var_samp_fields
    variance: redirect_mapping_variance_fields
}

"aggregate avg on columns"
type redirect_mapping_avg_fields {
    code: Float
}

"aggregate max on columns"
type redirect_mapping_max_fields {
    code: Int
    from_slug: String
    to_slug: String
}

"aggregate min on columns"
type redirect_mapping_min_fields {
    code: Int
    from_slug: String
    to_slug: String
}

"response of any mutation on the table \"redirect_mapping\""
type redirect_mapping_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [redirect_mapping!]!
}

"aggregate stddev on columns"
type redirect_mapping_stddev_fields {
    code: Float
}

"aggregate stddev_pop on columns"
type redirect_mapping_stddev_pop_fields {
    code: Float
}

"aggregate stddev_samp on columns"
type redirect_mapping_stddev_samp_fields {
    code: Float
}

"aggregate sum on columns"
type redirect_mapping_sum_fields {
    code: Int
}

"aggregate var_pop on columns"
type redirect_mapping_var_pop_fields {
    code: Float
}

"aggregate var_samp on columns"
type redirect_mapping_var_samp_fields {
    code: Float
}

"aggregate variance on columns"
type redirect_mapping_variance_fields {
    code: Float
}

"columns and relationships of \"schedules\""
type schedules {
    cancelled: Boolean!
    "An object relationship"
    cohort: instructor_enrollments!
    "An object relationship"
    course: courses!
    courseId: uuid!
    endTime: timestamptz!
    id: uuid!
    "An object relationship"
    instructor: users
    instructorEnrollmentId: uuid!
    instructorId: uuid
    "An object relationship"
    registrant: student_meeting_enrollments
    "An array relationship"
    registrants(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): [student_meeting_enrollments!]!
    "An aggregated array relationship"
    registrants_aggregate(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): student_meeting_enrollments_aggregate!
    session: Int
    startTime: timestamptz!
    survey_sent: Boolean
    "An object relationship"
    zoomMeeting: zoom_meetings!
    zoomMeetingId: uuid!
    zoomOccurrenceId: String!
}

"aggregated selection of \"schedules\""
type schedules_aggregate {
    aggregate: schedules_aggregate_fields
    nodes: [schedules!]!
}

"aggregate fields of \"schedules\""
type schedules_aggregate_fields {
    avg: schedules_avg_fields
    count(columns: [schedules_select_column!], distinct: Boolean): Int
    max: schedules_max_fields
    min: schedules_min_fields
    stddev: schedules_stddev_fields
    stddev_pop: schedules_stddev_pop_fields
    stddev_samp: schedules_stddev_samp_fields
    sum: schedules_sum_fields
    var_pop: schedules_var_pop_fields
    var_samp: schedules_var_samp_fields
    variance: schedules_variance_fields
}

"aggregate avg on columns"
type schedules_avg_fields {
    session: Float
}

"aggregate max on columns"
type schedules_max_fields {
    courseId: uuid
    endTime: timestamptz
    id: uuid
    instructorEnrollmentId: uuid
    instructorId: uuid
    session: Int
    startTime: timestamptz
    zoomMeetingId: uuid
    zoomOccurrenceId: String
}

"aggregate min on columns"
type schedules_min_fields {
    courseId: uuid
    endTime: timestamptz
    id: uuid
    instructorEnrollmentId: uuid
    instructorId: uuid
    session: Int
    startTime: timestamptz
    zoomMeetingId: uuid
    zoomOccurrenceId: String
}

"response of any mutation on the table \"schedules\""
type schedules_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [schedules!]!
}

"aggregate stddev on columns"
type schedules_stddev_fields {
    session: Float
}

"aggregate stddev_pop on columns"
type schedules_stddev_pop_fields {
    session: Float
}

"aggregate stddev_samp on columns"
type schedules_stddev_samp_fields {
    session: Float
}

"aggregate sum on columns"
type schedules_sum_fields {
    session: Int
}

"aggregate var_pop on columns"
type schedules_var_pop_fields {
    session: Float
}

"aggregate var_samp on columns"
type schedules_var_samp_fields {
    session: Float
}

"aggregate variance on columns"
type schedules_variance_fields {
    session: Float
}

"columns and relationships of \"schools\""
type schools {
    banner: String
    config(
        "JSON select path"
        path: String
    ): jsonb
    "An array relationship"
    domains(
        "distinct select on columns"
        distinct_on: [schools_domains_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_domains_order_by!],
        "filter the rows returned"
        where: schools_domains_bool_exp
    ): [schools_domains!]!
    "An aggregated array relationship"
    domains_aggregate(
        "distinct select on columns"
        distinct_on: [schools_domains_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_domains_order_by!],
        "filter the rows returned"
        where: schools_domains_bool_exp
    ): schools_domains_aggregate!
    id: uuid!
    isSchool: Boolean!
    loginUrl: String
    logoUrl: String
    name: String!
    "An array relationship"
    profiles(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): [profile!]!
    "An aggregated array relationship"
    profiles_aggregate(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): profile_aggregate!
    provider: String
    "An array relationship"
    students(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): [students!]!
    "An aggregated array relationship"
    students_aggregate(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): students_aggregate!
    timeZone: String
}

"aggregated selection of \"schools\""
type schools_aggregate {
    aggregate: schools_aggregate_fields
    nodes: [schools!]!
}

"aggregate fields of \"schools\""
type schools_aggregate_fields {
    count(columns: [schools_select_column!], distinct: Boolean): Int
    max: schools_max_fields
    min: schools_min_fields
}

"columns and relationships of \"schools_domains\""
type schools_domains {
    domain: String!
    id: uuid!
    "An object relationship"
    organization: schools
    school_id: uuid!
}

"aggregated selection of \"schools_domains\""
type schools_domains_aggregate {
    aggregate: schools_domains_aggregate_fields
    nodes: [schools_domains!]!
}

"aggregate fields of \"schools_domains\""
type schools_domains_aggregate_fields {
    count(columns: [schools_domains_select_column!], distinct: Boolean): Int
    max: schools_domains_max_fields
    min: schools_domains_min_fields
}

"aggregate max on columns"
type schools_domains_max_fields {
    domain: String
    id: uuid
    school_id: uuid
}

"aggregate min on columns"
type schools_domains_min_fields {
    domain: String
    id: uuid
    school_id: uuid
}

"response of any mutation on the table \"schools_domains\""
type schools_domains_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [schools_domains!]!
}

"aggregate max on columns"
type schools_max_fields {
    banner: String
    id: uuid
    loginUrl: String
    logoUrl: String
    name: String
    provider: String
    timeZone: String
}

"aggregate min on columns"
type schools_min_fields {
    banner: String
    id: uuid
    loginUrl: String
    logoUrl: String
    name: String
    provider: String
    timeZone: String
}

"response of any mutation on the table \"schools\""
type schools_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [schools!]!
}

"columns and relationships of \"stripe_customers\""
type stripe_customers {
    customerId: String!
    profileId: uuid!
    "An array relationship"
    students(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): [students!]!
    "An aggregated array relationship"
    students_aggregate(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): students_aggregate!
    "An object relationship"
    user: profile
}

"aggregated selection of \"stripe_customers\""
type stripe_customers_aggregate {
    aggregate: stripe_customers_aggregate_fields
    nodes: [stripe_customers!]!
}

"aggregate fields of \"stripe_customers\""
type stripe_customers_aggregate_fields {
    count(columns: [stripe_customers_select_column!], distinct: Boolean): Int
    max: stripe_customers_max_fields
    min: stripe_customers_min_fields
}

"aggregate max on columns"
type stripe_customers_max_fields {
    customerId: String
    profileId: uuid
}

"aggregate min on columns"
type stripe_customers_min_fields {
    customerId: String
    profileId: uuid
}

"response of any mutation on the table \"stripe_customers\""
type stripe_customers_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [stripe_customers!]!
}

"columns and relationships of \"student_enrollments\""
type student_enrollments {
    "An object relationship"
    cohort: instructor_enrollments!
    "An object relationship"
    course: courses!
    course_id: uuid!
    created_at: timestamptz!
    id: uuid!
    instructorEnrollmentId: uuid!
    "An array relationship"
    meetingEnrollments(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): [student_meeting_enrollments!]!
    "An aggregated array relationship"
    meetingEnrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): student_meeting_enrollments_aggregate!
    "An object relationship"
    student: students!
    studentId: uuid!
    "An object relationship"
    subscription: subscriptions
    withSubscription: Boolean!
}

"aggregated selection of \"student_enrollments\""
type student_enrollments_aggregate {
    aggregate: student_enrollments_aggregate_fields
    nodes: [student_enrollments!]!
}

"aggregate fields of \"student_enrollments\""
type student_enrollments_aggregate_fields {
    count(columns: [student_enrollments_select_column!], distinct: Boolean): Int
    max: student_enrollments_max_fields
    min: student_enrollments_min_fields
}

"aggregate max on columns"
type student_enrollments_max_fields {
    course_id: uuid
    created_at: timestamptz
    id: uuid
    instructorEnrollmentId: uuid
    studentId: uuid
}

"aggregate min on columns"
type student_enrollments_min_fields {
    course_id: uuid
    created_at: timestamptz
    id: uuid
    instructorEnrollmentId: uuid
    studentId: uuid
}

"response of any mutation on the table \"student_enrollments\""
type student_enrollments_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [student_enrollments!]!
}

"columns and relationships of \"student_meeting_enrollments\""
type student_meeting_enrollments {
    "An object relationship"
    cohort: instructor_enrollments!
    "An object relationship"
    enrollment: student_enrollments!
    id: uuid!
    instructorEnrollmentId: uuid!
    joinUrl: String!
    reminder_notified: Boolean!
    sms_reminder_notified: Boolean
    studentEnrollmentId: uuid!
    "An object relationship"
    zoomMeeting: zoom_meetings!
    zoomMeetingId: uuid!
    zoomRegistrantId: String!
}

"aggregated selection of \"student_meeting_enrollments\""
type student_meeting_enrollments_aggregate {
    aggregate: student_meeting_enrollments_aggregate_fields
    nodes: [student_meeting_enrollments!]!
}

"aggregate fields of \"student_meeting_enrollments\""
type student_meeting_enrollments_aggregate_fields {
    count(columns: [student_meeting_enrollments_select_column!], distinct: Boolean): Int
    max: student_meeting_enrollments_max_fields
    min: student_meeting_enrollments_min_fields
}

"aggregate max on columns"
type student_meeting_enrollments_max_fields {
    id: uuid
    instructorEnrollmentId: uuid
    joinUrl: String
    studentEnrollmentId: uuid
    zoomMeetingId: uuid
    zoomRegistrantId: String
}

"aggregate min on columns"
type student_meeting_enrollments_min_fields {
    id: uuid
    instructorEnrollmentId: uuid
    joinUrl: String
    studentEnrollmentId: uuid
    zoomMeetingId: uuid
    zoomRegistrantId: String
}

"response of any mutation on the table \"student_meeting_enrollments\""
type student_meeting_enrollments_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [student_meeting_enrollments!]!
}

"columns and relationships of \"student_sms_surveys\""
type student_sms_surveys {
    "An object relationship"
    cohort: instructor_enrollments
    course_id: uuid
    email: String
    endTime: timestamptz
    fullName: citext
    instructor_enrollment_id: uuid
    opt_in_sms: Boolean
    phone: String
    startTime: timestamptz
    studentId: uuid
}

"aggregated selection of \"student_sms_surveys\""
type student_sms_surveys_aggregate {
    aggregate: student_sms_surveys_aggregate_fields
    nodes: [student_sms_surveys!]!
}

"aggregate fields of \"student_sms_surveys\""
type student_sms_surveys_aggregate_fields {
    count(columns: [student_sms_surveys_select_column!], distinct: Boolean): Int
    max: student_sms_surveys_max_fields
    min: student_sms_surveys_min_fields
}

"aggregate max on columns"
type student_sms_surveys_max_fields {
    course_id: uuid
    email: String
    endTime: timestamptz
    fullName: citext
    instructor_enrollment_id: uuid
    phone: String
    startTime: timestamptz
    studentId: uuid
}

"aggregate min on columns"
type student_sms_surveys_min_fields {
    course_id: uuid
    email: String
    endTime: timestamptz
    fullName: citext
    instructor_enrollment_id: uuid
    phone: String
    startTime: timestamptz
    studentId: uuid
}

"columns and relationships of \"students\""
type students {
    createdAt: timestamptz
    currentGradeId: Int
    dob: date
    email: String
    shopifyCustomerId: String
    "A computed field, executes function \"student_enrollment_status\""
    enrollmentStatus(
        "JSON select path"
        path: String
    ): json
    "An array relationship"
    enrollment_rules(
        "distinct select on columns"
        distinct_on: [enrollment_rules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_rules_order_by!],
        "filter the rows returned"
        where: enrollment_rules_bool_exp
    ): [enrollment_rules!]!
    "An aggregated array relationship"
    enrollment_rules_aggregate(
        "distinct select on columns"
        distinct_on: [enrollment_rules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_rules_order_by!],
        "filter the rows returned"
        where: enrollment_rules_bool_exp
    ): enrollment_rules_aggregate!
    firstName: String!
    fullName: citext
    "An object relationship"
    gender: gender_types
    genderType: gender_types_enum
    "An object relationship"
    grade: grades
    hasConfirmed: Boolean!
    id: uuid!
    internalId: String
    lastName: String!
    optInSms: Boolean
    "An object relationship"
    organization: schools
    organizationId: uuid
    "An object relationship"
    parent: users
    parent_id: uuid
    paying: Boolean!
    phone: String
    "An object relationship"
    school: schools
    "An object relationship"
    stripe: stripe_customers
    "An array relationship"
    student_enrollments(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): [student_enrollments!]!
    "An aggregated array relationship"
    student_enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): student_enrollments_aggregate!
    "An object relationship"
    subscription: subscriptions
    "An array relationship"
    subscriptions(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!],
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): [subscriptions!]!
    "An aggregated array relationship"
    subscriptions_aggregate(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!],
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): subscriptions_aggregate!
}

"aggregated selection of \"students\""
type students_aggregate {
    aggregate: students_aggregate_fields
    nodes: [students!]!
}

"aggregate fields of \"students\""
type students_aggregate_fields {
    avg: students_avg_fields
    count(columns: [students_select_column!], distinct: Boolean): Int
    max: students_max_fields
    min: students_min_fields
    stddev: students_stddev_fields
    stddev_pop: students_stddev_pop_fields
    stddev_samp: students_stddev_samp_fields
    sum: students_sum_fields
    var_pop: students_var_pop_fields
    var_samp: students_var_samp_fields
    variance: students_variance_fields
}

"aggregate avg on columns"
type students_avg_fields {
    currentGradeId: Float
}

"aggregate max on columns"
type students_max_fields {
    createdAt: timestamptz
    currentGradeId: Int
    dob: date
    email: String
    firstName: String
    fullName: citext
    id: uuid
    internalId: String
    lastName: String
    organizationId: uuid
    parent_id: uuid
    phone: String
}

"aggregate min on columns"
type students_min_fields {
    createdAt: timestamptz
    currentGradeId: Int
    dob: date
    email: String
    firstName: String
    fullName: citext
    id: uuid
    internalId: String
    lastName: String
    organizationId: uuid
    parent_id: uuid
    phone: String
}

"response of any mutation on the table \"students\""
type students_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [students!]!
}

"aggregate stddev on columns"
type students_stddev_fields {
    currentGradeId: Float
}

"aggregate stddev_pop on columns"
type students_stddev_pop_fields {
    currentGradeId: Float
}

"aggregate stddev_samp on columns"
type students_stddev_samp_fields {
    currentGradeId: Float
}

"aggregate sum on columns"
type students_sum_fields {
    currentGradeId: Int
}

"aggregate var_pop on columns"
type students_var_pop_fields {
    currentGradeId: Float
}

"aggregate var_samp on columns"
type students_var_samp_fields {
    currentGradeId: Float
}

"aggregate variance on columns"
type students_variance_fields {
    currentGradeId: Float
}

"columns and relationships of \"subjects\""
type subjects {
    "An array relationship"
    courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "An aggregated array relationship"
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    description(
        "JSON select path"
        path: String
    ): json
    id: uuid!
    name: String!
}

"aggregated selection of \"subjects\""
type subjects_aggregate {
    aggregate: subjects_aggregate_fields
    nodes: [subjects!]!
}

"aggregate fields of \"subjects\""
type subjects_aggregate_fields {
    count(columns: [subjects_select_column!], distinct: Boolean): Int
    max: subjects_max_fields
    min: subjects_min_fields
}

"aggregate max on columns"
type subjects_max_fields {
    id: uuid
    name: String
}

"aggregate min on columns"
type subjects_min_fields {
    id: uuid
    name: String
}

"response of any mutation on the table \"subjects\""
type subjects_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [subjects!]!
}

"subscription root"
type subscription_root {
    "fetch data from the table: \"ages\""
    ages(
        "distinct select on columns"
        distinct_on: [ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [ages_order_by!],
        "filter the rows returned"
        where: ages_bool_exp
    ): [ages!]!
    "fetch aggregated fields from the table: \"ages\""
    ages_aggregate(
        "distinct select on columns"
        distinct_on: [ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [ages_order_by!],
        "filter the rows returned"
        where: ages_bool_exp
    ): ages_aggregate!
    "fetch data from the table: \"ages\" using primary key columns"
    ages_by_pk(id: Int!): ages
    "fetch data from the table: \"application_config\""
    application_config(
        "distinct select on columns"
        distinct_on: [application_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_config_order_by!],
        "filter the rows returned"
        where: application_config_bool_exp
    ): [application_config!]!
    "fetch aggregated fields from the table: \"application_config\""
    application_config_aggregate(
        "distinct select on columns"
        distinct_on: [application_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_config_order_by!],
        "filter the rows returned"
        where: application_config_bool_exp
    ): application_config_aggregate!
    "fetch data from the table: \"application_config\" using primary key columns"
    application_config_by_pk(id: uuid!): application_config
    "fetch data from the table: \"coupons\" using primary key columns"
    coupon(id: String!): coupons
    "fetch data from the table: \"coupons\""
    coupons(
        "distinct select on columns"
        distinct_on: [coupons_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [coupons_order_by!],
        "filter the rows returned"
        where: coupons_bool_exp
    ): [coupons!]!
    "fetch aggregated fields from the table: \"coupons\""
    coupons_aggregate(
        "distinct select on columns"
        distinct_on: [coupons_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [coupons_order_by!],
        "filter the rows returned"
        where: coupons_bool_exp
    ): coupons_aggregate!
    "fetch data from the table: \"courses\" using primary key columns"
    course(id: uuid!): courses
    "fetch data from the table: \"course_ages\""
    course_ages(
        "distinct select on columns"
        distinct_on: [course_ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_ages_order_by!],
        "filter the rows returned"
        where: course_ages_bool_exp
    ): [course_ages!]!
    "fetch aggregated fields from the table: \"course_ages\""
    course_ages_aggregate(
        "distinct select on columns"
        distinct_on: [course_ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_ages_order_by!],
        "filter the rows returned"
        where: course_ages_bool_exp
    ): course_ages_aggregate!
    "fetch data from the table: \"course_ages\" using primary key columns"
    course_ages_by_pk(ageId: Int!, courseId: uuid!): course_ages
    "fetch data from the table: \"course_grades\""
    course_grades(
        "distinct select on columns"
        distinct_on: [course_grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_grades_order_by!],
        "filter the rows returned"
        where: course_grades_bool_exp
    ): [course_grades!]!
    "fetch aggregated fields from the table: \"course_grades\""
    course_grades_aggregate(
        "distinct select on columns"
        distinct_on: [course_grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_grades_order_by!],
        "filter the rows returned"
        where: course_grades_bool_exp
    ): course_grades_aggregate!
    "fetch data from the table: \"course_grades\" using primary key columns"
    course_grades_by_pk(courseId: uuid!, gradeId: Int!): course_grades
    "fetch data from the table: \"course_materials\" using primary key columns"
    course_material(id: Int!): course_materials
    "fetch data from the table: \"course_materials\""
    course_materials(
        "distinct select on columns"
        distinct_on: [course_materials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_materials_order_by!],
        "filter the rows returned"
        where: course_materials_bool_exp
    ): [course_materials!]!
    "fetch aggregated fields from the table: \"course_materials\""
    course_materials_aggregate(
        "distinct select on columns"
        distinct_on: [course_materials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_materials_order_by!],
        "filter the rows returned"
        where: course_materials_bool_exp
    ): course_materials_aggregate!
    "fetch data from the table: \"course_types\""
    course_types(
        "distinct select on columns"
        distinct_on: [course_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_types_order_by!],
        "filter the rows returned"
        where: course_types_bool_exp
    ): [course_types!]!
    "fetch aggregated fields from the table: \"course_types\""
    course_types_aggregate(
        "distinct select on columns"
        distinct_on: [course_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_types_order_by!],
        "filter the rows returned"
        where: course_types_bool_exp
    ): course_types_aggregate!
    "fetch data from the table: \"course_types\" using primary key columns"
    course_types_by_pk(value: String!): course_types
    "fetch data from the table: \"courses\""
    courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "fetch aggregated fields from the table: \"courses\""
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "fetch data from the table: \"durations\""
    durations(
        "distinct select on columns"
        distinct_on: [durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [durations_order_by!],
        "filter the rows returned"
        where: durations_bool_exp
    ): [durations!]!
    "fetch aggregated fields from the table: \"durations\""
    durations_aggregate(
        "distinct select on columns"
        distinct_on: [durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [durations_order_by!],
        "filter the rows returned"
        where: durations_bool_exp
    ): durations_aggregate!
    "fetch data from the table: \"durations\" using primary key columns"
    durations_by_pk(id: Int!): durations
    "fetch data from the table: \"enrollment_info\""
    enrollment_info(
        "distinct select on columns"
        distinct_on: [enrollment_info_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_info_order_by!],
        "filter the rows returned"
        where: enrollment_info_bool_exp
    ): [enrollment_info!]!
    "fetch aggregated fields from the table: \"enrollment_info\""
    enrollment_info_aggregate(
        "distinct select on columns"
        distinct_on: [enrollment_info_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_info_order_by!],
        "filter the rows returned"
        where: enrollment_info_bool_exp
    ): enrollment_info_aggregate!
    "fetch data from the table: \"enrollment_rules\" using primary key columns"
    enrollment_rule(id: Int!): enrollment_rules
    "fetch data from the table: \"enrollment_rules\""
    enrollment_rules(
        "distinct select on columns"
        distinct_on: [enrollment_rules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_rules_order_by!],
        "filter the rows returned"
        where: enrollment_rules_bool_exp
    ): [enrollment_rules!]!
    "fetch aggregated fields from the table: \"enrollment_rules\""
    enrollment_rules_aggregate(
        "distinct select on columns"
        distinct_on: [enrollment_rules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [enrollment_rules_order_by!],
        "filter the rows returned"
        where: enrollment_rules_bool_exp
    ): enrollment_rules_aggregate!
    "execute function \"featured_courses\" which returns \"courses\""
    featured_courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "execute function \"featured_courses\" and query aggregates on result of table type \"courses\""
    featured_courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [courses_order_by!],
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "fetch data from the table: \"frequency_types\""
    frequency_types(
        "distinct select on columns"
        distinct_on: [frequency_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [frequency_types_order_by!],
        "filter the rows returned"
        where: frequency_types_bool_exp
    ): [frequency_types!]!
    "fetch aggregated fields from the table: \"frequency_types\""
    frequency_types_aggregate(
        "distinct select on columns"
        distinct_on: [frequency_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [frequency_types_order_by!],
        "filter the rows returned"
        where: frequency_types_bool_exp
    ): frequency_types_aggregate!
    "fetch data from the table: \"frequency_types\" using primary key columns"
    frequency_types_by_pk(value: String!): frequency_types
    "fetch data from the table: \"gender_types\""
    gender_types(
        "distinct select on columns"
        distinct_on: [gender_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [gender_types_order_by!],
        "filter the rows returned"
        where: gender_types_bool_exp
    ): [gender_types!]!
    "fetch aggregated fields from the table: \"gender_types\""
    gender_types_aggregate(
        "distinct select on columns"
        distinct_on: [gender_types_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [gender_types_order_by!],
        "filter the rows returned"
        where: gender_types_bool_exp
    ): gender_types_aggregate!
    "fetch data from the table: \"gender_types\" using primary key columns"
    gender_types_by_pk(value: String!): gender_types
    "execute function \"get_application_config\" which returns \"application_config\""
    get_application_config(
        "distinct select on columns"
        distinct_on: [application_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_config_order_by!],
        "filter the rows returned"
        where: application_config_bool_exp
    ): [application_config!]!
    "execute function \"get_application_config\" and query aggregates on result of table type \"application_config\""
    get_application_config_aggregate(
        "distinct select on columns"
        distinct_on: [application_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_config_order_by!],
        "filter the rows returned"
        where: application_config_bool_exp
    ): application_config_aggregate!
    "fetch data from the table: \"grades\""
    grades(
        "distinct select on columns"
        distinct_on: [grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [grades_order_by!],
        "filter the rows returned"
        where: grades_bool_exp
    ): [grades!]!
    "fetch aggregated fields from the table: \"grades\""
    grades_aggregate(
        "distinct select on columns"
        distinct_on: [grades_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [grades_order_by!],
        "filter the rows returned"
        where: grades_bool_exp
    ): grades_aggregate!
    "fetch data from the table: \"grades\" using primary key columns"
    grades_by_pk(id: Int!): grades
    "fetch data from the table: \"instructor_enrollments\" using primary key columns"
    instructor_enrollment(id: uuid!): instructor_enrollments
    "fetch data from the table: \"instructor_enrollments\""
    instructor_enrollments(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): [instructor_enrollments!]!
    "fetch aggregated fields from the table: \"instructor_enrollments\""
    instructor_enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): instructor_enrollments_aggregate!
    "fetch data from the table: \"schools\" using primary key columns"
    organization(id: uuid!): schools
    "fetch data from the table: \"schools_domains\" using primary key columns"
    organization_domain(id: uuid!): schools_domains
    "fetch data from the table: \"schools_domains\""
    organization_domains(
        "distinct select on columns"
        distinct_on: [schools_domains_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_domains_order_by!],
        "filter the rows returned"
        where: schools_domains_bool_exp
    ): [schools_domains!]!
    "fetch aggregated fields from the table: \"schools_domains\""
    organization_domains_aggregate(
        "distinct select on columns"
        distinct_on: [schools_domains_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_domains_order_by!],
        "filter the rows returned"
        where: schools_domains_bool_exp
    ): schools_domains_aggregate!
    "fetch data from the table: \"schools\""
    organizations(
        "distinct select on columns"
        distinct_on: [schools_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_order_by!],
        "filter the rows returned"
        where: schools_bool_exp
    ): [schools!]!
    "fetch aggregated fields from the table: \"schools\""
    organizations_aggregate(
        "distinct select on columns"
        distinct_on: [schools_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schools_order_by!],
        "filter the rows returned"
        where: schools_bool_exp
    ): schools_aggregate!
    "fetch data from the table: \"parent_email_survey\""
    parent_email_survey(
        "distinct select on columns"
        distinct_on: [parent_email_survey_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [parent_email_survey_order_by!],
        "filter the rows returned"
        where: parent_email_survey_bool_exp
    ): [parent_email_survey!]!
    "fetch aggregated fields from the table: \"parent_email_survey\""
    parent_email_survey_aggregate(
        "distinct select on columns"
        distinct_on: [parent_email_survey_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [parent_email_survey_order_by!],
        "filter the rows returned"
        where: parent_email_survey_bool_exp
    ): parent_email_survey_aggregate!
    "fetch data from the table: \"products\" using primary key columns"
    product(id: String!): products
    "fetch data from the table: \"product_prices\" using primary key columns"
    product_price(id: String!): product_prices
    "fetch data from the table: \"product_prices\""
    product_prices(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!],
        "filter the rows returned"
        where: product_prices_bool_exp
    ): [product_prices!]!
    "fetch aggregated fields from the table: \"product_prices\""
    product_prices_aggregate(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!],
        "filter the rows returned"
        where: product_prices_bool_exp
    ): product_prices_aggregate!
    "fetch data from the table: \"products\""
    products(
        "distinct select on columns"
        distinct_on: [products_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [products_order_by!],
        "filter the rows returned"
        where: products_bool_exp
    ): [products!]!
    "fetch aggregated fields from the table: \"products\""
    products_aggregate(
        "distinct select on columns"
        distinct_on: [products_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [products_order_by!],
        "filter the rows returned"
        where: products_bool_exp
    ): products_aggregate!
    "fetch data from the table: \"profile\""
    profile(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): [profile!]!
    "fetch aggregated fields from the table: \"profile\""
    profile_aggregate(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): profile_aggregate!
    "fetch data from the table: \"promo_codes\" using primary key columns"
    promo_code(id: String!): promo_codes
    "fetch data from the table: \"promo_codes\""
    promo_codes(
        "distinct select on columns"
        distinct_on: [promo_codes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [promo_codes_order_by!],
        "filter the rows returned"
        where: promo_codes_bool_exp
    ): [promo_codes!]!
    "fetch aggregated fields from the table: \"promo_codes\""
    promo_codes_aggregate(
        "distinct select on columns"
        distinct_on: [promo_codes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [promo_codes_order_by!],
        "filter the rows returned"
        where: promo_codes_bool_exp
    ): promo_codes_aggregate!
    "fetch data from the table: \"redirect_mapping\""
    redirect_mapping(
        "distinct select on columns"
        distinct_on: [redirect_mapping_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [redirect_mapping_order_by!],
        "filter the rows returned"
        where: redirect_mapping_bool_exp
    ): [redirect_mapping!]!
    "fetch aggregated fields from the table: \"redirect_mapping\""
    redirect_mapping_aggregate(
        "distinct select on columns"
        distinct_on: [redirect_mapping_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [redirect_mapping_order_by!],
        "filter the rows returned"
        where: redirect_mapping_bool_exp
    ): redirect_mapping_aggregate!
    "fetch data from the table: \"redirect_mapping\" using primary key columns"
    redirect_mapping_by_pk(from_slug: String!, to_slug: String!): redirect_mapping
    "fetch data from the table: \"schedules\" using primary key columns"
    schedule(id: uuid!): schedules
    "fetch data from the table: \"schedules\""
    schedules(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): [schedules!]!
    "fetch aggregated fields from the table: \"schedules\""
    schedules_aggregate(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): schedules_aggregate!
    "execute function \"schedules_for_delighted_email_survey\" which returns \"parent_email_survey\""
    schedules_for_delighted_email_survey(
        "input parameters for function \"schedules_for_delighted_email_survey\""
        args: schedules_for_delighted_email_survey_args!,
        "distinct select on columns"
        distinct_on: [parent_email_survey_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [parent_email_survey_order_by!],
        "filter the rows returned"
        where: parent_email_survey_bool_exp
    ): [parent_email_survey!]!
    "execute function \"schedules_for_delighted_email_survey\" and query aggregates on result of table type \"parent_email_survey\""
    schedules_for_delighted_email_survey_aggregate(
        "input parameters for function \"schedules_for_delighted_email_survey\""
        args: schedules_for_delighted_email_survey_args!,
        "distinct select on columns"
        distinct_on: [parent_email_survey_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [parent_email_survey_order_by!],
        "filter the rows returned"
        where: parent_email_survey_bool_exp
    ): parent_email_survey_aggregate!
    "fetch data from the table: \"view_search_courses\""
    search_courses(
        "distinct select on columns"
        distinct_on: [view_search_courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [view_search_courses_order_by!],
        "filter the rows returned"
        where: view_search_courses_bool_exp
    ): [view_search_courses!]!
    "fetch aggregated fields from the table: \"view_search_courses\""
    search_courses_aggregate(
        "distinct select on columns"
        distinct_on: [view_search_courses_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [view_search_courses_order_by!],
        "filter the rows returned"
        where: view_search_courses_bool_exp
    ): view_search_courses_aggregate!
    "fetch data from the table: \"stripe_customers\" using primary key columns"
    stripe_customer(profileId: uuid!): stripe_customers
    "fetch data from the table: \"stripe_customers\""
    stripe_customers(
        "distinct select on columns"
        distinct_on: [stripe_customers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [stripe_customers_order_by!],
        "filter the rows returned"
        where: stripe_customers_bool_exp
    ): [stripe_customers!]!
    "fetch aggregated fields from the table: \"stripe_customers\""
    stripe_customers_aggregate(
        "distinct select on columns"
        distinct_on: [stripe_customers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [stripe_customers_order_by!],
        "filter the rows returned"
        where: stripe_customers_bool_exp
    ): stripe_customers_aggregate!
    "fetch data from the table: \"students\" using primary key columns"
    student(id: uuid!): students
    "fetch data from the table: \"student_enrollments\""
    student_enrollments(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): [student_enrollments!]!
    "fetch aggregated fields from the table: \"student_enrollments\""
    student_enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_enrollments_order_by!],
        "filter the rows returned"
        where: student_enrollments_bool_exp
    ): student_enrollments_aggregate!
    "fetch data from the table: \"student_enrollments\" using primary key columns"
    student_enrollments_by_pk(id: uuid!): student_enrollments
    "fetch data from the table: \"student_meeting_enrollments\""
    student_meeting_enrollments(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): [student_meeting_enrollments!]!
    "fetch aggregated fields from the table: \"student_meeting_enrollments\""
    student_meeting_enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): student_meeting_enrollments_aggregate!
    "fetch data from the table: \"student_meeting_enrollments\" using primary key columns"
    student_meeting_enrollments_by_pk(id: uuid!): student_meeting_enrollments
    "fetch data from the table: \"student_sms_surveys\""
    student_sms_surveys(
        "distinct select on columns"
        distinct_on: [student_sms_surveys_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_sms_surveys_order_by!],
        "filter the rows returned"
        where: student_sms_surveys_bool_exp
    ): [student_sms_surveys!]!
    "fetch aggregated fields from the table: \"student_sms_surveys\""
    student_sms_surveys_aggregate(
        "distinct select on columns"
        distinct_on: [student_sms_surveys_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_sms_surveys_order_by!],
        "filter the rows returned"
        where: student_sms_surveys_bool_exp
    ): student_sms_surveys_aggregate!
    "fetch data from the table: \"students\""
    students(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): [students!]!
    "fetch aggregated fields from the table: \"students\""
    students_aggregate(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): students_aggregate!
    "fetch data from the table: \"subjects\" using primary key columns"
    subject(id: uuid!): subjects
    "fetch data from the table: \"subjects\""
    subjects(
        "distinct select on columns"
        distinct_on: [subjects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subjects_order_by!],
        "filter the rows returned"
        where: subjects_bool_exp
    ): [subjects!]!
    "fetch aggregated fields from the table: \"subjects\""
    subjects_aggregate(
        "distinct select on columns"
        distinct_on: [subjects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subjects_order_by!],
        "filter the rows returned"
        where: subjects_bool_exp
    ): subjects_aggregate!
    "fetch data from the table: \"subscriptions\" using primary key columns"
    subscription(id: uuid!): subscriptions
    "fetch data from the table: \"subscription_status\""
    subscription_status(
        "distinct select on columns"
        distinct_on: [subscription_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscription_status_order_by!],
        "filter the rows returned"
        where: subscription_status_bool_exp
    ): [subscription_status!]!
    "fetch aggregated fields from the table: \"subscription_status\""
    subscription_status_aggregate(
        "distinct select on columns"
        distinct_on: [subscription_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscription_status_order_by!],
        "filter the rows returned"
        where: subscription_status_bool_exp
    ): subscription_status_aggregate!
    "fetch data from the table: \"subscription_status\" using primary key columns"
    subscription_status_by_pk(value: String!): subscription_status
    "fetch data from the table: \"subscriptions\""
    subscriptions(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!],
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): [subscriptions!]!
    "fetch aggregated fields from the table: \"subscriptions\""
    subscriptions_aggregate(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!],
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): subscriptions_aggregate!
    "fetch data from the table: \"testimonials\" using primary key columns"
    testimonial(id: Int!): testimonials
    "fetch data from the table: \"testimonials\""
    testimonials(
        "distinct select on columns"
        distinct_on: [testimonials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [testimonials_order_by!],
        "filter the rows returned"
        where: testimonials_bool_exp
    ): [testimonials!]!
    "fetch aggregated fields from the table: \"testimonials\""
    testimonials_aggregate(
        "distinct select on columns"
        distinct_on: [testimonials_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [testimonials_order_by!],
        "filter the rows returned"
        where: testimonials_bool_exp
    ): testimonials_aggregate!
    "fetch data from the table: \"units\" using primary key columns"
    unit(id: uuid!): units
    "fetch data from the table: \"units\""
    units(
        "distinct select on columns"
        distinct_on: [units_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [units_order_by!],
        "filter the rows returned"
        where: units_bool_exp
    ): [units!]!
    "fetch aggregated fields from the table: \"units\""
    units_aggregate(
        "distinct select on columns"
        distinct_on: [units_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [units_order_by!],
        "filter the rows returned"
        where: units_bool_exp
    ): units_aggregate!
    "fetch data from the table: \"uploads\" using primary key columns"
    upload(id: uuid!): uploads
    "fetch data from the table: \"uploads\""
    uploads(
        "distinct select on columns"
        distinct_on: [uploads_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [uploads_order_by!],
        "filter the rows returned"
        where: uploads_bool_exp
    ): [uploads!]!
    "fetch aggregated fields from the table: \"uploads\""
    uploads_aggregate(
        "distinct select on columns"
        distinct_on: [uploads_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [uploads_order_by!],
        "filter the rows returned"
        where: uploads_bool_exp
    ): uploads_aggregate!
    "fetch data from the table: \"users\" using primary key columns"
    user(id: uuid!): users
    "fetch data from the table: \"user_roles\""
    user_roles(
        "distinct select on columns"
        distinct_on: [user_roles_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_roles_order_by!],
        "filter the rows returned"
        where: user_roles_bool_exp
    ): [user_roles!]!
    "fetch aggregated fields from the table: \"user_roles\""
    user_roles_aggregate(
        "distinct select on columns"
        distinct_on: [user_roles_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_roles_order_by!],
        "filter the rows returned"
        where: user_roles_bool_exp
    ): user_roles_aggregate!
    "fetch data from the table: \"user_roles\" using primary key columns"
    user_roles_by_pk(value: String!): user_roles
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    "fetch data from the table: \"waitlists\" using primary key columns"
    waitlist(id: uuid!): waitlists
    "fetch data from the table: \"waitlists\""
    waitlists(
        "distinct select on columns"
        distinct_on: [waitlists_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [waitlists_order_by!],
        "filter the rows returned"
        where: waitlists_bool_exp
    ): [waitlists!]!
    "fetch aggregated fields from the table: \"waitlists\""
    waitlists_aggregate(
        "distinct select on columns"
        distinct_on: [waitlists_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [waitlists_order_by!],
        "filter the rows returned"
        where: waitlists_bool_exp
    ): waitlists_aggregate!
    "fetch data from the table: \"zoom_meetings\" using primary key columns"
    zoom_meeting(id: uuid!): zoom_meetings
    "fetch data from the table: \"zoom_meetings\""
    zoom_meetings(
        "distinct select on columns"
        distinct_on: [zoom_meetings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [zoom_meetings_order_by!],
        "filter the rows returned"
        where: zoom_meetings_bool_exp
    ): [zoom_meetings!]!
    "fetch aggregated fields from the table: \"zoom_meetings\""
    zoom_meetings_aggregate(
        "distinct select on columns"
        distinct_on: [zoom_meetings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [zoom_meetings_order_by!],
        "filter the rows returned"
        where: zoom_meetings_bool_exp
    ): zoom_meetings_aggregate!
}

"columns and relationships of \"subscription_status\""
type subscription_status {
    description: String!
    value: String!
}

"aggregated selection of \"subscription_status\""
type subscription_status_aggregate {
    aggregate: subscription_status_aggregate_fields
    nodes: [subscription_status!]!
}

"aggregate fields of \"subscription_status\""
type subscription_status_aggregate_fields {
    count(columns: [subscription_status_select_column!], distinct: Boolean): Int
    max: subscription_status_max_fields
    min: subscription_status_min_fields
}

"aggregate max on columns"
type subscription_status_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type subscription_status_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"subscription_status\""
type subscription_status_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [subscription_status!]!
}

"columns and relationships of \"subscriptions\""
type subscriptions {
    cancelAt: timestamptz
    createdAt: timestamptz!
    id: uuid!
    "An object relationship"
    parent: users
    parentId: uuid
    "An object relationship"
    price: product_prices
    productPriceId: String
    status: subscription_status_enum!
    stripeObject(
        "JSON select path"
        path: String
    ): json
    stripePendingInvoiceId: String
    stripeSubscriptionId: String!
    stripeSubscriptionItemId: String
    "An object relationship"
    student: students!
    studentId: uuid!
    updatedAt: timestamptz!
}

"aggregated selection of \"subscriptions\""
type subscriptions_aggregate {
    aggregate: subscriptions_aggregate_fields
    nodes: [subscriptions!]!
}

"aggregate fields of \"subscriptions\""
type subscriptions_aggregate_fields {
    count(columns: [subscriptions_select_column!], distinct: Boolean): Int
    max: subscriptions_max_fields
    min: subscriptions_min_fields
}

"aggregate max on columns"
type subscriptions_max_fields {
    cancelAt: timestamptz
    createdAt: timestamptz
    id: uuid
    parentId: uuid
    productPriceId: String
    stripePendingInvoiceId: String
    stripeSubscriptionId: String
    stripeSubscriptionItemId: String
    studentId: uuid
    updatedAt: timestamptz
}

"aggregate min on columns"
type subscriptions_min_fields {
    cancelAt: timestamptz
    createdAt: timestamptz
    id: uuid
    parentId: uuid
    productPriceId: String
    stripePendingInvoiceId: String
    stripeSubscriptionId: String
    stripeSubscriptionItemId: String
    studentId: uuid
    updatedAt: timestamptz
}

"response of any mutation on the table \"subscriptions\""
type subscriptions_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [subscriptions!]!
}

"columns and relationships of \"testimonials\""
type testimonials {
    "An object relationship"
    avatar: uploads
    avatarId: uuid
    content: String!
    "An object relationship"
    course: courses
    courseId: uuid
    id: Int!
    name: String!
    order: Int
    role: String
}

"aggregated selection of \"testimonials\""
type testimonials_aggregate {
    aggregate: testimonials_aggregate_fields
    nodes: [testimonials!]!
}

"aggregate fields of \"testimonials\""
type testimonials_aggregate_fields {
    avg: testimonials_avg_fields
    count(columns: [testimonials_select_column!], distinct: Boolean): Int
    max: testimonials_max_fields
    min: testimonials_min_fields
    stddev: testimonials_stddev_fields
    stddev_pop: testimonials_stddev_pop_fields
    stddev_samp: testimonials_stddev_samp_fields
    sum: testimonials_sum_fields
    var_pop: testimonials_var_pop_fields
    var_samp: testimonials_var_samp_fields
    variance: testimonials_variance_fields
}

"aggregate avg on columns"
type testimonials_avg_fields {
    id: Float
    order: Float
}

"aggregate max on columns"
type testimonials_max_fields {
    avatarId: uuid
    content: String
    courseId: uuid
    id: Int
    name: String
    order: Int
    role: String
}

"aggregate min on columns"
type testimonials_min_fields {
    avatarId: uuid
    content: String
    courseId: uuid
    id: Int
    name: String
    order: Int
    role: String
}

"response of any mutation on the table \"testimonials\""
type testimonials_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [testimonials!]!
}

"aggregate stddev on columns"
type testimonials_stddev_fields {
    id: Float
    order: Float
}

"aggregate stddev_pop on columns"
type testimonials_stddev_pop_fields {
    id: Float
    order: Float
}

"aggregate stddev_samp on columns"
type testimonials_stddev_samp_fields {
    id: Float
    order: Float
}

"aggregate sum on columns"
type testimonials_sum_fields {
    id: Int
    order: Int
}

"aggregate var_pop on columns"
type testimonials_var_pop_fields {
    id: Float
    order: Float
}

"aggregate var_samp on columns"
type testimonials_var_samp_fields {
    id: Float
    order: Float
}

"aggregate variance on columns"
type testimonials_variance_fields {
    id: Float
    order: Float
}

"columns and relationships of \"units\""
type units {
    capacity: Int!
    "An array relationship"
    cohorts(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): [instructor_enrollments!]!
    "An aggregated array relationship"
    cohorts_aggregate(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): instructor_enrollments_aggregate!
    "An object relationship"
    course: courses!
    courseId: uuid!
    description: String!
    "An object relationship"
    duration: durations!
    durationId: Int!
    "An object relationship"
    frequency: frequency_types!
    frequencyType: frequency_types_enum!
    id: uuid!
    name: String!
    order: Int
    price: Int!
    totalSessions: Int!
}

"aggregated selection of \"units\""
type units_aggregate {
    aggregate: units_aggregate_fields
    nodes: [units!]!
}

"aggregate fields of \"units\""
type units_aggregate_fields {
    avg: units_avg_fields
    count(columns: [units_select_column!], distinct: Boolean): Int
    max: units_max_fields
    min: units_min_fields
    stddev: units_stddev_fields
    stddev_pop: units_stddev_pop_fields
    stddev_samp: units_stddev_samp_fields
    sum: units_sum_fields
    var_pop: units_var_pop_fields
    var_samp: units_var_samp_fields
    variance: units_variance_fields
}

"aggregate avg on columns"
type units_avg_fields {
    capacity: Float
    durationId: Float
    order: Float
    price: Float
    totalSessions: Float
}

"aggregate max on columns"
type units_max_fields {
    capacity: Int
    courseId: uuid
    description: String
    durationId: Int
    id: uuid
    name: String
    order: Int
    price: Int
    totalSessions: Int
}

"aggregate min on columns"
type units_min_fields {
    capacity: Int
    courseId: uuid
    description: String
    durationId: Int
    id: uuid
    name: String
    order: Int
    price: Int
    totalSessions: Int
}

"response of any mutation on the table \"units\""
type units_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [units!]!
}

"aggregate stddev on columns"
type units_stddev_fields {
    capacity: Float
    durationId: Float
    order: Float
    price: Float
    totalSessions: Float
}

"aggregate stddev_pop on columns"
type units_stddev_pop_fields {
    capacity: Float
    durationId: Float
    order: Float
    price: Float
    totalSessions: Float
}

"aggregate stddev_samp on columns"
type units_stddev_samp_fields {
    capacity: Float
    durationId: Float
    order: Float
    price: Float
    totalSessions: Float
}

"aggregate sum on columns"
type units_sum_fields {
    capacity: Int
    durationId: Int
    order: Int
    price: Int
    totalSessions: Int
}

"aggregate var_pop on columns"
type units_var_pop_fields {
    capacity: Float
    durationId: Float
    order: Float
    price: Float
    totalSessions: Float
}

"aggregate var_samp on columns"
type units_var_samp_fields {
    capacity: Float
    durationId: Float
    order: Float
    price: Float
    totalSessions: Float
}

"aggregate variance on columns"
type units_variance_fields {
    capacity: Float
    durationId: Float
    order: Float
    price: Float
    totalSessions: Float
}

"columns and relationships of \"uploads\""
type uploads {
    bucket: String
    created_at: timestamptz
    deletedAt: timestamptz
    id: uuid!
    mediaType: String
    name: String
    size: Int
    updated_at: timestamptz
    "A computed field, executes function \"get_upload_url\""
    url: String
}

"aggregated selection of \"uploads\""
type uploads_aggregate {
    aggregate: uploads_aggregate_fields
    nodes: [uploads!]!
}

"aggregate fields of \"uploads\""
type uploads_aggregate_fields {
    avg: uploads_avg_fields
    count(columns: [uploads_select_column!], distinct: Boolean): Int
    max: uploads_max_fields
    min: uploads_min_fields
    stddev: uploads_stddev_fields
    stddev_pop: uploads_stddev_pop_fields
    stddev_samp: uploads_stddev_samp_fields
    sum: uploads_sum_fields
    var_pop: uploads_var_pop_fields
    var_samp: uploads_var_samp_fields
    variance: uploads_variance_fields
}

"aggregate avg on columns"
type uploads_avg_fields {
    size: Float
}

"aggregate max on columns"
type uploads_max_fields {
    bucket: String
    created_at: timestamptz
    deletedAt: timestamptz
    id: uuid
    mediaType: String
    name: String
    size: Int
    updated_at: timestamptz
}

"aggregate min on columns"
type uploads_min_fields {
    bucket: String
    created_at: timestamptz
    deletedAt: timestamptz
    id: uuid
    mediaType: String
    name: String
    size: Int
    updated_at: timestamptz
}

"response of any mutation on the table \"uploads\""
type uploads_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [uploads!]!
}

"aggregate stddev on columns"
type uploads_stddev_fields {
    size: Float
}

"aggregate stddev_pop on columns"
type uploads_stddev_pop_fields {
    size: Float
}

"aggregate stddev_samp on columns"
type uploads_stddev_samp_fields {
    size: Float
}

"aggregate sum on columns"
type uploads_sum_fields {
    size: Int
}

"aggregate var_pop on columns"
type uploads_var_pop_fields {
    size: Float
}

"aggregate var_samp on columns"
type uploads_var_samp_fields {
    size: Float
}

"aggregate variance on columns"
type uploads_variance_fields {
    size: Float
}

"columns and relationships of \"user_roles\""
type user_roles {
    description: String!
    "An array relationship"
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "An aggregated array relationship"
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    value: String!
}

"aggregated selection of \"user_roles\""
type user_roles_aggregate {
    aggregate: user_roles_aggregate_fields
    nodes: [user_roles!]!
}

"aggregate fields of \"user_roles\""
type user_roles_aggregate_fields {
    count(columns: [user_roles_select_column!], distinct: Boolean): Int
    max: user_roles_max_fields
    min: user_roles_min_fields
}

"aggregate max on columns"
type user_roles_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type user_roles_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"user_roles\""
type user_roles_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [user_roles!]!
}

"columns and relationships of \"users\""
type users {
    "An object relationship"
    avatar: uploads
    avatarId: uuid
    bio: String
    created_at: timestamptz
    email: String!
    emailAlias: String
    firstName: String!
    fullName: citext
    hasConfirmed: Boolean!
    shopifyCustomerId: String
    id: uuid!
    "An array relationship"
    instructor_enrollments(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): [instructor_enrollments!]!
    "An aggregated array relationship"
    instructor_enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [instructor_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [instructor_enrollments_order_by!],
        "filter the rows returned"
        where: instructor_enrollments_bool_exp
    ): instructor_enrollments_aggregate!
    lastName: String!
    optInSms: Boolean
    "An object relationship"
    organization: schools
    organizationId: uuid
    personal_zoom: Boolean!
    phone: String
    provisioning: Boolean!
    role: String!
    "An array relationship"
    schedules(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): [schedules!]!
    "An aggregated array relationship"
    schedules_aggregate(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): schedules_aggregate!
    "An object relationship"
    stripe: stripe_customers
    "An array relationship"
    students(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): [students!]!
    "An aggregated array relationship"
    students_aggregate(
        "distinct select on columns"
        distinct_on: [students_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [students_order_by!],
        "filter the rows returned"
        where: students_bool_exp
    ): students_aggregate!
    "An array relationship"
    subscriptions(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!],
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): [subscriptions!]!
    "An aggregated array relationship"
    subscriptions_aggregate(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!],
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): subscriptions_aggregate!
    thinkificId: Int
    "An object relationship"
    user_role: user_roles!
    zoomId: String
}

"aggregated selection of \"users\""
type users_aggregate {
    aggregate: users_aggregate_fields
    nodes: [users!]!
}

"aggregate fields of \"users\""
type users_aggregate_fields {
    avg: users_avg_fields
    count(columns: [users_select_column!], distinct: Boolean): Int
    max: users_max_fields
    min: users_min_fields
    stddev: users_stddev_fields
    stddev_pop: users_stddev_pop_fields
    stddev_samp: users_stddev_samp_fields
    sum: users_sum_fields
    var_pop: users_var_pop_fields
    var_samp: users_var_samp_fields
    variance: users_variance_fields
}

"aggregate avg on columns"
type users_avg_fields {
    thinkificId: Float
}

"aggregate max on columns"
type users_max_fields {
    avatarId: uuid
    bio: String
    created_at: timestamptz
    email: String
    emailAlias: String
    firstName: String
    fullName: citext
    id: uuid
    lastName: String
    organizationId: uuid
    phone: String
    role: String
    thinkificId: Int
    zoomId: String
}

"aggregate min on columns"
type users_min_fields {
    avatarId: uuid
    bio: String
    created_at: timestamptz
    email: String
    emailAlias: String
    firstName: String
    fullName: citext
    id: uuid
    lastName: String
    organizationId: uuid
    phone: String
    role: String
    thinkificId: Int
    zoomId: String
}

"response of any mutation on the table \"users\""
type users_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [users!]!
}

"aggregate stddev on columns"
type users_stddev_fields {
    thinkificId: Float
}

"aggregate stddev_pop on columns"
type users_stddev_pop_fields {
    thinkificId: Float
}

"aggregate stddev_samp on columns"
type users_stddev_samp_fields {
    thinkificId: Float
}

"aggregate sum on columns"
type users_sum_fields {
    thinkificId: Int
}

"aggregate var_pop on columns"
type users_var_pop_fields {
    thinkificId: Float
}

"aggregate var_samp on columns"
type users_var_samp_fields {
    thinkificId: Float
}

"aggregate variance on columns"
type users_variance_fields {
    thinkificId: Float
}

"columns and relationships of \"view_search_courses\""
type view_search_courses {
    academic: String
    "An array relationship"
    ages(
        "distinct select on columns"
        distinct_on: [course_ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_ages_order_by!],
        "filter the rows returned"
        where: course_ages_bool_exp
    ): [course_ages!]!
    "An aggregated array relationship"
    ages_aggregate(
        "distinct select on columns"
        distinct_on: [course_ages_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [course_ages_order_by!],
        "filter the rows returned"
        where: course_ages_bool_exp
    ): course_ages_aggregate!
    description: String
    "An object relationship"
    duration: durations
    durationId: Int
    headline: String
    id: uuid
    name: String
    slug: String
    startTime: timestamptz
    "An object relationship"
    subject: subjects
    subjectId: uuid
}

"aggregated selection of \"view_search_courses\""
type view_search_courses_aggregate {
    aggregate: view_search_courses_aggregate_fields
    nodes: [view_search_courses!]!
}

"aggregate fields of \"view_search_courses\""
type view_search_courses_aggregate_fields {
    avg: view_search_courses_avg_fields
    count(columns: [view_search_courses_select_column!], distinct: Boolean): Int
    max: view_search_courses_max_fields
    min: view_search_courses_min_fields
    stddev: view_search_courses_stddev_fields
    stddev_pop: view_search_courses_stddev_pop_fields
    stddev_samp: view_search_courses_stddev_samp_fields
    sum: view_search_courses_sum_fields
    var_pop: view_search_courses_var_pop_fields
    var_samp: view_search_courses_var_samp_fields
    variance: view_search_courses_variance_fields
}

"aggregate avg on columns"
type view_search_courses_avg_fields {
    durationId: Float
}

"aggregate max on columns"
type view_search_courses_max_fields {
    academic: String
    description: String
    durationId: Int
    headline: String
    id: uuid
    name: String
    slug: String
    startTime: timestamptz
    subjectId: uuid
}

"aggregate min on columns"
type view_search_courses_min_fields {
    academic: String
    description: String
    durationId: Int
    headline: String
    id: uuid
    name: String
    slug: String
    startTime: timestamptz
    subjectId: uuid
}

"aggregate stddev on columns"
type view_search_courses_stddev_fields {
    durationId: Float
}

"aggregate stddev_pop on columns"
type view_search_courses_stddev_pop_fields {
    durationId: Float
}

"aggregate stddev_samp on columns"
type view_search_courses_stddev_samp_fields {
    durationId: Float
}

"aggregate sum on columns"
type view_search_courses_sum_fields {
    durationId: Int
}

"aggregate var_pop on columns"
type view_search_courses_var_pop_fields {
    durationId: Float
}

"aggregate var_samp on columns"
type view_search_courses_var_samp_fields {
    durationId: Float
}

"aggregate variance on columns"
type view_search_courses_variance_fields {
    durationId: Float
}

"columns and relationships of \"waitlists\""
type waitlists {
    email: String
    id: uuid!
    "An object relationship"
    profile: profile
    profileId: uuid
    shouldNotify: Boolean!
    "An object relationship"
    unit: units!
    unitId: uuid!
}

"aggregated selection of \"waitlists\""
type waitlists_aggregate {
    aggregate: waitlists_aggregate_fields
    nodes: [waitlists!]!
}

"aggregate fields of \"waitlists\""
type waitlists_aggregate_fields {
    count(columns: [waitlists_select_column!], distinct: Boolean): Int
    max: waitlists_max_fields
    min: waitlists_min_fields
}

"aggregate max on columns"
type waitlists_max_fields {
    email: String
    id: uuid
    profileId: uuid
    unitId: uuid
}

"aggregate min on columns"
type waitlists_min_fields {
    email: String
    id: uuid
    profileId: uuid
    unitId: uuid
}

"response of any mutation on the table \"waitlists\""
type waitlists_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [waitlists!]!
}

"columns and relationships of \"zoom_meetings\""
type zoom_meetings {
    "An object relationship"
    cohort: instructor_enrollments!
    "An object relationship"
    course: courses!
    courseId: uuid!
    created_at: timestamptz!
    endDate: date!
    id: uuid!
    instructor_enrollment_id: uuid!
    internalZoomMeetingId: String
    password: String!
    "An array relationship"
    schedules(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): [schedules!]!
    "An aggregated array relationship"
    schedules_aggregate(
        "distinct select on columns"
        distinct_on: [schedules_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [schedules_order_by!],
        "filter the rows returned"
        where: schedules_bool_exp
    ): schedules_aggregate!
    startDate: date!
    startUrl: String!
    "An array relationship"
    studentMeetings(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): [student_meeting_enrollments!]!
    "An aggregated array relationship"
    studentMeetings_aggregate(
        "distinct select on columns"
        distinct_on: [student_meeting_enrollments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [student_meeting_enrollments_order_by!],
        "filter the rows returned"
        where: student_meeting_enrollments_bool_exp
    ): student_meeting_enrollments_aggregate!
    updated_at: timestamptz!
}

"aggregated selection of \"zoom_meetings\""
type zoom_meetings_aggregate {
    aggregate: zoom_meetings_aggregate_fields
    nodes: [zoom_meetings!]!
}

"aggregate fields of \"zoom_meetings\""
type zoom_meetings_aggregate_fields {
    count(columns: [zoom_meetings_select_column!], distinct: Boolean): Int
    max: zoom_meetings_max_fields
    min: zoom_meetings_min_fields
}

"aggregate max on columns"
type zoom_meetings_max_fields {
    courseId: uuid
    created_at: timestamptz
    endDate: date
    id: uuid
    instructor_enrollment_id: uuid
    internalZoomMeetingId: String
    password: String
    startDate: date
    startUrl: String
    updated_at: timestamptz
}

"aggregate min on columns"
type zoom_meetings_min_fields {
    courseId: uuid
    created_at: timestamptz
    endDate: date
    id: uuid
    instructor_enrollment_id: uuid
    internalZoomMeetingId: String
    password: String
    startDate: date
    startUrl: String
    updated_at: timestamptz
}

"response of any mutation on the table \"zoom_meetings\""
type zoom_meetings_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [zoom_meetings!]!
}

enum EntityUpdateType {
    testimonial
    unit
}

"unique or primary key constraints on table \"ages\""
enum ages_constraint {
    "unique or primary key constraint"
    ages_pkey
}

"select columns of table \"ages\""
enum ages_select_column {
    "column name"
    id
    "column name"
    name
    "column name"
    value
}

"update columns of table \"ages\""
enum ages_update_column {
    "column name"
    id
    "column name"
    name
    "column name"
    value
}

"unique or primary key constraints on table \"application_config\""
enum application_config_constraint {
    "unique or primary key constraint"
    application_config_pkey
}

"select columns of table \"application_config\""
enum application_config_select_column {
    "column name"
    id
    "column name"
    immersiveDiscount
}

"update columns of table \"application_config\""
enum application_config_update_column {
    "column name"
    id
    "column name"
    immersiveDiscount
}

"unique or primary key constraints on table \"coupons\""
enum coupons_constraint {
    "unique or primary key constraint"
    coupons_pkey
}

"select columns of table \"coupons\""
enum coupons_select_column {
    "column name"
    id
    "column name"
    name
    "column name"
    stripeObject
}

"update columns of table \"coupons\""
enum coupons_update_column {
    "column name"
    id
    "column name"
    name
    "column name"
    stripeObject
}

"unique or primary key constraints on table \"course_ages\""
enum course_ages_constraint {
    "unique or primary key constraint"
    course_ages_pkey
}

"select columns of table \"course_ages\""
enum course_ages_select_column {
    "column name"
    ageId
    "column name"
    courseId
}

"update columns of table \"course_ages\""
enum course_ages_update_column {
    "column name"
    ageId
    "column name"
    courseId
}

"unique or primary key constraints on table \"course_grades\""
enum course_grades_constraint {
    "unique or primary key constraint"
    course_grades_pkey
}

"select columns of table \"course_grades\""
enum course_grades_select_column {
    "column name"
    courseId
    "column name"
    gradeId
}

"update columns of table \"course_grades\""
enum course_grades_update_column {
    "column name"
    courseId
    "column name"
    gradeId
}

"unique or primary key constraints on table \"course_materials\""
enum course_materials_constraint {
    "unique or primary key constraint"
    course_materials_pkey
}

"select columns of table \"course_materials\""
enum course_materials_select_column {
    "column name"
    courseId
    "column name"
    id
    "column name"
    kind
    "column name"
    link
    "column name"
    name
    "column name"
    unit
    "column name"
    unitId
    "column name"
    week
}

"update columns of table \"course_materials\""
enum course_materials_update_column {
    "column name"
    courseId
    "column name"
    id
    "column name"
    kind
    "column name"
    link
    "column name"
    name
    "column name"
    unit
    "column name"
    unitId
    "column name"
    week
}

"unique or primary key constraints on table \"course_types\""
enum course_types_constraint {
    "unique or primary key constraint"
    course_types_pkey
}

"select columns of table \"course_types\""
enum course_types_select_column {
    "column name"
    description
    "column name"
    sortOrder
    "column name"
    value
}

"update columns of table \"course_types\""
enum course_types_update_column {
    "column name"
    description
    "column name"
    sortOrder
    "column name"
    value
}

"unique or primary key constraints on table \"courses\""
enum courses_constraint {
    "unique or primary key constraint"
    courses_pkey
    "unique or primary key constraint"
    courses_slug_key
}

"select columns of table \"courses\""
enum courses_select_column {
    "column name"
    capacity
    "column name"
    description
    "column name"
    durationId
    "column name"
    featured
    "column name"
    frequencyType
    "column name"
    headline
    "column name"
    heroId
    "column name"
    id
    "column name"
    kind
    "column name"
    name
    "column name"
    price
    "column name"
    slug
    "column name"
    subjectId
    "column name"
    thumbId
    "column name"
    totalClasses
    "column name"
    videoLink
}

"update columns of table \"courses\""
enum courses_update_column {
    "column name"
    capacity
    "column name"
    description
    "column name"
    durationId
    "column name"
    featured
    "column name"
    frequencyType
    "column name"
    headline
    "column name"
    heroId
    "column name"
    id
    "column name"
    kind
    "column name"
    name
    "column name"
    price
    "column name"
    slug
    "column name"
    subjectId
    "column name"
    thumbId
    "column name"
    totalClasses
    "column name"
    videoLink
}

"unique or primary key constraints on table \"durations\""
enum durations_constraint {
    "unique or primary key constraint"
    durations_pkey
}

"select columns of table \"durations\""
enum durations_select_column {
    "column name"
    id
    "column name"
    minutes
    "column name"
    name
}

"update columns of table \"durations\""
enum durations_update_column {
    "column name"
    id
    "column name"
    minutes
    "column name"
    name
}

"select columns of table \"enrollment_info\""
enum enrollment_info_select_column {
    "column name"
    check
    "column name"
    comparison
    "column name"
    data
    "column name"
    entities
    "column name"
    entityids
    "column name"
    id
    "column name"
    organizationId
    "column name"
    studentId
    "column name"
    studentInternalId
}

"unique or primary key constraints on table \"enrollment_rules\""
enum enrollment_rules_constraint {
    "unique or primary key constraint"
    enrollment_rules_pkey
}

"select columns of table \"enrollment_rules\""
enum enrollment_rules_select_column {
    "column name"
    data
    "column name"
    id
    "column name"
    organizationId
    "column name"
    studentInternalId
}

"update columns of table \"enrollment_rules\""
enum enrollment_rules_update_column {
    "column name"
    data
    "column name"
    id
    "column name"
    organizationId
    "column name"
    studentInternalId
}

"unique or primary key constraints on table \"frequency_types\""
enum frequency_types_constraint {
    "unique or primary key constraint"
    frequency_types_pkey
}

enum frequency_types_enum {
    "Twice Weekly"
    twice_weekly
    "Every weekday (Mon - Fri)"
    weekdays
    "Weekly"
    weekly
}

"select columns of table \"frequency_types\""
enum frequency_types_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"frequency_types\""
enum frequency_types_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"gender_types\""
enum gender_types_constraint {
    "unique or primary key constraint"
    gender_pkey
}

enum gender_types_enum {
    "Female"
    female
    "Male"
    male
    "Not Listed"
    not_listed
    "Prefer Not to Say"
    prefer_not_to_say
}

enum gender_types_enum_ {
    female
    male
    not_listed
    prefer_not_to_say
}

"select columns of table \"gender_types\""
enum gender_types_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"gender_types\""
enum gender_types_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"grades\""
enum grades_constraint {
    "unique or primary key constraint"
    grades_pkey
}

"select columns of table \"grades\""
enum grades_select_column {
    "column name"
    id
    "column name"
    name
}

"update columns of table \"grades\""
enum grades_update_column {
    "column name"
    id
    "column name"
    name
}

"unique or primary key constraints on table \"instructor_enrollments\""
enum instructor_enrollments_constraint {
    "unique or primary key constraint"
    instructor_enrollments_pkey
}

"select columns of table \"instructor_enrollments\""
enum instructor_enrollments_select_column {
    "column name"
    canEnroll
    "column name"
    capacity
    "column name"
    courseId
    "column name"
    durationId
    "column name"
    endTime
    "column name"
    frequencyType
    "column name"
    id
    "column name"
    instructorId
    "column name"
    lookupId
    "column name"
    published
    "column name"
    seatsAvailable
    "column name"
    startTime
    "column name"
    totalSessions
    "column name"
    unitId
}

"update columns of table \"instructor_enrollments\""
enum instructor_enrollments_update_column {
    "column name"
    canEnroll
    "column name"
    capacity
    "column name"
    courseId
    "column name"
    durationId
    "column name"
    endTime
    "column name"
    frequencyType
    "column name"
    id
    "column name"
    instructorId
    "column name"
    lookupId
    "column name"
    published
    "column name"
    seatsAvailable
    "column name"
    startTime
    "column name"
    totalSessions
    "column name"
    unitId
}

"column ordering options"
enum order_by {
    "in the ascending order, nulls last"
    asc
    "in the ascending order, nulls first"
    asc_nulls_first
    "in the ascending order, nulls last"
    asc_nulls_last
    "in the descending order, nulls first"
    desc
    "in the descending order, nulls first"
    desc_nulls_first
    "in the descending order, nulls last"
    desc_nulls_last
}

"select columns of table \"parent_email_survey\""
enum parent_email_survey_select_column {
    "column name"
    cancelled
    "column name"
    course_id
    "column name"
    end_time
    "column name"
    id
    "column name"
    instructor_enrollment_id
    "column name"
    instructor_id
    "column name"
    session
    "column name"
    start_time
    "column name"
    student_id
    "column name"
    survey_sent
    "column name"
    total_sessions
    "column name"
    zoom_meeting_id
    "column name"
    zoom_occurrence_id
}

enum plan_internval_types {
    mo
    yr
}

"unique or primary key constraints on table \"product_prices\""
enum product_prices_constraint {
    "unique or primary key constraint"
    product_prices_pkey
}

"select columns of table \"product_prices\""
enum product_prices_select_column {
    "column name"
    active
    "column name"
    amount
    "column name"
    id
    "column name"
    interval
    "column name"
    productId
    "column name"
    stripeObject
}

"update columns of table \"product_prices\""
enum product_prices_update_column {
    "column name"
    active
    "column name"
    amount
    "column name"
    id
    "column name"
    interval
    "column name"
    productId
    "column name"
    stripeObject
}

"unique or primary key constraints on table \"products\""
enum products_constraint {
    "unique or primary key constraint"
    products_pkey
}

"select columns of table \"products\""
enum products_select_column {
    "column name"
    details
    "column name"
    id
    "column name"
    name
    "column name"
    stripeObject
    "column name"
    title
}

"update columns of table \"products\""
enum products_update_column {
    "column name"
    details
    "column name"
    id
    "column name"
    name
    "column name"
    stripeObject
    "column name"
    title
}

"select columns of table \"profile\""
enum profile_select_column {
    "column name"
    currentGradeId
    "column name"
    dob
    "column name"
    email
    "column name"
    firstName
    "column name"
    genderType
    "column name"
    id
    "column name"
    lastName
    "column name"
    organizationId
    "column name"
    parentId
    "column name"
    paying
    "column name"
    phone
    "column name"
    role
    "column name"
    searchName
}

"unique or primary key constraints on table \"promo_codes\""
enum promo_codes_constraint {
    "unique or primary key constraint"
    promo_codes_pkey
}

"select columns of table \"promo_codes\""
enum promo_codes_select_column {
    "column name"
    active
    "column name"
    code
    "column name"
    couponId
    "column name"
    id
    "column name"
    stripeObject
}

"update columns of table \"promo_codes\""
enum promo_codes_update_column {
    "column name"
    active
    "column name"
    code
    "column name"
    couponId
    "column name"
    id
    "column name"
    stripeObject
}

"unique or primary key constraints on table \"redirect_mapping\""
enum redirect_mapping_constraint {
    "unique or primary key constraint"
    redirect_mapping_pkey
}

"select columns of table \"redirect_mapping\""
enum redirect_mapping_select_column {
    "column name"
    code
    "column name"
    from_slug
    "column name"
    to_slug
}

"update columns of table \"redirect_mapping\""
enum redirect_mapping_update_column {
    "column name"
    code
    "column name"
    from_slug
    "column name"
    to_slug
}

"unique or primary key constraints on table \"schedules\""
enum schedules_constraint {
    "unique or primary key constraint"
    schedules_pkey
}

"select columns of table \"schedules\""
enum schedules_select_column {
    "column name"
    cancelled
    "column name"
    courseId
    "column name"
    endTime
    "column name"
    id
    "column name"
    instructorEnrollmentId
    "column name"
    instructorId
    "column name"
    session
    "column name"
    startTime
    "column name"
    survey_sent
    "column name"
    zoomMeetingId
    "column name"
    zoomOccurrenceId
}

"update columns of table \"schedules\""
enum schedules_update_column {
    "column name"
    cancelled
    "column name"
    courseId
    "column name"
    endTime
    "column name"
    id
    "column name"
    instructorEnrollmentId
    "column name"
    instructorId
    "column name"
    session
    "column name"
    startTime
    "column name"
    survey_sent
    "column name"
    zoomMeetingId
    "column name"
    zoomOccurrenceId
}

"unique or primary key constraints on table \"schools\""
enum schools_constraint {
    "unique or primary key constraint"
    schools_pkey
}

"unique or primary key constraints on table \"schools_domains\""
enum schools_domains_constraint {
    "unique or primary key constraint"
    schools_domains_pkey
}

"select columns of table \"schools_domains\""
enum schools_domains_select_column {
    "column name"
    domain
    "column name"
    id
    "column name"
    school_id
}

"update columns of table \"schools_domains\""
enum schools_domains_update_column {
    "column name"
    domain
    "column name"
    id
    "column name"
    school_id
}

"select columns of table \"schools\""
enum schools_select_column {
    "column name"
    banner
    "column name"
    config
    "column name"
    id
    "column name"
    isSchool
    "column name"
    loginUrl
    "column name"
    logoUrl
    "column name"
    name
    "column name"
    provider
    "column name"
    timeZone
}

"update columns of table \"schools\""
enum schools_update_column {
    "column name"
    banner
    "column name"
    config
    "column name"
    id
    "column name"
    isSchool
    "column name"
    loginUrl
    "column name"
    logoUrl
    "column name"
    name
    "column name"
    provider
    "column name"
    timeZone
}

enum sso_enum_types {
    clever
    gsuite
}

"unique or primary key constraints on table \"stripe_customers\""
enum stripe_customers_constraint {
    "unique or primary key constraint"
    stripe_customers_pkey
}

"select columns of table \"stripe_customers\""
enum stripe_customers_select_column {
    "column name"
    customerId
    "column name"
    profileId
}

"update columns of table \"stripe_customers\""
enum stripe_customers_update_column {
    "column name"
    customerId
    "column name"
    profileId
}

"unique or primary key constraints on table \"student_enrollments\""
enum student_enrollments_constraint {
    "unique or primary key constraint"
    student_enrollments_pkey
    "unique or primary key constraint"
    student_enrollments_student_id_instructor_enrollment_id_key
}

"select columns of table \"student_enrollments\""
enum student_enrollments_select_column {
    "column name"
    course_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    instructorEnrollmentId
    "column name"
    studentId
    "column name"
    withSubscription
}

"update columns of table \"student_enrollments\""
enum student_enrollments_update_column {
    "column name"
    course_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    instructorEnrollmentId
    "column name"
    studentId
    "column name"
    withSubscription
}

"unique or primary key constraints on table \"student_meeting_enrollments\""
enum student_meeting_enrollments_constraint {
    "unique or primary key constraint"
    student_meeting_enrollments_pkey
}

"select columns of table \"student_meeting_enrollments\""
enum student_meeting_enrollments_select_column {
    "column name"
    id
    "column name"
    instructorEnrollmentId
    "column name"
    joinUrl
    "column name"
    reminder_notified
    "column name"
    sms_reminder_notified
    "column name"
    studentEnrollmentId
    "column name"
    zoomMeetingId
    "column name"
    zoomRegistrantId
}

"update columns of table \"student_meeting_enrollments\""
enum student_meeting_enrollments_update_column {
    "column name"
    id
    "column name"
    instructorEnrollmentId
    "column name"
    joinUrl
    "column name"
    reminder_notified
    "column name"
    sms_reminder_notified
    "column name"
    studentEnrollmentId
    "column name"
    zoomMeetingId
    "column name"
    zoomRegistrantId
}

"select columns of table \"student_sms_surveys\""
enum student_sms_surveys_select_column {
    "column name"
    course_id
    "column name"
    email
    "column name"
    endTime
    "column name"
    fullName
    "column name"
    instructor_enrollment_id
    "column name"
    opt_in_sms
    "column name"
    phone
    "column name"
    startTime
    "column name"
    studentId
}

"unique or primary key constraints on table \"students\""
enum students_constraint {
    "unique or primary key constraint"
    students_internal_id_key
    "unique or primary key constraint"
    students_parent_id_first_name_last_name_dob_key
    "unique or primary key constraint"
    students_pkey
    "unique or primary key constraint"
    students_school_id_email_key
}

"select columns of table \"students\""
enum students_select_column {
    "column name"
    createdAt
    "column name"
    currentGradeId
    "column name"
    dob
    "column name"
    email
    "column name"
    firstName
    "column name"
    fullName
    "column name"
    genderType
    "column name"
    hasConfirmed
    "column name"
    id
    "column name"
    internalId
    "column name"
    lastName
    "column name"
    optInSms
    "column name"
    organizationId
    "column name"
    parent_id
    "column name"
    paying
    "column name"
    phone
}

"update columns of table \"students\""
enum students_update_column {
    "column name"
    createdAt
    "column name"
    currentGradeId
    "column name"
    dob
    "column name"
    email
    "column name"
    firstName
    "column name"
    fullName
    "column name"
    genderType
    "column name"
    hasConfirmed
    "column name"
    id
    "column name"
    internalId
    "column name"
    lastName
    "column name"
    optInSms
    "column name"
    organizationId
    "column name"
    parent_id
    "column name"
    paying
    "column name"
    phone
}

"unique or primary key constraints on table \"subjects\""
enum subjects_constraint {
    "unique or primary key constraint"
    subjects_pkey
}

"select columns of table \"subjects\""
enum subjects_select_column {
    "column name"
    description
    "column name"
    id
    "column name"
    name
}

"update columns of table \"subjects\""
enum subjects_update_column {
    "column name"
    description
    "column name"
    id
    "column name"
    name
}

"unique or primary key constraints on table \"subscription_status\""
enum subscription_status_constraint {
    "unique or primary key constraint"
    subscription_status_pkey
}

enum subscription_status_enum {
    "Subscription is active and up to date."
    active
    "Subscription has been cancelled."
    canceled
    "Initial payment attempt failed"
    incomplete
    "First invoice is not paid within 23 hours"
    incomplete_expired
    "Subscription is passed due."
    past_due
    "Currently in trial mode."
    trialing
    "Subscription is active but needs payment."
    unpaid
}

"select columns of table \"subscription_status\""
enum subscription_status_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"subscription_status\""
enum subscription_status_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"subscriptions\""
enum subscriptions_constraint {
    "unique or primary key constraint"
    subscriptions_pkey
    "unique or primary key constraint"
    subscriptions_student_id_stripe_subscription_id_parent_id_key
}

"select columns of table \"subscriptions\""
enum subscriptions_select_column {
    "column name"
    cancelAt
    "column name"
    createdAt
    "column name"
    id
    "column name"
    parentId
    "column name"
    productPriceId
    "column name"
    status
    "column name"
    stripeObject
    "column name"
    stripePendingInvoiceId
    "column name"
    stripeSubscriptionId
    "column name"
    stripeSubscriptionItemId
    "column name"
    studentId
    "column name"
    updatedAt
}

"update columns of table \"subscriptions\""
enum subscriptions_update_column {
    "column name"
    cancelAt
    "column name"
    createdAt
    "column name"
    id
    "column name"
    parentId
    "column name"
    productPriceId
    "column name"
    status
    "column name"
    stripeObject
    "column name"
    stripePendingInvoiceId
    "column name"
    stripeSubscriptionId
    "column name"
    stripeSubscriptionItemId
    "column name"
    studentId
    "column name"
    updatedAt
}

"unique or primary key constraints on table \"testimonials\""
enum testimonials_constraint {
    "unique or primary key constraint"
    testimonials_pkey
}

"select columns of table \"testimonials\""
enum testimonials_select_column {
    "column name"
    avatarId
    "column name"
    content
    "column name"
    courseId
    "column name"
    id
    "column name"
    name
    "column name"
    order
    "column name"
    role
}

"update columns of table \"testimonials\""
enum testimonials_update_column {
    "column name"
    avatarId
    "column name"
    content
    "column name"
    courseId
    "column name"
    id
    "column name"
    name
    "column name"
    order
    "column name"
    role
}

"unique or primary key constraints on table \"units\""
enum units_constraint {
    "unique or primary key constraint"
    units_pkey
}

"select columns of table \"units\""
enum units_select_column {
    "column name"
    capacity
    "column name"
    courseId
    "column name"
    description
    "column name"
    durationId
    "column name"
    frequencyType
    "column name"
    id
    "column name"
    name
    "column name"
    order
    "column name"
    price
    "column name"
    totalSessions
}

"update columns of table \"units\""
enum units_update_column {
    "column name"
    capacity
    "column name"
    courseId
    "column name"
    description
    "column name"
    durationId
    "column name"
    frequencyType
    "column name"
    id
    "column name"
    name
    "column name"
    order
    "column name"
    price
    "column name"
    totalSessions
}

"unique or primary key constraints on table \"uploads\""
enum uploads_constraint {
    "unique or primary key constraint"
    uploads_pkey
}

"select columns of table \"uploads\""
enum uploads_select_column {
    "column name"
    bucket
    "column name"
    created_at
    "column name"
    deletedAt
    "column name"
    id
    "column name"
    mediaType
    "column name"
    name
    "column name"
    size
    "column name"
    updated_at
}

"update columns of table \"uploads\""
enum uploads_update_column {
    "column name"
    bucket
    "column name"
    created_at
    "column name"
    deletedAt
    "column name"
    id
    "column name"
    mediaType
    "column name"
    name
    "column name"
    size
    "column name"
    updated_at
}

"unique or primary key constraints on table \"user_roles\""
enum user_roles_constraint {
    "unique or primary key constraint"
    user_roles_pkey
}

enum user_roles_enum_ {
    dashboard
    parent
    student
    teacher
}

"select columns of table \"user_roles\""
enum user_roles_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"user_roles\""
enum user_roles_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"users\""
enum users_constraint {
    "unique or primary key constraint"
    users_pkey
}

"select columns of table \"users\""
enum users_select_column {
    "column name"
    avatarId
    "column name"
    bio
    "column name"
    created_at
    "column name"
    email
    "column name"
    emailAlias
    "column name"
    firstName
    "column name"
    fullName
    "column name"
    hasConfirmed
    "column name"
    id
    "column name"
    lastName
    "column name"
    optInSms
    "column name"
    organizationId
    "column name"
    personal_zoom
    "column name"
    phone
    "column name"
    provisioning
    "column name"
    role
    "column name"
    thinkificId
    "column name"
    zoomId
}

"update columns of table \"users\""
enum users_update_column {
    "column name"
    avatarId
    "column name"
    bio
    "column name"
    created_at
    "column name"
    email
    "column name"
    emailAlias
    "column name"
    firstName
    "column name"
    fullName
    "column name"
    hasConfirmed
    "column name"
    id
    "column name"
    lastName
    "column name"
    optInSms
    "column name"
    organizationId
    "column name"
    personal_zoom
    "column name"
    phone
    "column name"
    provisioning
    "column name"
    role
    "column name"
    thinkificId
    "column name"
    zoomId
}

"select columns of table \"view_search_courses\""
enum view_search_courses_select_column {
    "column name"
    academic
    "column name"
    description
    "column name"
    durationId
    "column name"
    headline
    "column name"
    id
    "column name"
    name
    "column name"
    slug
    "column name"
    startTime
    "column name"
    subjectId
}

enum waitlist_timeslot_enum_types {
    early_afternoon
    early_evening
    early_morning
    late_afternoon
    late_morning
}

"unique or primary key constraints on table \"waitlists\""
enum waitlists_constraint {
    "unique or primary key constraint"
    waitlists_email_unit_id_key
    "unique or primary key constraint"
    waitlists_pkey
    "unique or primary key constraint"
    waitlists_profile_id_unit_id_key
}

"select columns of table \"waitlists\""
enum waitlists_select_column {
    "column name"
    email
    "column name"
    id
    "column name"
    profileId
    "column name"
    shouldNotify
    "column name"
    unitId
}

"update columns of table \"waitlists\""
enum waitlists_update_column {
    "column name"
    email
    "column name"
    id
    "column name"
    profileId
    "column name"
    shouldNotify
    "column name"
    unitId
}

enum weekday_enum_types {
    friday
    monday
    saturday
    sunday
    thursday
    tuesday
    wednesday
}

"unique or primary key constraints on table \"zoom_meetings\""
enum zoom_meetings_constraint {
    "unique or primary key constraint"
    zoom_meetings_pkey
}

"select columns of table \"zoom_meetings\""
enum zoom_meetings_select_column {
    "column name"
    courseId
    "column name"
    created_at
    "column name"
    endDate
    "column name"
    id
    "column name"
    instructor_enrollment_id
    "column name"
    internalZoomMeetingId
    "column name"
    password
    "column name"
    startDate
    "column name"
    startUrl
    "column name"
    updated_at
}

"update columns of table \"zoom_meetings\""
enum zoom_meetings_update_column {
    "column name"
    courseId
    "column name"
    created_at
    "column name"
    endDate
    "column name"
    id
    "column name"
    instructor_enrollment_id
    "column name"
    internalZoomMeetingId
    "column name"
    password
    "column name"
    startDate
    "column name"
    startUrl
    "column name"
    updated_at
}

"expression to compare columns of type Boolean. All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

input CreateSchoolInput {
    cert: String
    domain: String!
    name: String!
    sso: sso_enum_types!
    timeZone: String!
}

"expression to compare columns of type Int. All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

input NewCohortInput {
    capacity: Int
    instructorId: uuid
    occurrences: [NewCohortOccurrenceInput!]!
    timeZone: String!
    totalClasses: Int
    unitId: uuid!
}

input NewCohortOccurrenceInput {
    startDate: timestamptz!
    startTime: timestamptz!
}

input SignUpUserInput {
    avatarId: uuid
    bio: String
    dateOfBirth: String
    email: String!
    firstName: String!
    gender: gender_types_enum_
    grade: Int
    lastName: String!
    optInSms: Boolean
    password: String
    phone: String
    role: user_roles_enum_!
}

input SingupUserInput {
    avatarId: uuid
    bio: String
    email: String!
    firstName: String!
    gender: gender_types_enum_
    grade: Int
    lastName: String!
    role: user_roles_enum_!
}

input SingupUserRequest {
    avatarId: uuid
    bio: String
    email: String!
    firstName: String!
    gender: gender_types_enum_
    grade: Int
    lastName: String!
    role: user_roles_enum_!
}

"expression to compare columns of type String. All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    _ilike: String
    _in: [String!]
    _is_null: Boolean
    _like: String
    _lt: String
    _lte: String
    _neq: String
    _nilike: String
    _nin: [String!]
    _nlike: String
    _nsimilar: String
    _similar: String
}

input UpdateEntityOrderInput {
    entityId: StringOrInt!
    order: Int!
}

input UpdatePlanInput {
    details: String!
    id: String!
    name: String!
    priceId: String!
    title: String
}

input UpdateUnitOrderInput {
    order: Int!
    unitId: uuid!
}

input WaitlistSignupInput {
    email: String
    timeslots: [waitlist_timeslot_enum_types!]!
    unitId: String!
    weekdays: [weekday_enum_types!]!
}

"expression to compare columns of type _json. All fields are combined with logical 'AND'."
input _json_comparison_exp {
    _eq: _json
    _gt: _json
    _gte: _json
    _in: [_json!]
    _is_null: Boolean
    _lt: _json
    _lte: _json
    _neq: _json
    _nin: [_json!]
}

"order by aggregate values of table \"ages\""
input ages_aggregate_order_by {
    avg: ages_avg_order_by
    count: order_by
    max: ages_max_order_by
    min: ages_min_order_by
    stddev: ages_stddev_order_by
    stddev_pop: ages_stddev_pop_order_by
    stddev_samp: ages_stddev_samp_order_by
    sum: ages_sum_order_by
    var_pop: ages_var_pop_order_by
    var_samp: ages_var_samp_order_by
    variance: ages_variance_order_by
}

"input type for inserting array relation for remote table \"ages\""
input ages_arr_rel_insert_input {
    data: [ages_insert_input!]!
    on_conflict: ages_on_conflict
}

"order by avg() on columns of table \"ages\""
input ages_avg_order_by {
    id: order_by
    value: order_by
}

"Boolean expression to filter rows from the table \"ages\". All fields are combined with a logical 'AND'."
input ages_bool_exp {
    _and: [ages_bool_exp]
    _not: ages_bool_exp
    _or: [ages_bool_exp]
    id: Int_comparison_exp
    name: String_comparison_exp
    value: numeric_comparison_exp
}

"input type for incrementing integer column in table \"ages\""
input ages_inc_input {
    id: Int
    value: numeric
}

"input type for inserting data into table \"ages\""
input ages_insert_input {
    id: Int
    name: String
    value: numeric
}

"order by max() on columns of table \"ages\""
input ages_max_order_by {
    id: order_by
    name: order_by
    value: order_by
}

"order by min() on columns of table \"ages\""
input ages_min_order_by {
    id: order_by
    name: order_by
    value: order_by
}

"input type for inserting object relation for remote table \"ages\""
input ages_obj_rel_insert_input {
    data: ages_insert_input!
    on_conflict: ages_on_conflict
}

"on conflict condition type for table \"ages\""
input ages_on_conflict {
    constraint: ages_constraint!
    update_columns: [ages_update_column!]!
    where: ages_bool_exp
}

"ordering options when selecting data from \"ages\""
input ages_order_by {
    id: order_by
    name: order_by
    value: order_by
}

"primary key columns input for table: \"ages\""
input ages_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"ages\""
input ages_set_input {
    id: Int
    name: String
    value: numeric
}

"order by stddev() on columns of table \"ages\""
input ages_stddev_order_by {
    id: order_by
    value: order_by
}

"order by stddev_pop() on columns of table \"ages\""
input ages_stddev_pop_order_by {
    id: order_by
    value: order_by
}

"order by stddev_samp() on columns of table \"ages\""
input ages_stddev_samp_order_by {
    id: order_by
    value: order_by
}

"order by sum() on columns of table \"ages\""
input ages_sum_order_by {
    id: order_by
    value: order_by
}

"order by var_pop() on columns of table \"ages\""
input ages_var_pop_order_by {
    id: order_by
    value: order_by
}

"order by var_samp() on columns of table \"ages\""
input ages_var_samp_order_by {
    id: order_by
    value: order_by
}

"order by variance() on columns of table \"ages\""
input ages_variance_order_by {
    id: order_by
    value: order_by
}

"order by aggregate values of table \"application_config\""
input application_config_aggregate_order_by {
    avg: application_config_avg_order_by
    count: order_by
    max: application_config_max_order_by
    min: application_config_min_order_by
    stddev: application_config_stddev_order_by
    stddev_pop: application_config_stddev_pop_order_by
    stddev_samp: application_config_stddev_samp_order_by
    sum: application_config_sum_order_by
    var_pop: application_config_var_pop_order_by
    var_samp: application_config_var_samp_order_by
    variance: application_config_variance_order_by
}

"input type for inserting array relation for remote table \"application_config\""
input application_config_arr_rel_insert_input {
    data: [application_config_insert_input!]!
    on_conflict: application_config_on_conflict
}

"order by avg() on columns of table \"application_config\""
input application_config_avg_order_by {
    immersiveDiscount: order_by
}

"Boolean expression to filter rows from the table \"application_config\". All fields are combined with a logical 'AND'."
input application_config_bool_exp {
    _and: [application_config_bool_exp]
    _not: application_config_bool_exp
    _or: [application_config_bool_exp]
    id: uuid_comparison_exp
    immersiveDiscount: Int_comparison_exp
}

"input type for incrementing integer column in table \"application_config\""
input application_config_inc_input {
    immersiveDiscount: Int
}

"input type for inserting data into table \"application_config\""
input application_config_insert_input {
    id: uuid
    immersiveDiscount: Int
}

"order by max() on columns of table \"application_config\""
input application_config_max_order_by {
    id: order_by
    immersiveDiscount: order_by
}

"order by min() on columns of table \"application_config\""
input application_config_min_order_by {
    id: order_by
    immersiveDiscount: order_by
}

"input type for inserting object relation for remote table \"application_config\""
input application_config_obj_rel_insert_input {
    data: application_config_insert_input!
    on_conflict: application_config_on_conflict
}

"on conflict condition type for table \"application_config\""
input application_config_on_conflict {
    constraint: application_config_constraint!
    update_columns: [application_config_update_column!]!
    where: application_config_bool_exp
}

"ordering options when selecting data from \"application_config\""
input application_config_order_by {
    id: order_by
    immersiveDiscount: order_by
}

"primary key columns input for table: \"application_config\""
input application_config_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"application_config\""
input application_config_set_input {
    id: uuid
    immersiveDiscount: Int
}

"order by stddev() on columns of table \"application_config\""
input application_config_stddev_order_by {
    immersiveDiscount: order_by
}

"order by stddev_pop() on columns of table \"application_config\""
input application_config_stddev_pop_order_by {
    immersiveDiscount: order_by
}

"order by stddev_samp() on columns of table \"application_config\""
input application_config_stddev_samp_order_by {
    immersiveDiscount: order_by
}

"order by sum() on columns of table \"application_config\""
input application_config_sum_order_by {
    immersiveDiscount: order_by
}

"order by var_pop() on columns of table \"application_config\""
input application_config_var_pop_order_by {
    immersiveDiscount: order_by
}

"order by var_samp() on columns of table \"application_config\""
input application_config_var_samp_order_by {
    immersiveDiscount: order_by
}

"order by variance() on columns of table \"application_config\""
input application_config_variance_order_by {
    immersiveDiscount: order_by
}

"expression to compare columns of type citext. All fields are combined with logical 'AND'."
input citext_comparison_exp {
    _eq: citext
    _gt: citext
    _gte: citext
    _ilike: String
    _in: [citext!]
    _is_null: Boolean
    _like: String
    _lt: citext
    _lte: citext
    _neq: citext
    _nilike: String
    _nin: [citext!]
    _nlike: String
    _nsimilar: String
    _similar: String
}

"order by aggregate values of table \"coupons\""
input coupons_aggregate_order_by {
    count: order_by
    max: coupons_max_order_by
    min: coupons_min_order_by
}

"input type for inserting array relation for remote table \"coupons\""
input coupons_arr_rel_insert_input {
    data: [coupons_insert_input!]!
    on_conflict: coupons_on_conflict
}

"Boolean expression to filter rows from the table \"coupons\". All fields are combined with a logical 'AND'."
input coupons_bool_exp {
    _and: [coupons_bool_exp]
    _not: coupons_bool_exp
    _or: [coupons_bool_exp]
    id: String_comparison_exp
    name: String_comparison_exp
    stripeObject: json_comparison_exp
}

"input type for inserting data into table \"coupons\""
input coupons_insert_input {
    id: String
    name: String
    stripeObject: json
}

"order by max() on columns of table \"coupons\""
input coupons_max_order_by {
    id: order_by
    name: order_by
}

"order by min() on columns of table \"coupons\""
input coupons_min_order_by {
    id: order_by
    name: order_by
}

"input type for inserting object relation for remote table \"coupons\""
input coupons_obj_rel_insert_input {
    data: coupons_insert_input!
    on_conflict: coupons_on_conflict
}

"on conflict condition type for table \"coupons\""
input coupons_on_conflict {
    constraint: coupons_constraint!
    update_columns: [coupons_update_column!]!
    where: coupons_bool_exp
}

"ordering options when selecting data from \"coupons\""
input coupons_order_by {
    id: order_by
    name: order_by
    stripeObject: order_by
}

"primary key columns input for table: \"coupons\""
input coupons_pk_columns_input {
    id: String!
}

"input type for updating data in table \"coupons\""
input coupons_set_input {
    id: String
    name: String
    stripeObject: json
}

"order by aggregate values of table \"course_ages\""
input course_ages_aggregate_order_by {
    avg: course_ages_avg_order_by
    count: order_by
    max: course_ages_max_order_by
    min: course_ages_min_order_by
    stddev: course_ages_stddev_order_by
    stddev_pop: course_ages_stddev_pop_order_by
    stddev_samp: course_ages_stddev_samp_order_by
    sum: course_ages_sum_order_by
    var_pop: course_ages_var_pop_order_by
    var_samp: course_ages_var_samp_order_by
    variance: course_ages_variance_order_by
}

"input type for inserting array relation for remote table \"course_ages\""
input course_ages_arr_rel_insert_input {
    data: [course_ages_insert_input!]!
    on_conflict: course_ages_on_conflict
}

"order by avg() on columns of table \"course_ages\""
input course_ages_avg_order_by {
    ageId: order_by
}

"Boolean expression to filter rows from the table \"course_ages\". All fields are combined with a logical 'AND'."
input course_ages_bool_exp {
    _and: [course_ages_bool_exp]
    _not: course_ages_bool_exp
    _or: [course_ages_bool_exp]
    age: ages_bool_exp
    ageId: Int_comparison_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
}

"input type for incrementing integer column in table \"course_ages\""
input course_ages_inc_input {
    ageId: Int
}

"input type for inserting data into table \"course_ages\""
input course_ages_insert_input {
    age: ages_obj_rel_insert_input
    ageId: Int
    course: courses_obj_rel_insert_input
    courseId: uuid
}

"order by max() on columns of table \"course_ages\""
input course_ages_max_order_by {
    ageId: order_by
    courseId: order_by
}

"order by min() on columns of table \"course_ages\""
input course_ages_min_order_by {
    ageId: order_by
    courseId: order_by
}

"input type for inserting object relation for remote table \"course_ages\""
input course_ages_obj_rel_insert_input {
    data: course_ages_insert_input!
    on_conflict: course_ages_on_conflict
}

"on conflict condition type for table \"course_ages\""
input course_ages_on_conflict {
    constraint: course_ages_constraint!
    update_columns: [course_ages_update_column!]!
    where: course_ages_bool_exp
}

"ordering options when selecting data from \"course_ages\""
input course_ages_order_by {
    age: ages_order_by
    ageId: order_by
    course: courses_order_by
    courseId: order_by
}

"primary key columns input for table: \"course_ages\""
input course_ages_pk_columns_input {
    ageId: Int!
    courseId: uuid!
}

"input type for updating data in table \"course_ages\""
input course_ages_set_input {
    ageId: Int
    courseId: uuid
}

"order by stddev() on columns of table \"course_ages\""
input course_ages_stddev_order_by {
    ageId: order_by
}

"order by stddev_pop() on columns of table \"course_ages\""
input course_ages_stddev_pop_order_by {
    ageId: order_by
}

"order by stddev_samp() on columns of table \"course_ages\""
input course_ages_stddev_samp_order_by {
    ageId: order_by
}

"order by sum() on columns of table \"course_ages\""
input course_ages_sum_order_by {
    ageId: order_by
}

"order by var_pop() on columns of table \"course_ages\""
input course_ages_var_pop_order_by {
    ageId: order_by
}

"order by var_samp() on columns of table \"course_ages\""
input course_ages_var_samp_order_by {
    ageId: order_by
}

"order by variance() on columns of table \"course_ages\""
input course_ages_variance_order_by {
    ageId: order_by
}

"order by aggregate values of table \"course_grades\""
input course_grades_aggregate_order_by {
    avg: course_grades_avg_order_by
    count: order_by
    max: course_grades_max_order_by
    min: course_grades_min_order_by
    stddev: course_grades_stddev_order_by
    stddev_pop: course_grades_stddev_pop_order_by
    stddev_samp: course_grades_stddev_samp_order_by
    sum: course_grades_sum_order_by
    var_pop: course_grades_var_pop_order_by
    var_samp: course_grades_var_samp_order_by
    variance: course_grades_variance_order_by
}

"input type for inserting array relation for remote table \"course_grades\""
input course_grades_arr_rel_insert_input {
    data: [course_grades_insert_input!]!
    on_conflict: course_grades_on_conflict
}

"order by avg() on columns of table \"course_grades\""
input course_grades_avg_order_by {
    gradeId: order_by
}

"Boolean expression to filter rows from the table \"course_grades\". All fields are combined with a logical 'AND'."
input course_grades_bool_exp {
    _and: [course_grades_bool_exp]
    _not: course_grades_bool_exp
    _or: [course_grades_bool_exp]
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    grade: grades_bool_exp
    gradeId: Int_comparison_exp
}

"input type for incrementing integer column in table \"course_grades\""
input course_grades_inc_input {
    gradeId: Int
}

"input type for inserting data into table \"course_grades\""
input course_grades_insert_input {
    course: courses_obj_rel_insert_input
    courseId: uuid
    grade: grades_obj_rel_insert_input
    gradeId: Int
}

"order by max() on columns of table \"course_grades\""
input course_grades_max_order_by {
    courseId: order_by
    gradeId: order_by
}

"order by min() on columns of table \"course_grades\""
input course_grades_min_order_by {
    courseId: order_by
    gradeId: order_by
}

"input type for inserting object relation for remote table \"course_grades\""
input course_grades_obj_rel_insert_input {
    data: course_grades_insert_input!
    on_conflict: course_grades_on_conflict
}

"on conflict condition type for table \"course_grades\""
input course_grades_on_conflict {
    constraint: course_grades_constraint!
    update_columns: [course_grades_update_column!]!
    where: course_grades_bool_exp
}

"ordering options when selecting data from \"course_grades\""
input course_grades_order_by {
    course: courses_order_by
    courseId: order_by
    grade: grades_order_by
    gradeId: order_by
}

"primary key columns input for table: \"course_grades\""
input course_grades_pk_columns_input {
    courseId: uuid!
    gradeId: Int!
}

"input type for updating data in table \"course_grades\""
input course_grades_set_input {
    courseId: uuid
    gradeId: Int
}

"order by stddev() on columns of table \"course_grades\""
input course_grades_stddev_order_by {
    gradeId: order_by
}

"order by stddev_pop() on columns of table \"course_grades\""
input course_grades_stddev_pop_order_by {
    gradeId: order_by
}

"order by stddev_samp() on columns of table \"course_grades\""
input course_grades_stddev_samp_order_by {
    gradeId: order_by
}

"order by sum() on columns of table \"course_grades\""
input course_grades_sum_order_by {
    gradeId: order_by
}

"order by var_pop() on columns of table \"course_grades\""
input course_grades_var_pop_order_by {
    gradeId: order_by
}

"order by var_samp() on columns of table \"course_grades\""
input course_grades_var_samp_order_by {
    gradeId: order_by
}

"order by variance() on columns of table \"course_grades\""
input course_grades_variance_order_by {
    gradeId: order_by
}

"order by aggregate values of table \"course_materials\""
input course_materials_aggregate_order_by {
    avg: course_materials_avg_order_by
    count: order_by
    max: course_materials_max_order_by
    min: course_materials_min_order_by
    stddev: course_materials_stddev_order_by
    stddev_pop: course_materials_stddev_pop_order_by
    stddev_samp: course_materials_stddev_samp_order_by
    sum: course_materials_sum_order_by
    var_pop: course_materials_var_pop_order_by
    var_samp: course_materials_var_samp_order_by
    variance: course_materials_variance_order_by
}

"input type for inserting array relation for remote table \"course_materials\""
input course_materials_arr_rel_insert_input {
    data: [course_materials_insert_input!]!
    on_conflict: course_materials_on_conflict
}

"order by avg() on columns of table \"course_materials\""
input course_materials_avg_order_by {
    id: order_by
    unit: order_by
    week: order_by
}

"Boolean expression to filter rows from the table \"course_materials\". All fields are combined with a logical 'AND'."
input course_materials_bool_exp {
    _and: [course_materials_bool_exp]
    _not: course_materials_bool_exp
    _or: [course_materials_bool_exp]
    courseId: uuid_comparison_exp
    id: Int_comparison_exp
    kind: String_comparison_exp
    link: String_comparison_exp
    name: String_comparison_exp
    unit: Int_comparison_exp
    unitId: uuid_comparison_exp
    week: Int_comparison_exp
}

"input type for incrementing integer column in table \"course_materials\""
input course_materials_inc_input {
    id: Int
    unit: Int
    week: Int
}

"input type for inserting data into table \"course_materials\""
input course_materials_insert_input {
    courseId: uuid
    id: Int
    kind: String
    link: String
    name: String
    unit: Int
    unitId: uuid
    week: Int
}

"order by max() on columns of table \"course_materials\""
input course_materials_max_order_by {
    courseId: order_by
    id: order_by
    kind: order_by
    link: order_by
    name: order_by
    unit: order_by
    unitId: order_by
    week: order_by
}

"order by min() on columns of table \"course_materials\""
input course_materials_min_order_by {
    courseId: order_by
    id: order_by
    kind: order_by
    link: order_by
    name: order_by
    unit: order_by
    unitId: order_by
    week: order_by
}

"input type for inserting object relation for remote table \"course_materials\""
input course_materials_obj_rel_insert_input {
    data: course_materials_insert_input!
    on_conflict: course_materials_on_conflict
}

"on conflict condition type for table \"course_materials\""
input course_materials_on_conflict {
    constraint: course_materials_constraint!
    update_columns: [course_materials_update_column!]!
    where: course_materials_bool_exp
}

"ordering options when selecting data from \"course_materials\""
input course_materials_order_by {
    courseId: order_by
    id: order_by
    kind: order_by
    link: order_by
    name: order_by
    unit: order_by
    unitId: order_by
    week: order_by
}

"primary key columns input for table: \"course_materials\""
input course_materials_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"course_materials\""
input course_materials_set_input {
    courseId: uuid
    id: Int
    kind: String
    link: String
    name: String
    unit: Int
    unitId: uuid
    week: Int
}

"order by stddev() on columns of table \"course_materials\""
input course_materials_stddev_order_by {
    id: order_by
    unit: order_by
    week: order_by
}

"order by stddev_pop() on columns of table \"course_materials\""
input course_materials_stddev_pop_order_by {
    id: order_by
    unit: order_by
    week: order_by
}

"order by stddev_samp() on columns of table \"course_materials\""
input course_materials_stddev_samp_order_by {
    id: order_by
    unit: order_by
    week: order_by
}

"order by sum() on columns of table \"course_materials\""
input course_materials_sum_order_by {
    id: order_by
    unit: order_by
    week: order_by
}

"order by var_pop() on columns of table \"course_materials\""
input course_materials_var_pop_order_by {
    id: order_by
    unit: order_by
    week: order_by
}

"order by var_samp() on columns of table \"course_materials\""
input course_materials_var_samp_order_by {
    id: order_by
    unit: order_by
    week: order_by
}

"order by variance() on columns of table \"course_materials\""
input course_materials_variance_order_by {
    id: order_by
    unit: order_by
    week: order_by
}

"order by aggregate values of table \"course_types\""
input course_types_aggregate_order_by {
    avg: course_types_avg_order_by
    count: order_by
    max: course_types_max_order_by
    min: course_types_min_order_by
    stddev: course_types_stddev_order_by
    stddev_pop: course_types_stddev_pop_order_by
    stddev_samp: course_types_stddev_samp_order_by
    sum: course_types_sum_order_by
    var_pop: course_types_var_pop_order_by
    var_samp: course_types_var_samp_order_by
    variance: course_types_variance_order_by
}

"input type for inserting array relation for remote table \"course_types\""
input course_types_arr_rel_insert_input {
    data: [course_types_insert_input!]!
    on_conflict: course_types_on_conflict
}

"order by avg() on columns of table \"course_types\""
input course_types_avg_order_by {
    sortOrder: order_by
}

"Boolean expression to filter rows from the table \"course_types\". All fields are combined with a logical 'AND'."
input course_types_bool_exp {
    _and: [course_types_bool_exp]
    _not: course_types_bool_exp
    _or: [course_types_bool_exp]
    description: String_comparison_exp
    sortOrder: Int_comparison_exp
    value: String_comparison_exp
}

"input type for incrementing integer column in table \"course_types\""
input course_types_inc_input {
    sortOrder: Int
}

"input type for inserting data into table \"course_types\""
input course_types_insert_input {
    description: String
    sortOrder: Int
    value: String
}

"order by max() on columns of table \"course_types\""
input course_types_max_order_by {
    description: order_by
    sortOrder: order_by
    value: order_by
}

"order by min() on columns of table \"course_types\""
input course_types_min_order_by {
    description: order_by
    sortOrder: order_by
    value: order_by
}

"input type for inserting object relation for remote table \"course_types\""
input course_types_obj_rel_insert_input {
    data: course_types_insert_input!
    on_conflict: course_types_on_conflict
}

"on conflict condition type for table \"course_types\""
input course_types_on_conflict {
    constraint: course_types_constraint!
    update_columns: [course_types_update_column!]!
    where: course_types_bool_exp
}

"ordering options when selecting data from \"course_types\""
input course_types_order_by {
    description: order_by
    sortOrder: order_by
    value: order_by
}

"primary key columns input for table: \"course_types\""
input course_types_pk_columns_input {
    value: String!
}

"input type for updating data in table \"course_types\""
input course_types_set_input {
    description: String
    sortOrder: Int
    value: String
}

"order by stddev() on columns of table \"course_types\""
input course_types_stddev_order_by {
    sortOrder: order_by
}

"order by stddev_pop() on columns of table \"course_types\""
input course_types_stddev_pop_order_by {
    sortOrder: order_by
}

"order by stddev_samp() on columns of table \"course_types\""
input course_types_stddev_samp_order_by {
    sortOrder: order_by
}

"order by sum() on columns of table \"course_types\""
input course_types_sum_order_by {
    sortOrder: order_by
}

"order by var_pop() on columns of table \"course_types\""
input course_types_var_pop_order_by {
    sortOrder: order_by
}

"order by var_samp() on columns of table \"course_types\""
input course_types_var_samp_order_by {
    sortOrder: order_by
}

"order by variance() on columns of table \"course_types\""
input course_types_variance_order_by {
    sortOrder: order_by
}

"order by aggregate values of table \"courses\""
input courses_aggregate_order_by {
    avg: courses_avg_order_by
    count: order_by
    max: courses_max_order_by
    min: courses_min_order_by
    stddev: courses_stddev_order_by
    stddev_pop: courses_stddev_pop_order_by
    stddev_samp: courses_stddev_samp_order_by
    sum: courses_sum_order_by
    var_pop: courses_var_pop_order_by
    var_samp: courses_var_samp_order_by
    variance: courses_variance_order_by
}

"input type for inserting array relation for remote table \"courses\""
input courses_arr_rel_insert_input {
    data: [courses_insert_input!]!
    on_conflict: courses_on_conflict
}

"order by avg() on columns of table \"courses\""
input courses_avg_order_by {
    capacity: order_by
    durationId: order_by
    price: order_by
    totalClasses: order_by
}

"Boolean expression to filter rows from the table \"courses\". All fields are combined with a logical 'AND'."
input courses_bool_exp {
    _and: [courses_bool_exp]
    _not: courses_bool_exp
    _or: [courses_bool_exp]
    ages: course_ages_bool_exp
    capacity: Int_comparison_exp
    cohorts: instructor_enrollments_bool_exp
    courseType: course_types_bool_exp
    description: String_comparison_exp
    duration: durations_bool_exp
    durationId: Int_comparison_exp
    enrollments: student_enrollments_bool_exp
    featured: Boolean_comparison_exp
    frequency: frequency_types_bool_exp
    frequencyType: frequency_types_enum_comparison_exp
    grades: course_grades_bool_exp
    headline: String_comparison_exp
    hero: uploads_bool_exp
    heroId: uuid_comparison_exp
    id: uuid_comparison_exp
    kind: String_comparison_exp
    name: String_comparison_exp
    price: numeric_comparison_exp
    schedules: schedules_bool_exp
    slug: String_comparison_exp
    subject: subjects_bool_exp
    subjectId: uuid_comparison_exp
    testimonials: testimonials_bool_exp
    thumb: uploads_bool_exp
    thumbId: uuid_comparison_exp
    totalClasses: Int_comparison_exp
    units: units_bool_exp
    videoLink: String_comparison_exp
    zoomMeetings: zoom_meetings_bool_exp
}

"input type for incrementing integer column in table \"courses\""
input courses_inc_input {
    capacity: Int
    durationId: Int
    price: numeric
    totalClasses: Int
}

"input type for inserting data into table \"courses\""
input courses_insert_input {
    ages: course_ages_arr_rel_insert_input
    capacity: Int
    cohorts: instructor_enrollments_arr_rel_insert_input
    courseType: course_types_obj_rel_insert_input
    description: String
    duration: durations_obj_rel_insert_input
    durationId: Int
    enrollments: student_enrollments_arr_rel_insert_input
    featured: Boolean
    frequency: frequency_types_obj_rel_insert_input
    frequencyType: frequency_types_enum
    grades: course_grades_arr_rel_insert_input
    headline: String
    hero: uploads_obj_rel_insert_input
    heroId: uuid
    id: uuid
    kind: String
    name: String
    price: numeric
    schedules: schedules_arr_rel_insert_input
    slug: String
    subject: subjects_obj_rel_insert_input
    subjectId: uuid
    testimonials: testimonials_arr_rel_insert_input
    thumb: uploads_obj_rel_insert_input
    thumbId: uuid
    totalClasses: Int
    units: units_arr_rel_insert_input
    videoLink: String
    zoomMeetings: zoom_meetings_arr_rel_insert_input
}

"order by max() on columns of table \"courses\""
input courses_max_order_by {
    capacity: order_by
    description: order_by
    durationId: order_by
    headline: order_by
    heroId: order_by
    id: order_by
    kind: order_by
    name: order_by
    price: order_by
    slug: order_by
    subjectId: order_by
    thumbId: order_by
    totalClasses: order_by
    videoLink: order_by
}

"order by min() on columns of table \"courses\""
input courses_min_order_by {
    capacity: order_by
    description: order_by
    durationId: order_by
    headline: order_by
    heroId: order_by
    id: order_by
    kind: order_by
    name: order_by
    price: order_by
    slug: order_by
    subjectId: order_by
    thumbId: order_by
    totalClasses: order_by
    videoLink: order_by
}

"input type for inserting object relation for remote table \"courses\""
input courses_obj_rel_insert_input {
    data: courses_insert_input!
    on_conflict: courses_on_conflict
}

"on conflict condition type for table \"courses\""
input courses_on_conflict {
    constraint: courses_constraint!
    update_columns: [courses_update_column!]!
    where: courses_bool_exp
}

"ordering options when selecting data from \"courses\""
input courses_order_by {
    ages_aggregate: course_ages_aggregate_order_by
    capacity: order_by
    cohorts_aggregate: instructor_enrollments_aggregate_order_by
    courseType: course_types_order_by
    description: order_by
    duration: durations_order_by
    durationId: order_by
    enrollments_aggregate: student_enrollments_aggregate_order_by
    featured: order_by
    frequency: frequency_types_order_by
    frequencyType: order_by
    grades_aggregate: course_grades_aggregate_order_by
    headline: order_by
    hero: uploads_order_by
    heroId: order_by
    id: order_by
    kind: order_by
    name: order_by
    price: order_by
    schedules_aggregate: schedules_aggregate_order_by
    slug: order_by
    subject: subjects_order_by
    subjectId: order_by
    testimonials_aggregate: testimonials_aggregate_order_by
    thumb: uploads_order_by
    thumbId: order_by
    totalClasses: order_by
    units_aggregate: units_aggregate_order_by
    videoLink: order_by
    zoomMeetings_aggregate: zoom_meetings_aggregate_order_by
}

"primary key columns input for table: \"courses\""
input courses_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"courses\""
input courses_set_input {
    capacity: Int
    description: String
    durationId: Int
    featured: Boolean
    frequencyType: frequency_types_enum
    headline: String
    heroId: uuid
    id: uuid
    kind: String
    name: String
    price: numeric
    slug: String
    subjectId: uuid
    thumbId: uuid
    totalClasses: Int
    videoLink: String
}

"order by stddev() on columns of table \"courses\""
input courses_stddev_order_by {
    capacity: order_by
    durationId: order_by
    price: order_by
    totalClasses: order_by
}

"order by stddev_pop() on columns of table \"courses\""
input courses_stddev_pop_order_by {
    capacity: order_by
    durationId: order_by
    price: order_by
    totalClasses: order_by
}

"order by stddev_samp() on columns of table \"courses\""
input courses_stddev_samp_order_by {
    capacity: order_by
    durationId: order_by
    price: order_by
    totalClasses: order_by
}

"order by sum() on columns of table \"courses\""
input courses_sum_order_by {
    capacity: order_by
    durationId: order_by
    price: order_by
    totalClasses: order_by
}

"order by var_pop() on columns of table \"courses\""
input courses_var_pop_order_by {
    capacity: order_by
    durationId: order_by
    price: order_by
    totalClasses: order_by
}

"order by var_samp() on columns of table \"courses\""
input courses_var_samp_order_by {
    capacity: order_by
    durationId: order_by
    price: order_by
    totalClasses: order_by
}

"order by variance() on columns of table \"courses\""
input courses_variance_order_by {
    capacity: order_by
    durationId: order_by
    price: order_by
    totalClasses: order_by
}

"expression to compare columns of type date. All fields are combined with logical 'AND'."
input date_comparison_exp {
    _eq: date
    _gt: date
    _gte: date
    _in: [date!]
    _is_null: Boolean
    _lt: date
    _lte: date
    _neq: date
    _nin: [date!]
}

"order by aggregate values of table \"durations\""
input durations_aggregate_order_by {
    avg: durations_avg_order_by
    count: order_by
    max: durations_max_order_by
    min: durations_min_order_by
    stddev: durations_stddev_order_by
    stddev_pop: durations_stddev_pop_order_by
    stddev_samp: durations_stddev_samp_order_by
    sum: durations_sum_order_by
    var_pop: durations_var_pop_order_by
    var_samp: durations_var_samp_order_by
    variance: durations_variance_order_by
}

"input type for inserting array relation for remote table \"durations\""
input durations_arr_rel_insert_input {
    data: [durations_insert_input!]!
    on_conflict: durations_on_conflict
}

"order by avg() on columns of table \"durations\""
input durations_avg_order_by {
    id: order_by
    minutes: order_by
}

"Boolean expression to filter rows from the table \"durations\". All fields are combined with a logical 'AND'."
input durations_bool_exp {
    _and: [durations_bool_exp]
    _not: durations_bool_exp
    _or: [durations_bool_exp]
    id: Int_comparison_exp
    minutes: Int_comparison_exp
    name: String_comparison_exp
}

"input type for incrementing integer column in table \"durations\""
input durations_inc_input {
    id: Int
    minutes: Int
}

"input type for inserting data into table \"durations\""
input durations_insert_input {
    id: Int
    minutes: Int
    name: String
}

"order by max() on columns of table \"durations\""
input durations_max_order_by {
    id: order_by
    minutes: order_by
    name: order_by
}

"order by min() on columns of table \"durations\""
input durations_min_order_by {
    id: order_by
    minutes: order_by
    name: order_by
}

"input type for inserting object relation for remote table \"durations\""
input durations_obj_rel_insert_input {
    data: durations_insert_input!
    on_conflict: durations_on_conflict
}

"on conflict condition type for table \"durations\""
input durations_on_conflict {
    constraint: durations_constraint!
    update_columns: [durations_update_column!]!
    where: durations_bool_exp
}

"ordering options when selecting data from \"durations\""
input durations_order_by {
    id: order_by
    minutes: order_by
    name: order_by
}

"primary key columns input for table: \"durations\""
input durations_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"durations\""
input durations_set_input {
    id: Int
    minutes: Int
    name: String
}

"order by stddev() on columns of table \"durations\""
input durations_stddev_order_by {
    id: order_by
    minutes: order_by
}

"order by stddev_pop() on columns of table \"durations\""
input durations_stddev_pop_order_by {
    id: order_by
    minutes: order_by
}

"order by stddev_samp() on columns of table \"durations\""
input durations_stddev_samp_order_by {
    id: order_by
    minutes: order_by
}

"order by sum() on columns of table \"durations\""
input durations_sum_order_by {
    id: order_by
    minutes: order_by
}

"order by var_pop() on columns of table \"durations\""
input durations_var_pop_order_by {
    id: order_by
    minutes: order_by
}

"order by var_samp() on columns of table \"durations\""
input durations_var_samp_order_by {
    id: order_by
    minutes: order_by
}

"order by variance() on columns of table \"durations\""
input durations_variance_order_by {
    id: order_by
    minutes: order_by
}

"order by aggregate values of table \"enrollment_info\""
input enrollment_info_aggregate_order_by {
    avg: enrollment_info_avg_order_by
    count: order_by
    max: enrollment_info_max_order_by
    min: enrollment_info_min_order_by
    stddev: enrollment_info_stddev_order_by
    stddev_pop: enrollment_info_stddev_pop_order_by
    stddev_samp: enrollment_info_stddev_samp_order_by
    sum: enrollment_info_sum_order_by
    var_pop: enrollment_info_var_pop_order_by
    var_samp: enrollment_info_var_samp_order_by
    variance: enrollment_info_variance_order_by
}

"input type for inserting array relation for remote table \"enrollment_info\""
input enrollment_info_arr_rel_insert_input {
    data: [enrollment_info_insert_input!]!
}

"order by avg() on columns of table \"enrollment_info\""
input enrollment_info_avg_order_by {
    id: order_by
}

"Boolean expression to filter rows from the table \"enrollment_info\". All fields are combined with a logical 'AND'."
input enrollment_info_bool_exp {
    _and: [enrollment_info_bool_exp]
    _not: enrollment_info_bool_exp
    _or: [enrollment_info_bool_exp]
    check: String_comparison_exp
    comparison: String_comparison_exp
    data: json_comparison_exp
    entities: _json_comparison_exp
    entityids: json_comparison_exp
    id: Int_comparison_exp
    organization: schools_bool_exp
    organizationId: uuid_comparison_exp
    student: students_bool_exp
    studentId: uuid_comparison_exp
    studentInternalId: String_comparison_exp
}

"input type for incrementing integer column in table \"enrollment_info\""
input enrollment_info_inc_input {
    id: Int
}

"input type for inserting data into table \"enrollment_info\""
input enrollment_info_insert_input {
    check: String
    comparison: String
    data: json
    entities: _json
    entityids: json
    id: Int
    organization: schools_obj_rel_insert_input
    organizationId: uuid
    student: students_obj_rel_insert_input
    studentId: uuid
    studentInternalId: String
}

"order by max() on columns of table \"enrollment_info\""
input enrollment_info_max_order_by {
    check: order_by
    comparison: order_by
    id: order_by
    organizationId: order_by
    studentId: order_by
    studentInternalId: order_by
}

"order by min() on columns of table \"enrollment_info\""
input enrollment_info_min_order_by {
    check: order_by
    comparison: order_by
    id: order_by
    organizationId: order_by
    studentId: order_by
    studentInternalId: order_by
}

"input type for inserting object relation for remote table \"enrollment_info\""
input enrollment_info_obj_rel_insert_input {
    data: enrollment_info_insert_input!
}

"ordering options when selecting data from \"enrollment_info\""
input enrollment_info_order_by {
    check: order_by
    comparison: order_by
    data: order_by
    entities: order_by
    entityids: order_by
    id: order_by
    organization: schools_order_by
    organizationId: order_by
    student: students_order_by
    studentId: order_by
    studentInternalId: order_by
}

"input type for updating data in table \"enrollment_info\""
input enrollment_info_set_input {
    check: String
    comparison: String
    data: json
    entities: _json
    entityids: json
    id: Int
    organizationId: uuid
    studentId: uuid
    studentInternalId: String
}

"order by stddev() on columns of table \"enrollment_info\""
input enrollment_info_stddev_order_by {
    id: order_by
}

"order by stddev_pop() on columns of table \"enrollment_info\""
input enrollment_info_stddev_pop_order_by {
    id: order_by
}

"order by stddev_samp() on columns of table \"enrollment_info\""
input enrollment_info_stddev_samp_order_by {
    id: order_by
}

"order by sum() on columns of table \"enrollment_info\""
input enrollment_info_sum_order_by {
    id: order_by
}

"order by var_pop() on columns of table \"enrollment_info\""
input enrollment_info_var_pop_order_by {
    id: order_by
}

"order by var_samp() on columns of table \"enrollment_info\""
input enrollment_info_var_samp_order_by {
    id: order_by
}

"order by variance() on columns of table \"enrollment_info\""
input enrollment_info_variance_order_by {
    id: order_by
}

"order by aggregate values of table \"enrollment_rules\""
input enrollment_rules_aggregate_order_by {
    avg: enrollment_rules_avg_order_by
    count: order_by
    max: enrollment_rules_max_order_by
    min: enrollment_rules_min_order_by
    stddev: enrollment_rules_stddev_order_by
    stddev_pop: enrollment_rules_stddev_pop_order_by
    stddev_samp: enrollment_rules_stddev_samp_order_by
    sum: enrollment_rules_sum_order_by
    var_pop: enrollment_rules_var_pop_order_by
    var_samp: enrollment_rules_var_samp_order_by
    variance: enrollment_rules_variance_order_by
}

"input type for inserting array relation for remote table \"enrollment_rules\""
input enrollment_rules_arr_rel_insert_input {
    data: [enrollment_rules_insert_input!]!
    on_conflict: enrollment_rules_on_conflict
}

"order by avg() on columns of table \"enrollment_rules\""
input enrollment_rules_avg_order_by {
    id: order_by
}

"Boolean expression to filter rows from the table \"enrollment_rules\". All fields are combined with a logical 'AND'."
input enrollment_rules_bool_exp {
    _and: [enrollment_rules_bool_exp]
    _not: enrollment_rules_bool_exp
    _or: [enrollment_rules_bool_exp]
    data: json_comparison_exp
    id: Int_comparison_exp
    info: enrollment_info_bool_exp
    organization: schools_bool_exp
    organizationId: uuid_comparison_exp
    student: students_bool_exp
    studentInternalId: String_comparison_exp
}

"input type for incrementing integer column in table \"enrollment_rules\""
input enrollment_rules_inc_input {
    id: Int
}

"input type for inserting data into table \"enrollment_rules\""
input enrollment_rules_insert_input {
    data: json
    id: Int
    info: enrollment_info_obj_rel_insert_input
    organization: schools_obj_rel_insert_input
    organizationId: uuid
    student: students_obj_rel_insert_input
    studentInternalId: String
}

"order by max() on columns of table \"enrollment_rules\""
input enrollment_rules_max_order_by {
    id: order_by
    organizationId: order_by
    studentInternalId: order_by
}

"order by min() on columns of table \"enrollment_rules\""
input enrollment_rules_min_order_by {
    id: order_by
    organizationId: order_by
    studentInternalId: order_by
}

"input type for inserting object relation for remote table \"enrollment_rules\""
input enrollment_rules_obj_rel_insert_input {
    data: enrollment_rules_insert_input!
    on_conflict: enrollment_rules_on_conflict
}

"on conflict condition type for table \"enrollment_rules\""
input enrollment_rules_on_conflict {
    constraint: enrollment_rules_constraint!
    update_columns: [enrollment_rules_update_column!]!
    where: enrollment_rules_bool_exp
}

"ordering options when selecting data from \"enrollment_rules\""
input enrollment_rules_order_by {
    data: order_by
    id: order_by
    info: enrollment_info_order_by
    organization: schools_order_by
    organizationId: order_by
    student: students_order_by
    studentInternalId: order_by
}

"primary key columns input for table: \"enrollment_rules\""
input enrollment_rules_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"enrollment_rules\""
input enrollment_rules_set_input {
    data: json
    id: Int
    organizationId: uuid
    studentInternalId: String
}

"order by stddev() on columns of table \"enrollment_rules\""
input enrollment_rules_stddev_order_by {
    id: order_by
}

"order by stddev_pop() on columns of table \"enrollment_rules\""
input enrollment_rules_stddev_pop_order_by {
    id: order_by
}

"order by stddev_samp() on columns of table \"enrollment_rules\""
input enrollment_rules_stddev_samp_order_by {
    id: order_by
}

"order by sum() on columns of table \"enrollment_rules\""
input enrollment_rules_sum_order_by {
    id: order_by
}

"order by var_pop() on columns of table \"enrollment_rules\""
input enrollment_rules_var_pop_order_by {
    id: order_by
}

"order by var_samp() on columns of table \"enrollment_rules\""
input enrollment_rules_var_samp_order_by {
    id: order_by
}

"order by variance() on columns of table \"enrollment_rules\""
input enrollment_rules_variance_order_by {
    id: order_by
}

"order by aggregate values of table \"frequency_types\""
input frequency_types_aggregate_order_by {
    count: order_by
    max: frequency_types_max_order_by
    min: frequency_types_min_order_by
}

"input type for inserting array relation for remote table \"frequency_types\""
input frequency_types_arr_rel_insert_input {
    data: [frequency_types_insert_input!]!
    on_conflict: frequency_types_on_conflict
}

"Boolean expression to filter rows from the table \"frequency_types\". All fields are combined with a logical 'AND'."
input frequency_types_bool_exp {
    _and: [frequency_types_bool_exp]
    _not: frequency_types_bool_exp
    _or: [frequency_types_bool_exp]
    courses: courses_bool_exp
    description: String_comparison_exp
    value: String_comparison_exp
}

"expression to compare columns of type frequency_types_enum. All fields are combined with logical 'AND'."
input frequency_types_enum_comparison_exp {
    _eq: frequency_types_enum
    _in: [frequency_types_enum!]
    _is_null: Boolean
    _neq: frequency_types_enum
    _nin: [frequency_types_enum!]
}

"input type for inserting data into table \"frequency_types\""
input frequency_types_insert_input {
    courses: courses_arr_rel_insert_input
    description: String
    value: String
}

"order by max() on columns of table \"frequency_types\""
input frequency_types_max_order_by {
    description: order_by
    value: order_by
}

"order by min() on columns of table \"frequency_types\""
input frequency_types_min_order_by {
    description: order_by
    value: order_by
}

"input type for inserting object relation for remote table \"frequency_types\""
input frequency_types_obj_rel_insert_input {
    data: frequency_types_insert_input!
    on_conflict: frequency_types_on_conflict
}

"on conflict condition type for table \"frequency_types\""
input frequency_types_on_conflict {
    constraint: frequency_types_constraint!
    update_columns: [frequency_types_update_column!]!
    where: frequency_types_bool_exp
}

"ordering options when selecting data from \"frequency_types\""
input frequency_types_order_by {
    courses_aggregate: courses_aggregate_order_by
    description: order_by
    value: order_by
}

"primary key columns input for table: \"frequency_types\""
input frequency_types_pk_columns_input {
    value: String!
}

"input type for updating data in table \"frequency_types\""
input frequency_types_set_input {
    description: String
    value: String
}

"order by aggregate values of table \"gender_types\""
input gender_types_aggregate_order_by {
    count: order_by
    max: gender_types_max_order_by
    min: gender_types_min_order_by
}

"input type for inserting array relation for remote table \"gender_types\""
input gender_types_arr_rel_insert_input {
    data: [gender_types_insert_input!]!
    on_conflict: gender_types_on_conflict
}

"Boolean expression to filter rows from the table \"gender_types\". All fields are combined with a logical 'AND'."
input gender_types_bool_exp {
    _and: [gender_types_bool_exp]
    _not: gender_types_bool_exp
    _or: [gender_types_bool_exp]
    description: String_comparison_exp
    students: students_bool_exp
    value: String_comparison_exp
}

"expression to compare columns of type gender_types_enum. All fields are combined with logical 'AND'."
input gender_types_enum_comparison_exp {
    _eq: gender_types_enum
    _in: [gender_types_enum!]
    _is_null: Boolean
    _neq: gender_types_enum
    _nin: [gender_types_enum!]
}

"input type for inserting data into table \"gender_types\""
input gender_types_insert_input {
    description: String
    students: students_arr_rel_insert_input
    value: String
}

"order by max() on columns of table \"gender_types\""
input gender_types_max_order_by {
    description: order_by
    value: order_by
}

"order by min() on columns of table \"gender_types\""
input gender_types_min_order_by {
    description: order_by
    value: order_by
}

"input type for inserting object relation for remote table \"gender_types\""
input gender_types_obj_rel_insert_input {
    data: gender_types_insert_input!
    on_conflict: gender_types_on_conflict
}

"on conflict condition type for table \"gender_types\""
input gender_types_on_conflict {
    constraint: gender_types_constraint!
    update_columns: [gender_types_update_column!]!
    where: gender_types_bool_exp
}

"ordering options when selecting data from \"gender_types\""
input gender_types_order_by {
    description: order_by
    students_aggregate: students_aggregate_order_by
    value: order_by
}

"primary key columns input for table: \"gender_types\""
input gender_types_pk_columns_input {
    value: String!
}

"input type for updating data in table \"gender_types\""
input gender_types_set_input {
    description: String
    value: String
}

"order by aggregate values of table \"grades\""
input grades_aggregate_order_by {
    avg: grades_avg_order_by
    count: order_by
    max: grades_max_order_by
    min: grades_min_order_by
    stddev: grades_stddev_order_by
    stddev_pop: grades_stddev_pop_order_by
    stddev_samp: grades_stddev_samp_order_by
    sum: grades_sum_order_by
    var_pop: grades_var_pop_order_by
    var_samp: grades_var_samp_order_by
    variance: grades_variance_order_by
}

"input type for inserting array relation for remote table \"grades\""
input grades_arr_rel_insert_input {
    data: [grades_insert_input!]!
    on_conflict: grades_on_conflict
}

"order by avg() on columns of table \"grades\""
input grades_avg_order_by {
    id: order_by
}

"Boolean expression to filter rows from the table \"grades\". All fields are combined with a logical 'AND'."
input grades_bool_exp {
    _and: [grades_bool_exp]
    _not: grades_bool_exp
    _or: [grades_bool_exp]
    courses: course_grades_bool_exp
    id: Int_comparison_exp
    name: String_comparison_exp
    students: students_bool_exp
}

"input type for incrementing integer column in table \"grades\""
input grades_inc_input {
    id: Int
}

"input type for inserting data into table \"grades\""
input grades_insert_input {
    courses: course_grades_arr_rel_insert_input
    id: Int
    name: String
    students: students_arr_rel_insert_input
}

"order by max() on columns of table \"grades\""
input grades_max_order_by {
    id: order_by
    name: order_by
}

"order by min() on columns of table \"grades\""
input grades_min_order_by {
    id: order_by
    name: order_by
}

"input type for inserting object relation for remote table \"grades\""
input grades_obj_rel_insert_input {
    data: grades_insert_input!
    on_conflict: grades_on_conflict
}

"on conflict condition type for table \"grades\""
input grades_on_conflict {
    constraint: grades_constraint!
    update_columns: [grades_update_column!]!
    where: grades_bool_exp
}

"ordering options when selecting data from \"grades\""
input grades_order_by {
    courses_aggregate: course_grades_aggregate_order_by
    id: order_by
    name: order_by
    students_aggregate: students_aggregate_order_by
}

"primary key columns input for table: \"grades\""
input grades_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"grades\""
input grades_set_input {
    id: Int
    name: String
}

"order by stddev() on columns of table \"grades\""
input grades_stddev_order_by {
    id: order_by
}

"order by stddev_pop() on columns of table \"grades\""
input grades_stddev_pop_order_by {
    id: order_by
}

"order by stddev_samp() on columns of table \"grades\""
input grades_stddev_samp_order_by {
    id: order_by
}

"order by sum() on columns of table \"grades\""
input grades_sum_order_by {
    id: order_by
}

"order by var_pop() on columns of table \"grades\""
input grades_var_pop_order_by {
    id: order_by
}

"order by var_samp() on columns of table \"grades\""
input grades_var_samp_order_by {
    id: order_by
}

"order by variance() on columns of table \"grades\""
input grades_variance_order_by {
    id: order_by
}

"order by aggregate values of table \"instructor_enrollments\""
input instructor_enrollments_aggregate_order_by {
    avg: instructor_enrollments_avg_order_by
    count: order_by
    max: instructor_enrollments_max_order_by
    min: instructor_enrollments_min_order_by
    stddev: instructor_enrollments_stddev_order_by
    stddev_pop: instructor_enrollments_stddev_pop_order_by
    stddev_samp: instructor_enrollments_stddev_samp_order_by
    sum: instructor_enrollments_sum_order_by
    var_pop: instructor_enrollments_var_pop_order_by
    var_samp: instructor_enrollments_var_samp_order_by
    variance: instructor_enrollments_variance_order_by
}

"input type for inserting array relation for remote table \"instructor_enrollments\""
input instructor_enrollments_arr_rel_insert_input {
    data: [instructor_enrollments_insert_input!]!
    on_conflict: instructor_enrollments_on_conflict
}

"order by avg() on columns of table \"instructor_enrollments\""
input instructor_enrollments_avg_order_by {
    capacity: order_by
    durationId: order_by
    seatsAvailable: order_by
    totalSessions: order_by
}

"Boolean expression to filter rows from the table \"instructor_enrollments\". All fields are combined with a logical 'AND'."
input instructor_enrollments_bool_exp {
    _and: [instructor_enrollments_bool_exp]
    _not: instructor_enrollments_bool_exp
    _or: [instructor_enrollments_bool_exp]
    canEnroll: Boolean_comparison_exp
    capacity: Int_comparison_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    duration: durations_bool_exp
    durationId: Int_comparison_exp
    endTime: timestamptz_comparison_exp
    frequencyType: frequency_types_enum_comparison_exp
    id: uuid_comparison_exp
    instructor: users_bool_exp
    instructorId: uuid_comparison_exp
    lookupId: String_comparison_exp
    meetingEnrollments: student_meeting_enrollments_bool_exp
    published: Boolean_comparison_exp
    schedules: schedules_bool_exp
    seatsAvailable: Int_comparison_exp
    startTime: timestamptz_comparison_exp
    studentEnrollments: student_enrollments_bool_exp
    totalSessions: Int_comparison_exp
    unit: units_bool_exp
    unitId: uuid_comparison_exp
    zoomMeetings: zoom_meetings_bool_exp
}

"input type for incrementing integer column in table \"instructor_enrollments\""
input instructor_enrollments_inc_input {
    capacity: Int
    durationId: Int
    seatsAvailable: Int
    totalSessions: Int
}

"input type for inserting data into table \"instructor_enrollments\""
input instructor_enrollments_insert_input {
    canEnroll: Boolean
    capacity: Int
    course: courses_obj_rel_insert_input
    courseId: uuid
    duration: durations_obj_rel_insert_input
    durationId: Int
    endTime: timestamptz
    frequencyType: frequency_types_enum
    id: uuid
    instructor: users_obj_rel_insert_input
    instructorId: uuid
    lookupId: String
    meetingEnrollments: student_meeting_enrollments_arr_rel_insert_input
    published: Boolean
    schedules: schedules_arr_rel_insert_input
    seatsAvailable: Int
    startTime: timestamptz
    studentEnrollments: student_enrollments_arr_rel_insert_input
    totalSessions: Int
    unit: units_obj_rel_insert_input
    unitId: uuid
    zoomMeetings: zoom_meetings_arr_rel_insert_input
}

"order by max() on columns of table \"instructor_enrollments\""
input instructor_enrollments_max_order_by {
    capacity: order_by
    courseId: order_by
    durationId: order_by
    endTime: order_by
    id: order_by
    instructorId: order_by
    lookupId: order_by
    seatsAvailable: order_by
    startTime: order_by
    totalSessions: order_by
    unitId: order_by
}

"order by min() on columns of table \"instructor_enrollments\""
input instructor_enrollments_min_order_by {
    capacity: order_by
    courseId: order_by
    durationId: order_by
    endTime: order_by
    id: order_by
    instructorId: order_by
    lookupId: order_by
    seatsAvailable: order_by
    startTime: order_by
    totalSessions: order_by
    unitId: order_by
}

"input type for inserting object relation for remote table \"instructor_enrollments\""
input instructor_enrollments_obj_rel_insert_input {
    data: instructor_enrollments_insert_input!
    on_conflict: instructor_enrollments_on_conflict
}

"on conflict condition type for table \"instructor_enrollments\""
input instructor_enrollments_on_conflict {
    constraint: instructor_enrollments_constraint!
    update_columns: [instructor_enrollments_update_column!]!
    where: instructor_enrollments_bool_exp
}

"ordering options when selecting data from \"instructor_enrollments\""
input instructor_enrollments_order_by {
    canEnroll: order_by
    capacity: order_by
    course: courses_order_by
    courseId: order_by
    duration: durations_order_by
    durationId: order_by
    endTime: order_by
    frequencyType: order_by
    id: order_by
    instructor: users_order_by
    instructorId: order_by
    lookupId: order_by
    meetingEnrollments_aggregate: student_meeting_enrollments_aggregate_order_by
    published: order_by
    schedules_aggregate: schedules_aggregate_order_by
    seatsAvailable: order_by
    startTime: order_by
    studentEnrollments_aggregate: student_enrollments_aggregate_order_by
    totalSessions: order_by
    unit: units_order_by
    unitId: order_by
    zoomMeetings_aggregate: zoom_meetings_aggregate_order_by
}

"primary key columns input for table: \"instructor_enrollments\""
input instructor_enrollments_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"instructor_enrollments\""
input instructor_enrollments_set_input {
    canEnroll: Boolean
    capacity: Int
    courseId: uuid
    durationId: Int
    endTime: timestamptz
    frequencyType: frequency_types_enum
    id: uuid
    instructorId: uuid
    lookupId: String
    published: Boolean
    seatsAvailable: Int
    startTime: timestamptz
    totalSessions: Int
    unitId: uuid
}

"order by stddev() on columns of table \"instructor_enrollments\""
input instructor_enrollments_stddev_order_by {
    capacity: order_by
    durationId: order_by
    seatsAvailable: order_by
    totalSessions: order_by
}

"order by stddev_pop() on columns of table \"instructor_enrollments\""
input instructor_enrollments_stddev_pop_order_by {
    capacity: order_by
    durationId: order_by
    seatsAvailable: order_by
    totalSessions: order_by
}

"order by stddev_samp() on columns of table \"instructor_enrollments\""
input instructor_enrollments_stddev_samp_order_by {
    capacity: order_by
    durationId: order_by
    seatsAvailable: order_by
    totalSessions: order_by
}

"order by sum() on columns of table \"instructor_enrollments\""
input instructor_enrollments_sum_order_by {
    capacity: order_by
    durationId: order_by
    seatsAvailable: order_by
    totalSessions: order_by
}

"order by var_pop() on columns of table \"instructor_enrollments\""
input instructor_enrollments_var_pop_order_by {
    capacity: order_by
    durationId: order_by
    seatsAvailable: order_by
    totalSessions: order_by
}

"order by var_samp() on columns of table \"instructor_enrollments\""
input instructor_enrollments_var_samp_order_by {
    capacity: order_by
    durationId: order_by
    seatsAvailable: order_by
    totalSessions: order_by
}

"order by variance() on columns of table \"instructor_enrollments\""
input instructor_enrollments_variance_order_by {
    capacity: order_by
    durationId: order_by
    seatsAvailable: order_by
    totalSessions: order_by
}

"expression to compare columns of type json. All fields are combined with logical 'AND'."
input json_comparison_exp {
    _eq: json
    _gt: json
    _gte: json
    _in: [json!]
    _is_null: Boolean
    _lt: json
    _lte: json
    _neq: json
    _nin: [json!]
}

"expression to compare columns of type jsonb. All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

"expression to compare columns of type numeric. All fields are combined with logical 'AND'."
input numeric_comparison_exp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _is_null: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"order by aggregate values of table \"parent_email_survey\""
input parent_email_survey_aggregate_order_by {
    avg: parent_email_survey_avg_order_by
    count: order_by
    max: parent_email_survey_max_order_by
    min: parent_email_survey_min_order_by
    stddev: parent_email_survey_stddev_order_by
    stddev_pop: parent_email_survey_stddev_pop_order_by
    stddev_samp: parent_email_survey_stddev_samp_order_by
    sum: parent_email_survey_sum_order_by
    var_pop: parent_email_survey_var_pop_order_by
    var_samp: parent_email_survey_var_samp_order_by
    variance: parent_email_survey_variance_order_by
}

"order by avg() on columns of table \"parent_email_survey\""
input parent_email_survey_avg_order_by {
    session: order_by
    total_sessions: order_by
}

"Boolean expression to filter rows from the table \"parent_email_survey\". All fields are combined with a logical 'AND'."
input parent_email_survey_bool_exp {
    _and: [parent_email_survey_bool_exp]
    _not: parent_email_survey_bool_exp
    _or: [parent_email_survey_bool_exp]
    cancelled: Boolean_comparison_exp
    cohort: instructor_enrollments_bool_exp
    course: courses_bool_exp
    course_id: uuid_comparison_exp
    end_time: timestamptz_comparison_exp
    id: uuid_comparison_exp
    instructor_enrollment_id: uuid_comparison_exp
    instructor_id: uuid_comparison_exp
    session: Int_comparison_exp
    start_time: timestamptz_comparison_exp
    student: students_bool_exp
    student_id: uuid_comparison_exp
    survey_sent: Boolean_comparison_exp
    total_sessions: Int_comparison_exp
    zoom_meeting_id: uuid_comparison_exp
    zoom_occurrence_id: String_comparison_exp
}

"order by max() on columns of table \"parent_email_survey\""
input parent_email_survey_max_order_by {
    course_id: order_by
    end_time: order_by
    id: order_by
    instructor_enrollment_id: order_by
    instructor_id: order_by
    session: order_by
    start_time: order_by
    student_id: order_by
    total_sessions: order_by
    zoom_meeting_id: order_by
    zoom_occurrence_id: order_by
}

"order by min() on columns of table \"parent_email_survey\""
input parent_email_survey_min_order_by {
    course_id: order_by
    end_time: order_by
    id: order_by
    instructor_enrollment_id: order_by
    instructor_id: order_by
    session: order_by
    start_time: order_by
    student_id: order_by
    total_sessions: order_by
    zoom_meeting_id: order_by
    zoom_occurrence_id: order_by
}

"ordering options when selecting data from \"parent_email_survey\""
input parent_email_survey_order_by {
    cancelled: order_by
    cohort: instructor_enrollments_order_by
    course: courses_order_by
    course_id: order_by
    end_time: order_by
    id: order_by
    instructor_enrollment_id: order_by
    instructor_id: order_by
    session: order_by
    start_time: order_by
    student: students_order_by
    student_id: order_by
    survey_sent: order_by
    total_sessions: order_by
    zoom_meeting_id: order_by
    zoom_occurrence_id: order_by
}

"order by stddev() on columns of table \"parent_email_survey\""
input parent_email_survey_stddev_order_by {
    session: order_by
    total_sessions: order_by
}

"order by stddev_pop() on columns of table \"parent_email_survey\""
input parent_email_survey_stddev_pop_order_by {
    session: order_by
    total_sessions: order_by
}

"order by stddev_samp() on columns of table \"parent_email_survey\""
input parent_email_survey_stddev_samp_order_by {
    session: order_by
    total_sessions: order_by
}

"order by sum() on columns of table \"parent_email_survey\""
input parent_email_survey_sum_order_by {
    session: order_by
    total_sessions: order_by
}

"order by var_pop() on columns of table \"parent_email_survey\""
input parent_email_survey_var_pop_order_by {
    session: order_by
    total_sessions: order_by
}

"order by var_samp() on columns of table \"parent_email_survey\""
input parent_email_survey_var_samp_order_by {
    session: order_by
    total_sessions: order_by
}

"order by variance() on columns of table \"parent_email_survey\""
input parent_email_survey_variance_order_by {
    session: order_by
    total_sessions: order_by
}

"order by aggregate values of table \"product_prices\""
input product_prices_aggregate_order_by {
    avg: product_prices_avg_order_by
    count: order_by
    max: product_prices_max_order_by
    min: product_prices_min_order_by
    stddev: product_prices_stddev_order_by
    stddev_pop: product_prices_stddev_pop_order_by
    stddev_samp: product_prices_stddev_samp_order_by
    sum: product_prices_sum_order_by
    var_pop: product_prices_var_pop_order_by
    var_samp: product_prices_var_samp_order_by
    variance: product_prices_variance_order_by
}

"input type for inserting array relation for remote table \"product_prices\""
input product_prices_arr_rel_insert_input {
    data: [product_prices_insert_input!]!
    on_conflict: product_prices_on_conflict
}

"order by avg() on columns of table \"product_prices\""
input product_prices_avg_order_by {
    amount: order_by
}

"Boolean expression to filter rows from the table \"product_prices\". All fields are combined with a logical 'AND'."
input product_prices_bool_exp {
    _and: [product_prices_bool_exp]
    _not: product_prices_bool_exp
    _or: [product_prices_bool_exp]
    active: Boolean_comparison_exp
    amount: Int_comparison_exp
    id: String_comparison_exp
    interval: String_comparison_exp
    product: products_bool_exp
    productId: String_comparison_exp
    stripeObject: json_comparison_exp
}

"input type for incrementing integer column in table \"product_prices\""
input product_prices_inc_input {
    amount: Int
}

"input type for inserting data into table \"product_prices\""
input product_prices_insert_input {
    active: Boolean
    amount: Int
    id: String
    interval: String
    product: products_obj_rel_insert_input
    productId: String
    stripeObject: json
}

"order by max() on columns of table \"product_prices\""
input product_prices_max_order_by {
    amount: order_by
    id: order_by
    interval: order_by
    productId: order_by
}

"order by min() on columns of table \"product_prices\""
input product_prices_min_order_by {
    amount: order_by
    id: order_by
    interval: order_by
    productId: order_by
}

"input type for inserting object relation for remote table \"product_prices\""
input product_prices_obj_rel_insert_input {
    data: product_prices_insert_input!
    on_conflict: product_prices_on_conflict
}

"on conflict condition type for table \"product_prices\""
input product_prices_on_conflict {
    constraint: product_prices_constraint!
    update_columns: [product_prices_update_column!]!
    where: product_prices_bool_exp
}

"ordering options when selecting data from \"product_prices\""
input product_prices_order_by {
    active: order_by
    amount: order_by
    id: order_by
    interval: order_by
    product: products_order_by
    productId: order_by
    stripeObject: order_by
}

"primary key columns input for table: \"product_prices\""
input product_prices_pk_columns_input {
    id: String!
}

"input type for updating data in table \"product_prices\""
input product_prices_set_input {
    active: Boolean
    amount: Int
    id: String
    interval: String
    productId: String
    stripeObject: json
}

"order by stddev() on columns of table \"product_prices\""
input product_prices_stddev_order_by {
    amount: order_by
}

"order by stddev_pop() on columns of table \"product_prices\""
input product_prices_stddev_pop_order_by {
    amount: order_by
}

"order by stddev_samp() on columns of table \"product_prices\""
input product_prices_stddev_samp_order_by {
    amount: order_by
}

"order by sum() on columns of table \"product_prices\""
input product_prices_sum_order_by {
    amount: order_by
}

"order by var_pop() on columns of table \"product_prices\""
input product_prices_var_pop_order_by {
    amount: order_by
}

"order by var_samp() on columns of table \"product_prices\""
input product_prices_var_samp_order_by {
    amount: order_by
}

"order by variance() on columns of table \"product_prices\""
input product_prices_variance_order_by {
    amount: order_by
}

"order by aggregate values of table \"products\""
input products_aggregate_order_by {
    count: order_by
    max: products_max_order_by
    min: products_min_order_by
}

"input type for inserting array relation for remote table \"products\""
input products_arr_rel_insert_input {
    data: [products_insert_input!]!
    on_conflict: products_on_conflict
}

"Boolean expression to filter rows from the table \"products\". All fields are combined with a logical 'AND'."
input products_bool_exp {
    _and: [products_bool_exp]
    _not: products_bool_exp
    _or: [products_bool_exp]
    details: String_comparison_exp
    id: String_comparison_exp
    name: String_comparison_exp
    prices: product_prices_bool_exp
    stripeObject: json_comparison_exp
    title: String_comparison_exp
}

"input type for inserting data into table \"products\""
input products_insert_input {
    details: String
    id: String
    name: String
    prices: product_prices_arr_rel_insert_input
    stripeObject: json
    title: String
}

"order by max() on columns of table \"products\""
input products_max_order_by {
    details: order_by
    id: order_by
    name: order_by
    title: order_by
}

"order by min() on columns of table \"products\""
input products_min_order_by {
    details: order_by
    id: order_by
    name: order_by
    title: order_by
}

"input type for inserting object relation for remote table \"products\""
input products_obj_rel_insert_input {
    data: products_insert_input!
    on_conflict: products_on_conflict
}

"on conflict condition type for table \"products\""
input products_on_conflict {
    constraint: products_constraint!
    update_columns: [products_update_column!]!
    where: products_bool_exp
}

"ordering options when selecting data from \"products\""
input products_order_by {
    details: order_by
    id: order_by
    name: order_by
    prices_aggregate: product_prices_aggregate_order_by
    stripeObject: order_by
    title: order_by
}

"primary key columns input for table: \"products\""
input products_pk_columns_input {
    id: String!
}

"input type for updating data in table \"products\""
input products_set_input {
    details: String
    id: String
    name: String
    stripeObject: json
    title: String
}

"order by aggregate values of table \"profile\""
input profile_aggregate_order_by {
    avg: profile_avg_order_by
    count: order_by
    max: profile_max_order_by
    min: profile_min_order_by
    stddev: profile_stddev_order_by
    stddev_pop: profile_stddev_pop_order_by
    stddev_samp: profile_stddev_samp_order_by
    sum: profile_sum_order_by
    var_pop: profile_var_pop_order_by
    var_samp: profile_var_samp_order_by
    variance: profile_variance_order_by
}

"order by avg() on columns of table \"profile\""
input profile_avg_order_by {
    currentGradeId: order_by
}

"Boolean expression to filter rows from the table \"profile\". All fields are combined with a logical 'AND'."
input profile_bool_exp {
    _and: [profile_bool_exp]
    _not: profile_bool_exp
    _or: [profile_bool_exp]
    currentGradeId: Int_comparison_exp
    dob: date_comparison_exp
    email: String_comparison_exp
    firstName: String_comparison_exp
    gender: gender_types_bool_exp
    genderType: String_comparison_exp
    grade: grades_bool_exp
    id: uuid_comparison_exp
    lastName: String_comparison_exp
    organization: schools_bool_exp
    organizationId: uuid_comparison_exp
    parentId: uuid_comparison_exp
    paying: Boolean_comparison_exp
    phone: String_comparison_exp
    role: String_comparison_exp
    searchName: String_comparison_exp
    subscription: subscriptions_bool_exp
}

"order by max() on columns of table \"profile\""
input profile_max_order_by {
    currentGradeId: order_by
    dob: order_by
    email: order_by
    firstName: order_by
    genderType: order_by
    id: order_by
    lastName: order_by
    organizationId: order_by
    parentId: order_by
    phone: order_by
    role: order_by
    searchName: order_by
}

"order by min() on columns of table \"profile\""
input profile_min_order_by {
    currentGradeId: order_by
    dob: order_by
    email: order_by
    firstName: order_by
    genderType: order_by
    id: order_by
    lastName: order_by
    organizationId: order_by
    parentId: order_by
    phone: order_by
    role: order_by
    searchName: order_by
}

"ordering options when selecting data from \"profile\""
input profile_order_by {
    currentGradeId: order_by
    dob: order_by
    email: order_by
    firstName: order_by
    gender: gender_types_order_by
    genderType: order_by
    grade: grades_order_by
    id: order_by
    lastName: order_by
    organization: schools_order_by
    organizationId: order_by
    parentId: order_by
    paying: order_by
    phone: order_by
    role: order_by
    searchName: order_by
    subscription: subscriptions_order_by
}

"order by stddev() on columns of table \"profile\""
input profile_stddev_order_by {
    currentGradeId: order_by
}

"order by stddev_pop() on columns of table \"profile\""
input profile_stddev_pop_order_by {
    currentGradeId: order_by
}

"order by stddev_samp() on columns of table \"profile\""
input profile_stddev_samp_order_by {
    currentGradeId: order_by
}

"order by sum() on columns of table \"profile\""
input profile_sum_order_by {
    currentGradeId: order_by
}

"order by var_pop() on columns of table \"profile\""
input profile_var_pop_order_by {
    currentGradeId: order_by
}

"order by var_samp() on columns of table \"profile\""
input profile_var_samp_order_by {
    currentGradeId: order_by
}

"order by variance() on columns of table \"profile\""
input profile_variance_order_by {
    currentGradeId: order_by
}

"order by aggregate values of table \"promo_codes\""
input promo_codes_aggregate_order_by {
    count: order_by
    max: promo_codes_max_order_by
    min: promo_codes_min_order_by
}

"input type for inserting array relation for remote table \"promo_codes\""
input promo_codes_arr_rel_insert_input {
    data: [promo_codes_insert_input!]!
    on_conflict: promo_codes_on_conflict
}

"Boolean expression to filter rows from the table \"promo_codes\". All fields are combined with a logical 'AND'."
input promo_codes_bool_exp {
    _and: [promo_codes_bool_exp]
    _not: promo_codes_bool_exp
    _or: [promo_codes_bool_exp]
    active: Boolean_comparison_exp
    code: String_comparison_exp
    coupon: coupons_bool_exp
    couponId: String_comparison_exp
    id: String_comparison_exp
    stripeObject: json_comparison_exp
}

"input type for inserting data into table \"promo_codes\""
input promo_codes_insert_input {
    active: Boolean
    code: String
    coupon: coupons_obj_rel_insert_input
    couponId: String
    id: String
    stripeObject: json
}

"order by max() on columns of table \"promo_codes\""
input promo_codes_max_order_by {
    code: order_by
    couponId: order_by
    id: order_by
}

"order by min() on columns of table \"promo_codes\""
input promo_codes_min_order_by {
    code: order_by
    couponId: order_by
    id: order_by
}

"input type for inserting object relation for remote table \"promo_codes\""
input promo_codes_obj_rel_insert_input {
    data: promo_codes_insert_input!
    on_conflict: promo_codes_on_conflict
}

"on conflict condition type for table \"promo_codes\""
input promo_codes_on_conflict {
    constraint: promo_codes_constraint!
    update_columns: [promo_codes_update_column!]!
    where: promo_codes_bool_exp
}

"ordering options when selecting data from \"promo_codes\""
input promo_codes_order_by {
    active: order_by
    code: order_by
    coupon: coupons_order_by
    couponId: order_by
    id: order_by
    stripeObject: order_by
}

"primary key columns input for table: \"promo_codes\""
input promo_codes_pk_columns_input {
    id: String!
}

"input type for updating data in table \"promo_codes\""
input promo_codes_set_input {
    active: Boolean
    code: String
    couponId: String
    id: String
    stripeObject: json
}

"order by aggregate values of table \"redirect_mapping\""
input redirect_mapping_aggregate_order_by {
    avg: redirect_mapping_avg_order_by
    count: order_by
    max: redirect_mapping_max_order_by
    min: redirect_mapping_min_order_by
    stddev: redirect_mapping_stddev_order_by
    stddev_pop: redirect_mapping_stddev_pop_order_by
    stddev_samp: redirect_mapping_stddev_samp_order_by
    sum: redirect_mapping_sum_order_by
    var_pop: redirect_mapping_var_pop_order_by
    var_samp: redirect_mapping_var_samp_order_by
    variance: redirect_mapping_variance_order_by
}

"input type for inserting array relation for remote table \"redirect_mapping\""
input redirect_mapping_arr_rel_insert_input {
    data: [redirect_mapping_insert_input!]!
    on_conflict: redirect_mapping_on_conflict
}

"order by avg() on columns of table \"redirect_mapping\""
input redirect_mapping_avg_order_by {
    code: order_by
}

"Boolean expression to filter rows from the table \"redirect_mapping\". All fields are combined with a logical 'AND'."
input redirect_mapping_bool_exp {
    _and: [redirect_mapping_bool_exp]
    _not: redirect_mapping_bool_exp
    _or: [redirect_mapping_bool_exp]
    code: Int_comparison_exp
    from_slug: String_comparison_exp
    to_slug: String_comparison_exp
}

"input type for incrementing integer column in table \"redirect_mapping\""
input redirect_mapping_inc_input {
    code: Int
}

"input type for inserting data into table \"redirect_mapping\""
input redirect_mapping_insert_input {
    code: Int
    from_slug: String
    to_slug: String
}

"order by max() on columns of table \"redirect_mapping\""
input redirect_mapping_max_order_by {
    code: order_by
    from_slug: order_by
    to_slug: order_by
}

"order by min() on columns of table \"redirect_mapping\""
input redirect_mapping_min_order_by {
    code: order_by
    from_slug: order_by
    to_slug: order_by
}

"input type for inserting object relation for remote table \"redirect_mapping\""
input redirect_mapping_obj_rel_insert_input {
    data: redirect_mapping_insert_input!
    on_conflict: redirect_mapping_on_conflict
}

"on conflict condition type for table \"redirect_mapping\""
input redirect_mapping_on_conflict {
    constraint: redirect_mapping_constraint!
    update_columns: [redirect_mapping_update_column!]!
    where: redirect_mapping_bool_exp
}

"ordering options when selecting data from \"redirect_mapping\""
input redirect_mapping_order_by {
    code: order_by
    from_slug: order_by
    to_slug: order_by
}

"primary key columns input for table: \"redirect_mapping\""
input redirect_mapping_pk_columns_input {
    from_slug: String!
    to_slug: String!
}

"input type for updating data in table \"redirect_mapping\""
input redirect_mapping_set_input {
    code: Int
    from_slug: String
    to_slug: String
}

"order by stddev() on columns of table \"redirect_mapping\""
input redirect_mapping_stddev_order_by {
    code: order_by
}

"order by stddev_pop() on columns of table \"redirect_mapping\""
input redirect_mapping_stddev_pop_order_by {
    code: order_by
}

"order by stddev_samp() on columns of table \"redirect_mapping\""
input redirect_mapping_stddev_samp_order_by {
    code: order_by
}

"order by sum() on columns of table \"redirect_mapping\""
input redirect_mapping_sum_order_by {
    code: order_by
}

"order by var_pop() on columns of table \"redirect_mapping\""
input redirect_mapping_var_pop_order_by {
    code: order_by
}

"order by var_samp() on columns of table \"redirect_mapping\""
input redirect_mapping_var_samp_order_by {
    code: order_by
}

"order by variance() on columns of table \"redirect_mapping\""
input redirect_mapping_variance_order_by {
    code: order_by
}

"order by aggregate values of table \"schedules\""
input schedules_aggregate_order_by {
    avg: schedules_avg_order_by
    count: order_by
    max: schedules_max_order_by
    min: schedules_min_order_by
    stddev: schedules_stddev_order_by
    stddev_pop: schedules_stddev_pop_order_by
    stddev_samp: schedules_stddev_samp_order_by
    sum: schedules_sum_order_by
    var_pop: schedules_var_pop_order_by
    var_samp: schedules_var_samp_order_by
    variance: schedules_variance_order_by
}

"input type for inserting array relation for remote table \"schedules\""
input schedules_arr_rel_insert_input {
    data: [schedules_insert_input!]!
    on_conflict: schedules_on_conflict
}

"order by avg() on columns of table \"schedules\""
input schedules_avg_order_by {
    session: order_by
}

"Boolean expression to filter rows from the table \"schedules\". All fields are combined with a logical 'AND'."
input schedules_bool_exp {
    _and: [schedules_bool_exp]
    _not: schedules_bool_exp
    _or: [schedules_bool_exp]
    cancelled: Boolean_comparison_exp
    cohort: instructor_enrollments_bool_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    endTime: timestamptz_comparison_exp
    id: uuid_comparison_exp
    instructor: users_bool_exp
    instructorEnrollmentId: uuid_comparison_exp
    instructorId: uuid_comparison_exp
    registrant: student_meeting_enrollments_bool_exp
    registrants: student_meeting_enrollments_bool_exp
    session: Int_comparison_exp
    startTime: timestamptz_comparison_exp
    survey_sent: Boolean_comparison_exp
    zoomMeeting: zoom_meetings_bool_exp
    zoomMeetingId: uuid_comparison_exp
    zoomOccurrenceId: String_comparison_exp
}

input schedules_for_delighted_email_survey_args {
    begin: date
    cutoff: timestamptz
    mark: schedules_for_survey_mark
}

"input type for incrementing integer column in table \"schedules\""
input schedules_inc_input {
    session: Int
}

"input type for inserting data into table \"schedules\""
input schedules_insert_input {
    cancelled: Boolean
    cohort: instructor_enrollments_obj_rel_insert_input
    course: courses_obj_rel_insert_input
    courseId: uuid
    endTime: timestamptz
    id: uuid
    instructor: users_obj_rel_insert_input
    instructorEnrollmentId: uuid
    instructorId: uuid
    registrant: student_meeting_enrollments_obj_rel_insert_input
    registrants: student_meeting_enrollments_arr_rel_insert_input
    session: Int
    startTime: timestamptz
    survey_sent: Boolean
    zoomMeeting: zoom_meetings_obj_rel_insert_input
    zoomMeetingId: uuid
    zoomOccurrenceId: String
}

"order by max() on columns of table \"schedules\""
input schedules_max_order_by {
    courseId: order_by
    endTime: order_by
    id: order_by
    instructorEnrollmentId: order_by
    instructorId: order_by
    session: order_by
    startTime: order_by
    zoomMeetingId: order_by
    zoomOccurrenceId: order_by
}

"order by min() on columns of table \"schedules\""
input schedules_min_order_by {
    courseId: order_by
    endTime: order_by
    id: order_by
    instructorEnrollmentId: order_by
    instructorId: order_by
    session: order_by
    startTime: order_by
    zoomMeetingId: order_by
    zoomOccurrenceId: order_by
}

"input type for inserting object relation for remote table \"schedules\""
input schedules_obj_rel_insert_input {
    data: schedules_insert_input!
    on_conflict: schedules_on_conflict
}

"on conflict condition type for table \"schedules\""
input schedules_on_conflict {
    constraint: schedules_constraint!
    update_columns: [schedules_update_column!]!
    where: schedules_bool_exp
}

"ordering options when selecting data from \"schedules\""
input schedules_order_by {
    cancelled: order_by
    cohort: instructor_enrollments_order_by
    course: courses_order_by
    courseId: order_by
    endTime: order_by
    id: order_by
    instructor: users_order_by
    instructorEnrollmentId: order_by
    instructorId: order_by
    registrant: student_meeting_enrollments_order_by
    registrants_aggregate: student_meeting_enrollments_aggregate_order_by
    session: order_by
    startTime: order_by
    survey_sent: order_by
    zoomMeeting: zoom_meetings_order_by
    zoomMeetingId: order_by
    zoomOccurrenceId: order_by
}

"primary key columns input for table: \"schedules\""
input schedules_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"schedules\""
input schedules_set_input {
    cancelled: Boolean
    courseId: uuid
    endTime: timestamptz
    id: uuid
    instructorEnrollmentId: uuid
    instructorId: uuid
    session: Int
    startTime: timestamptz
    survey_sent: Boolean
    zoomMeetingId: uuid
    zoomOccurrenceId: String
}

"order by stddev() on columns of table \"schedules\""
input schedules_stddev_order_by {
    session: order_by
}

"order by stddev_pop() on columns of table \"schedules\""
input schedules_stddev_pop_order_by {
    session: order_by
}

"order by stddev_samp() on columns of table \"schedules\""
input schedules_stddev_samp_order_by {
    session: order_by
}

"order by sum() on columns of table \"schedules\""
input schedules_sum_order_by {
    session: order_by
}

"order by var_pop() on columns of table \"schedules\""
input schedules_var_pop_order_by {
    session: order_by
}

"order by var_samp() on columns of table \"schedules\""
input schedules_var_samp_order_by {
    session: order_by
}

"order by variance() on columns of table \"schedules\""
input schedules_variance_order_by {
    session: order_by
}

"order by aggregate values of table \"schools\""
input schools_aggregate_order_by {
    count: order_by
    max: schools_max_order_by
    min: schools_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input schools_append_input {
    config: jsonb
}

"input type for inserting array relation for remote table \"schools\""
input schools_arr_rel_insert_input {
    data: [schools_insert_input!]!
    on_conflict: schools_on_conflict
}

"Boolean expression to filter rows from the table \"schools\". All fields are combined with a logical 'AND'."
input schools_bool_exp {
    _and: [schools_bool_exp]
    _not: schools_bool_exp
    _or: [schools_bool_exp]
    banner: String_comparison_exp
    config: jsonb_comparison_exp
    domains: schools_domains_bool_exp
    id: uuid_comparison_exp
    isSchool: Boolean_comparison_exp
    loginUrl: String_comparison_exp
    logoUrl: String_comparison_exp
    name: String_comparison_exp
    profiles: profile_bool_exp
    provider: String_comparison_exp
    students: students_bool_exp
    timeZone: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input schools_delete_at_path_input {
    config: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input schools_delete_elem_input {
    config: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input schools_delete_key_input {
    config: String
}

"order by aggregate values of table \"schools_domains\""
input schools_domains_aggregate_order_by {
    count: order_by
    max: schools_domains_max_order_by
    min: schools_domains_min_order_by
}

"input type for inserting array relation for remote table \"schools_domains\""
input schools_domains_arr_rel_insert_input {
    data: [schools_domains_insert_input!]!
    on_conflict: schools_domains_on_conflict
}

"Boolean expression to filter rows from the table \"schools_domains\". All fields are combined with a logical 'AND'."
input schools_domains_bool_exp {
    _and: [schools_domains_bool_exp]
    _not: schools_domains_bool_exp
    _or: [schools_domains_bool_exp]
    domain: String_comparison_exp
    id: uuid_comparison_exp
    organization: schools_bool_exp
    school_id: uuid_comparison_exp
}

"input type for inserting data into table \"schools_domains\""
input schools_domains_insert_input {
    domain: String
    id: uuid
    organization: schools_obj_rel_insert_input
    school_id: uuid
}

"order by max() on columns of table \"schools_domains\""
input schools_domains_max_order_by {
    domain: order_by
    id: order_by
    school_id: order_by
}

"order by min() on columns of table \"schools_domains\""
input schools_domains_min_order_by {
    domain: order_by
    id: order_by
    school_id: order_by
}

"input type for inserting object relation for remote table \"schools_domains\""
input schools_domains_obj_rel_insert_input {
    data: schools_domains_insert_input!
    on_conflict: schools_domains_on_conflict
}

"on conflict condition type for table \"schools_domains\""
input schools_domains_on_conflict {
    constraint: schools_domains_constraint!
    update_columns: [schools_domains_update_column!]!
    where: schools_domains_bool_exp
}

"ordering options when selecting data from \"schools_domains\""
input schools_domains_order_by {
    domain: order_by
    id: order_by
    organization: schools_order_by
    school_id: order_by
}

"primary key columns input for table: \"schools_domains\""
input schools_domains_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"schools_domains\""
input schools_domains_set_input {
    domain: String
    id: uuid
    school_id: uuid
}

"input type for inserting data into table \"schools\""
input schools_insert_input {
    banner: String
    config: jsonb
    domains: schools_domains_arr_rel_insert_input
    id: uuid
    isSchool: Boolean
    loginUrl: String
    logoUrl: String
    name: String
    provider: String
    students: students_arr_rel_insert_input
    timeZone: String
}

"order by max() on columns of table \"schools\""
input schools_max_order_by {
    banner: order_by
    id: order_by
    loginUrl: order_by
    logoUrl: order_by
    name: order_by
    provider: order_by
    timeZone: order_by
}

"order by min() on columns of table \"schools\""
input schools_min_order_by {
    banner: order_by
    id: order_by
    loginUrl: order_by
    logoUrl: order_by
    name: order_by
    provider: order_by
    timeZone: order_by
}

"input type for inserting object relation for remote table \"schools\""
input schools_obj_rel_insert_input {
    data: schools_insert_input!
    on_conflict: schools_on_conflict
}

"on conflict condition type for table \"schools\""
input schools_on_conflict {
    constraint: schools_constraint!
    update_columns: [schools_update_column!]!
    where: schools_bool_exp
}

"ordering options when selecting data from \"schools\""
input schools_order_by {
    banner: order_by
    config: order_by
    domains_aggregate: schools_domains_aggregate_order_by
    id: order_by
    isSchool: order_by
    loginUrl: order_by
    logoUrl: order_by
    name: order_by
    profiles_aggregate: profile_aggregate_order_by
    provider: order_by
    students_aggregate: students_aggregate_order_by
    timeZone: order_by
}

"primary key columns input for table: \"schools\""
input schools_pk_columns_input {
    id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input schools_prepend_input {
    config: jsonb
}

"input type for updating data in table \"schools\""
input schools_set_input {
    banner: String
    config: jsonb
    id: uuid
    isSchool: Boolean
    loginUrl: String
    logoUrl: String
    name: String
    provider: String
    timeZone: String
}

"order by aggregate values of table \"stripe_customers\""
input stripe_customers_aggregate_order_by {
    count: order_by
    max: stripe_customers_max_order_by
    min: stripe_customers_min_order_by
}

"input type for inserting array relation for remote table \"stripe_customers\""
input stripe_customers_arr_rel_insert_input {
    data: [stripe_customers_insert_input!]!
    on_conflict: stripe_customers_on_conflict
}

"Boolean expression to filter rows from the table \"stripe_customers\". All fields are combined with a logical 'AND'."
input stripe_customers_bool_exp {
    _and: [stripe_customers_bool_exp]
    _not: stripe_customers_bool_exp
    _or: [stripe_customers_bool_exp]
    customerId: String_comparison_exp
    profileId: uuid_comparison_exp
    students: students_bool_exp
    user: profile_bool_exp
}

"input type for inserting data into table \"stripe_customers\""
input stripe_customers_insert_input {
    customerId: String
    profileId: uuid
    students: students_arr_rel_insert_input
}

"order by max() on columns of table \"stripe_customers\""
input stripe_customers_max_order_by {
    customerId: order_by
    profileId: order_by
}

"order by min() on columns of table \"stripe_customers\""
input stripe_customers_min_order_by {
    customerId: order_by
    profileId: order_by
}

"input type for inserting object relation for remote table \"stripe_customers\""
input stripe_customers_obj_rel_insert_input {
    data: stripe_customers_insert_input!
    on_conflict: stripe_customers_on_conflict
}

"on conflict condition type for table \"stripe_customers\""
input stripe_customers_on_conflict {
    constraint: stripe_customers_constraint!
    update_columns: [stripe_customers_update_column!]!
    where: stripe_customers_bool_exp
}

"ordering options when selecting data from \"stripe_customers\""
input stripe_customers_order_by {
    customerId: order_by
    profileId: order_by
    students_aggregate: students_aggregate_order_by
    user: profile_order_by
}

"primary key columns input for table: \"stripe_customers\""
input stripe_customers_pk_columns_input {
    profileId: uuid!
}

"input type for updating data in table \"stripe_customers\""
input stripe_customers_set_input {
    customerId: String
    profileId: uuid
}

"order by aggregate values of table \"student_enrollments\""
input student_enrollments_aggregate_order_by {
    count: order_by
    max: student_enrollments_max_order_by
    min: student_enrollments_min_order_by
}

"input type for inserting array relation for remote table \"student_enrollments\""
input student_enrollments_arr_rel_insert_input {
    data: [student_enrollments_insert_input!]!
    on_conflict: student_enrollments_on_conflict
}

"Boolean expression to filter rows from the table \"student_enrollments\". All fields are combined with a logical 'AND'."
input student_enrollments_bool_exp {
    _and: [student_enrollments_bool_exp]
    _not: student_enrollments_bool_exp
    _or: [student_enrollments_bool_exp]
    cohort: instructor_enrollments_bool_exp
    course: courses_bool_exp
    course_id: uuid_comparison_exp
    created_at: timestamptz_comparison_exp
    id: uuid_comparison_exp
    instructorEnrollmentId: uuid_comparison_exp
    meetingEnrollments: student_meeting_enrollments_bool_exp
    student: students_bool_exp
    studentId: uuid_comparison_exp
    subscription: subscriptions_bool_exp
    withSubscription: Boolean_comparison_exp
}

"input type for inserting data into table \"student_enrollments\""
input student_enrollments_insert_input {
    cohort: instructor_enrollments_obj_rel_insert_input
    course: courses_obj_rel_insert_input
    course_id: uuid
    created_at: timestamptz
    id: uuid
    instructorEnrollmentId: uuid
    meetingEnrollments: student_meeting_enrollments_arr_rel_insert_input
    student: students_obj_rel_insert_input
    studentId: uuid
    subscription: subscriptions_obj_rel_insert_input
    withSubscription: Boolean
}

"order by max() on columns of table \"student_enrollments\""
input student_enrollments_max_order_by {
    course_id: order_by
    created_at: order_by
    id: order_by
    instructorEnrollmentId: order_by
    studentId: order_by
}

"order by min() on columns of table \"student_enrollments\""
input student_enrollments_min_order_by {
    course_id: order_by
    created_at: order_by
    id: order_by
    instructorEnrollmentId: order_by
    studentId: order_by
}

"input type for inserting object relation for remote table \"student_enrollments\""
input student_enrollments_obj_rel_insert_input {
    data: student_enrollments_insert_input!
    on_conflict: student_enrollments_on_conflict
}

"on conflict condition type for table \"student_enrollments\""
input student_enrollments_on_conflict {
    constraint: student_enrollments_constraint!
    update_columns: [student_enrollments_update_column!]!
    where: student_enrollments_bool_exp
}

"ordering options when selecting data from \"student_enrollments\""
input student_enrollments_order_by {
    cohort: instructor_enrollments_order_by
    course: courses_order_by
    course_id: order_by
    created_at: order_by
    id: order_by
    instructorEnrollmentId: order_by
    meetingEnrollments_aggregate: student_meeting_enrollments_aggregate_order_by
    student: students_order_by
    studentId: order_by
    subscription: subscriptions_order_by
    withSubscription: order_by
}

"primary key columns input for table: \"student_enrollments\""
input student_enrollments_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"student_enrollments\""
input student_enrollments_set_input {
    course_id: uuid
    created_at: timestamptz
    id: uuid
    instructorEnrollmentId: uuid
    studentId: uuid
    withSubscription: Boolean
}

"order by aggregate values of table \"student_meeting_enrollments\""
input student_meeting_enrollments_aggregate_order_by {
    count: order_by
    max: student_meeting_enrollments_max_order_by
    min: student_meeting_enrollments_min_order_by
}

"input type for inserting array relation for remote table \"student_meeting_enrollments\""
input student_meeting_enrollments_arr_rel_insert_input {
    data: [student_meeting_enrollments_insert_input!]!
    on_conflict: student_meeting_enrollments_on_conflict
}

"Boolean expression to filter rows from the table \"student_meeting_enrollments\". All fields are combined with a logical 'AND'."
input student_meeting_enrollments_bool_exp {
    _and: [student_meeting_enrollments_bool_exp]
    _not: student_meeting_enrollments_bool_exp
    _or: [student_meeting_enrollments_bool_exp]
    cohort: instructor_enrollments_bool_exp
    enrollment: student_enrollments_bool_exp
    id: uuid_comparison_exp
    instructorEnrollmentId: uuid_comparison_exp
    joinUrl: String_comparison_exp
    reminder_notified: Boolean_comparison_exp
    sms_reminder_notified: Boolean_comparison_exp
    studentEnrollmentId: uuid_comparison_exp
    zoomMeeting: zoom_meetings_bool_exp
    zoomMeetingId: uuid_comparison_exp
    zoomRegistrantId: String_comparison_exp
}

"input type for inserting data into table \"student_meeting_enrollments\""
input student_meeting_enrollments_insert_input {
    cohort: instructor_enrollments_obj_rel_insert_input
    enrollment: student_enrollments_obj_rel_insert_input
    id: uuid
    instructorEnrollmentId: uuid
    joinUrl: String
    reminder_notified: Boolean
    sms_reminder_notified: Boolean
    studentEnrollmentId: uuid
    zoomMeeting: zoom_meetings_obj_rel_insert_input
    zoomMeetingId: uuid
    zoomRegistrantId: String
}

"order by max() on columns of table \"student_meeting_enrollments\""
input student_meeting_enrollments_max_order_by {
    id: order_by
    instructorEnrollmentId: order_by
    joinUrl: order_by
    studentEnrollmentId: order_by
    zoomMeetingId: order_by
    zoomRegistrantId: order_by
}

"order by min() on columns of table \"student_meeting_enrollments\""
input student_meeting_enrollments_min_order_by {
    id: order_by
    instructorEnrollmentId: order_by
    joinUrl: order_by
    studentEnrollmentId: order_by
    zoomMeetingId: order_by
    zoomRegistrantId: order_by
}

"input type for inserting object relation for remote table \"student_meeting_enrollments\""
input student_meeting_enrollments_obj_rel_insert_input {
    data: student_meeting_enrollments_insert_input!
    on_conflict: student_meeting_enrollments_on_conflict
}

"on conflict condition type for table \"student_meeting_enrollments\""
input student_meeting_enrollments_on_conflict {
    constraint: student_meeting_enrollments_constraint!
    update_columns: [student_meeting_enrollments_update_column!]!
    where: student_meeting_enrollments_bool_exp
}

"ordering options when selecting data from \"student_meeting_enrollments\""
input student_meeting_enrollments_order_by {
    cohort: instructor_enrollments_order_by
    enrollment: student_enrollments_order_by
    id: order_by
    instructorEnrollmentId: order_by
    joinUrl: order_by
    reminder_notified: order_by
    sms_reminder_notified: order_by
    studentEnrollmentId: order_by
    zoomMeeting: zoom_meetings_order_by
    zoomMeetingId: order_by
    zoomRegistrantId: order_by
}

"primary key columns input for table: \"student_meeting_enrollments\""
input student_meeting_enrollments_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"student_meeting_enrollments\""
input student_meeting_enrollments_set_input {
    id: uuid
    instructorEnrollmentId: uuid
    joinUrl: String
    reminder_notified: Boolean
    sms_reminder_notified: Boolean
    studentEnrollmentId: uuid
    zoomMeetingId: uuid
    zoomRegistrantId: String
}

"order by aggregate values of table \"student_sms_surveys\""
input student_sms_surveys_aggregate_order_by {
    count: order_by
    max: student_sms_surveys_max_order_by
    min: student_sms_surveys_min_order_by
}

"Boolean expression to filter rows from the table \"student_sms_surveys\". All fields are combined with a logical 'AND'."
input student_sms_surveys_bool_exp {
    _and: [student_sms_surveys_bool_exp]
    _not: student_sms_surveys_bool_exp
    _or: [student_sms_surveys_bool_exp]
    cohort: instructor_enrollments_bool_exp
    course_id: uuid_comparison_exp
    email: String_comparison_exp
    endTime: timestamptz_comparison_exp
    fullName: citext_comparison_exp
    instructor_enrollment_id: uuid_comparison_exp
    opt_in_sms: Boolean_comparison_exp
    phone: String_comparison_exp
    startTime: timestamptz_comparison_exp
    studentId: uuid_comparison_exp
}

"order by max() on columns of table \"student_sms_surveys\""
input student_sms_surveys_max_order_by {
    course_id: order_by
    email: order_by
    endTime: order_by
    fullName: order_by
    instructor_enrollment_id: order_by
    phone: order_by
    startTime: order_by
    studentId: order_by
}

"order by min() on columns of table \"student_sms_surveys\""
input student_sms_surveys_min_order_by {
    course_id: order_by
    email: order_by
    endTime: order_by
    fullName: order_by
    instructor_enrollment_id: order_by
    phone: order_by
    startTime: order_by
    studentId: order_by
}

"ordering options when selecting data from \"student_sms_surveys\""
input student_sms_surveys_order_by {
    cohort: instructor_enrollments_order_by
    course_id: order_by
    email: order_by
    endTime: order_by
    fullName: order_by
    instructor_enrollment_id: order_by
    opt_in_sms: order_by
    phone: order_by
    startTime: order_by
    studentId: order_by
}

"order by aggregate values of table \"students\""
input students_aggregate_order_by {
    avg: students_avg_order_by
    count: order_by
    max: students_max_order_by
    min: students_min_order_by
    stddev: students_stddev_order_by
    stddev_pop: students_stddev_pop_order_by
    stddev_samp: students_stddev_samp_order_by
    sum: students_sum_order_by
    var_pop: students_var_pop_order_by
    var_samp: students_var_samp_order_by
    variance: students_variance_order_by
}

"input type for inserting array relation for remote table \"students\""
input students_arr_rel_insert_input {
    data: [students_insert_input!]!
    on_conflict: students_on_conflict
}

"order by avg() on columns of table \"students\""
input students_avg_order_by {
    currentGradeId: order_by
}

"Boolean expression to filter rows from the table \"students\". All fields are combined with a logical 'AND'."
input students_bool_exp {
    _and: [students_bool_exp]
    _not: students_bool_exp
    _or: [students_bool_exp]
    createdAt: timestamptz_comparison_exp
    currentGradeId: Int_comparison_exp
    dob: date_comparison_exp
    email: String_comparison_exp
    enrollment_rules: enrollment_rules_bool_exp
    firstName: String_comparison_exp
    fullName: citext_comparison_exp
    gender: gender_types_bool_exp
    genderType: gender_types_enum_comparison_exp
    grade: grades_bool_exp
    hasConfirmed: Boolean_comparison_exp
    id: uuid_comparison_exp
    internalId: String_comparison_exp
    lastName: String_comparison_exp
    optInSms: Boolean_comparison_exp
    organization: schools_bool_exp
    organizationId: uuid_comparison_exp
    parent: users_bool_exp
    parent_id: uuid_comparison_exp
    paying: Boolean_comparison_exp
    phone: String_comparison_exp
    school: schools_bool_exp
    stripe: stripe_customers_bool_exp
    student_enrollments: student_enrollments_bool_exp
    subscription: subscriptions_bool_exp
    subscriptions: subscriptions_bool_exp
}

"input type for incrementing integer column in table \"students\""
input students_inc_input {
    currentGradeId: Int
}

"input type for inserting data into table \"students\""
input students_insert_input {
    createdAt: timestamptz
    currentGradeId: Int
    dob: date
    email: String
    enrollment_rules: enrollment_rules_arr_rel_insert_input
    firstName: String
    fullName: citext
    gender: gender_types_obj_rel_insert_input
    genderType: gender_types_enum
    grade: grades_obj_rel_insert_input
    hasConfirmed: Boolean
    id: uuid
    internalId: String
    lastName: String
    optInSms: Boolean
    organization: schools_obj_rel_insert_input
    organizationId: uuid
    parent: users_obj_rel_insert_input
    parent_id: uuid
    paying: Boolean
    phone: String
    school: schools_obj_rel_insert_input
    stripe: stripe_customers_obj_rel_insert_input
    student_enrollments: student_enrollments_arr_rel_insert_input
    subscription: subscriptions_obj_rel_insert_input
    subscriptions: subscriptions_arr_rel_insert_input
}

"order by max() on columns of table \"students\""
input students_max_order_by {
    createdAt: order_by
    currentGradeId: order_by
    dob: order_by
    email: order_by
    firstName: order_by
    fullName: order_by
    id: order_by
    internalId: order_by
    lastName: order_by
    organizationId: order_by
    parent_id: order_by
    phone: order_by
}

"order by min() on columns of table \"students\""
input students_min_order_by {
    createdAt: order_by
    currentGradeId: order_by
    dob: order_by
    email: order_by
    firstName: order_by
    fullName: order_by
    id: order_by
    internalId: order_by
    lastName: order_by
    organizationId: order_by
    parent_id: order_by
    phone: order_by
}

"input type for inserting object relation for remote table \"students\""
input students_obj_rel_insert_input {
    data: students_insert_input!
    on_conflict: students_on_conflict
}

"on conflict condition type for table \"students\""
input students_on_conflict {
    constraint: students_constraint!
    update_columns: [students_update_column!]!
    where: students_bool_exp
}

"ordering options when selecting data from \"students\""
input students_order_by {
    createdAt: order_by
    currentGradeId: order_by
    dob: order_by
    email: order_by
    enrollment_rules_aggregate: enrollment_rules_aggregate_order_by
    firstName: order_by
    fullName: order_by
    gender: gender_types_order_by
    genderType: order_by
    grade: grades_order_by
    hasConfirmed: order_by
    id: order_by
    internalId: order_by
    lastName: order_by
    optInSms: order_by
    organization: schools_order_by
    organizationId: order_by
    parent: users_order_by
    parent_id: order_by
    paying: order_by
    phone: order_by
    school: schools_order_by
    stripe: stripe_customers_order_by
    student_enrollments_aggregate: student_enrollments_aggregate_order_by
    subscription: subscriptions_order_by
    subscriptions_aggregate: subscriptions_aggregate_order_by
}

"primary key columns input for table: \"students\""
input students_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"students\""
input students_set_input {
    createdAt: timestamptz
    currentGradeId: Int
    dob: date
    email: String
    firstName: String
    fullName: citext
    genderType: gender_types_enum
    hasConfirmed: Boolean
    id: uuid
    internalId: String
    lastName: String
    optInSms: Boolean
    organizationId: uuid
    parent_id: uuid
    paying: Boolean
    phone: String
    shopifyCustomerId: String
}

"order by stddev() on columns of table \"students\""
input students_stddev_order_by {
    currentGradeId: order_by
}

"order by stddev_pop() on columns of table \"students\""
input students_stddev_pop_order_by {
    currentGradeId: order_by
}

"order by stddev_samp() on columns of table \"students\""
input students_stddev_samp_order_by {
    currentGradeId: order_by
}

"order by sum() on columns of table \"students\""
input students_sum_order_by {
    currentGradeId: order_by
}

"order by var_pop() on columns of table \"students\""
input students_var_pop_order_by {
    currentGradeId: order_by
}

"order by var_samp() on columns of table \"students\""
input students_var_samp_order_by {
    currentGradeId: order_by
}

"order by variance() on columns of table \"students\""
input students_variance_order_by {
    currentGradeId: order_by
}

"order by aggregate values of table \"subjects\""
input subjects_aggregate_order_by {
    count: order_by
    max: subjects_max_order_by
    min: subjects_min_order_by
}

"input type for inserting array relation for remote table \"subjects\""
input subjects_arr_rel_insert_input {
    data: [subjects_insert_input!]!
    on_conflict: subjects_on_conflict
}

"Boolean expression to filter rows from the table \"subjects\". All fields are combined with a logical 'AND'."
input subjects_bool_exp {
    _and: [subjects_bool_exp]
    _not: subjects_bool_exp
    _or: [subjects_bool_exp]
    courses: courses_bool_exp
    description: json_comparison_exp
    id: uuid_comparison_exp
    name: String_comparison_exp
}

"input type for inserting data into table \"subjects\""
input subjects_insert_input {
    courses: courses_arr_rel_insert_input
    description: json
    id: uuid
    name: String
}

"order by max() on columns of table \"subjects\""
input subjects_max_order_by {
    id: order_by
    name: order_by
}

"order by min() on columns of table \"subjects\""
input subjects_min_order_by {
    id: order_by
    name: order_by
}

"input type for inserting object relation for remote table \"subjects\""
input subjects_obj_rel_insert_input {
    data: subjects_insert_input!
    on_conflict: subjects_on_conflict
}

"on conflict condition type for table \"subjects\""
input subjects_on_conflict {
    constraint: subjects_constraint!
    update_columns: [subjects_update_column!]!
    where: subjects_bool_exp
}

"ordering options when selecting data from \"subjects\""
input subjects_order_by {
    courses_aggregate: courses_aggregate_order_by
    description: order_by
    id: order_by
    name: order_by
}

"primary key columns input for table: \"subjects\""
input subjects_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"subjects\""
input subjects_set_input {
    description: json
    id: uuid
    name: String
}

"order by aggregate values of table \"subscription_status\""
input subscription_status_aggregate_order_by {
    count: order_by
    max: subscription_status_max_order_by
    min: subscription_status_min_order_by
}

"input type for inserting array relation for remote table \"subscription_status\""
input subscription_status_arr_rel_insert_input {
    data: [subscription_status_insert_input!]!
    on_conflict: subscription_status_on_conflict
}

"Boolean expression to filter rows from the table \"subscription_status\". All fields are combined with a logical 'AND'."
input subscription_status_bool_exp {
    _and: [subscription_status_bool_exp]
    _not: subscription_status_bool_exp
    _or: [subscription_status_bool_exp]
    description: String_comparison_exp
    value: String_comparison_exp
}

"expression to compare columns of type subscription_status_enum. All fields are combined with logical 'AND'."
input subscription_status_enum_comparison_exp {
    _eq: subscription_status_enum
    _in: [subscription_status_enum!]
    _is_null: Boolean
    _neq: subscription_status_enum
    _nin: [subscription_status_enum!]
}

"input type for inserting data into table \"subscription_status\""
input subscription_status_insert_input {
    description: String
    value: String
}

"order by max() on columns of table \"subscription_status\""
input subscription_status_max_order_by {
    description: order_by
    value: order_by
}

"order by min() on columns of table \"subscription_status\""
input subscription_status_min_order_by {
    description: order_by
    value: order_by
}

"input type for inserting object relation for remote table \"subscription_status\""
input subscription_status_obj_rel_insert_input {
    data: subscription_status_insert_input!
    on_conflict: subscription_status_on_conflict
}

"on conflict condition type for table \"subscription_status\""
input subscription_status_on_conflict {
    constraint: subscription_status_constraint!
    update_columns: [subscription_status_update_column!]!
    where: subscription_status_bool_exp
}

"ordering options when selecting data from \"subscription_status\""
input subscription_status_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: \"subscription_status\""
input subscription_status_pk_columns_input {
    value: String!
}

"input type for updating data in table \"subscription_status\""
input subscription_status_set_input {
    description: String
    value: String
}

"order by aggregate values of table \"subscriptions\""
input subscriptions_aggregate_order_by {
    count: order_by
    max: subscriptions_max_order_by
    min: subscriptions_min_order_by
}

"input type for inserting array relation for remote table \"subscriptions\""
input subscriptions_arr_rel_insert_input {
    data: [subscriptions_insert_input!]!
    on_conflict: subscriptions_on_conflict
}

"Boolean expression to filter rows from the table \"subscriptions\". All fields are combined with a logical 'AND'."
input subscriptions_bool_exp {
    _and: [subscriptions_bool_exp]
    _not: subscriptions_bool_exp
    _or: [subscriptions_bool_exp]
    cancelAt: timestamptz_comparison_exp
    createdAt: timestamptz_comparison_exp
    id: uuid_comparison_exp
    parent: users_bool_exp
    parentId: uuid_comparison_exp
    price: product_prices_bool_exp
    productPriceId: String_comparison_exp
    status: subscription_status_enum_comparison_exp
    stripeObject: json_comparison_exp
    stripePendingInvoiceId: String_comparison_exp
    stripeSubscriptionId: String_comparison_exp
    stripeSubscriptionItemId: String_comparison_exp
    student: students_bool_exp
    studentId: uuid_comparison_exp
    updatedAt: timestamptz_comparison_exp
}

"input type for inserting data into table \"subscriptions\""
input subscriptions_insert_input {
    cancelAt: timestamptz
    createdAt: timestamptz
    id: uuid
    parent: users_obj_rel_insert_input
    parentId: uuid
    price: product_prices_obj_rel_insert_input
    productPriceId: String
    status: subscription_status_enum
    stripeObject: json
    stripePendingInvoiceId: String
    stripeSubscriptionId: String
    stripeSubscriptionItemId: String
    student: students_obj_rel_insert_input
    studentId: uuid
    updatedAt: timestamptz
}

"order by max() on columns of table \"subscriptions\""
input subscriptions_max_order_by {
    cancelAt: order_by
    createdAt: order_by
    id: order_by
    parentId: order_by
    productPriceId: order_by
    stripePendingInvoiceId: order_by
    stripeSubscriptionId: order_by
    stripeSubscriptionItemId: order_by
    studentId: order_by
    updatedAt: order_by
}

"order by min() on columns of table \"subscriptions\""
input subscriptions_min_order_by {
    cancelAt: order_by
    createdAt: order_by
    id: order_by
    parentId: order_by
    productPriceId: order_by
    stripePendingInvoiceId: order_by
    stripeSubscriptionId: order_by
    stripeSubscriptionItemId: order_by
    studentId: order_by
    updatedAt: order_by
}

"input type for inserting object relation for remote table \"subscriptions\""
input subscriptions_obj_rel_insert_input {
    data: subscriptions_insert_input!
    on_conflict: subscriptions_on_conflict
}

"on conflict condition type for table \"subscriptions\""
input subscriptions_on_conflict {
    constraint: subscriptions_constraint!
    update_columns: [subscriptions_update_column!]!
    where: subscriptions_bool_exp
}

"ordering options when selecting data from \"subscriptions\""
input subscriptions_order_by {
    cancelAt: order_by
    createdAt: order_by
    id: order_by
    parent: users_order_by
    parentId: order_by
    price: product_prices_order_by
    productPriceId: order_by
    status: order_by
    stripeObject: order_by
    stripePendingInvoiceId: order_by
    stripeSubscriptionId: order_by
    stripeSubscriptionItemId: order_by
    student: students_order_by
    studentId: order_by
    updatedAt: order_by
}

"primary key columns input for table: \"subscriptions\""
input subscriptions_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"subscriptions\""
input subscriptions_set_input {
    cancelAt: timestamptz
    createdAt: timestamptz
    id: uuid
    parentId: uuid
    productPriceId: String
    status: subscription_status_enum
    stripeObject: json
    stripePendingInvoiceId: String
    stripeSubscriptionId: String
    stripeSubscriptionItemId: String
    studentId: uuid
    updatedAt: timestamptz
}

"order by aggregate values of table \"testimonials\""
input testimonials_aggregate_order_by {
    avg: testimonials_avg_order_by
    count: order_by
    max: testimonials_max_order_by
    min: testimonials_min_order_by
    stddev: testimonials_stddev_order_by
    stddev_pop: testimonials_stddev_pop_order_by
    stddev_samp: testimonials_stddev_samp_order_by
    sum: testimonials_sum_order_by
    var_pop: testimonials_var_pop_order_by
    var_samp: testimonials_var_samp_order_by
    variance: testimonials_variance_order_by
}

"input type for inserting array relation for remote table \"testimonials\""
input testimonials_arr_rel_insert_input {
    data: [testimonials_insert_input!]!
    on_conflict: testimonials_on_conflict
}

"order by avg() on columns of table \"testimonials\""
input testimonials_avg_order_by {
    id: order_by
    order: order_by
}

"Boolean expression to filter rows from the table \"testimonials\". All fields are combined with a logical 'AND'."
input testimonials_bool_exp {
    _and: [testimonials_bool_exp]
    _not: testimonials_bool_exp
    _or: [testimonials_bool_exp]
    avatar: uploads_bool_exp
    avatarId: uuid_comparison_exp
    content: String_comparison_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    id: Int_comparison_exp
    name: String_comparison_exp
    order: Int_comparison_exp
    role: String_comparison_exp
}

"input type for incrementing integer column in table \"testimonials\""
input testimonials_inc_input {
    id: Int
    order: Int
}

"input type for inserting data into table \"testimonials\""
input testimonials_insert_input {
    avatar: uploads_obj_rel_insert_input
    avatarId: uuid
    content: String
    course: courses_obj_rel_insert_input
    courseId: uuid
    id: Int
    name: String
    order: Int
    role: String
}

"order by max() on columns of table \"testimonials\""
input testimonials_max_order_by {
    avatarId: order_by
    content: order_by
    courseId: order_by
    id: order_by
    name: order_by
    order: order_by
    role: order_by
}

"order by min() on columns of table \"testimonials\""
input testimonials_min_order_by {
    avatarId: order_by
    content: order_by
    courseId: order_by
    id: order_by
    name: order_by
    order: order_by
    role: order_by
}

"input type for inserting object relation for remote table \"testimonials\""
input testimonials_obj_rel_insert_input {
    data: testimonials_insert_input!
    on_conflict: testimonials_on_conflict
}

"on conflict condition type for table \"testimonials\""
input testimonials_on_conflict {
    constraint: testimonials_constraint!
    update_columns: [testimonials_update_column!]!
    where: testimonials_bool_exp
}

"ordering options when selecting data from \"testimonials\""
input testimonials_order_by {
    avatar: uploads_order_by
    avatarId: order_by
    content: order_by
    course: courses_order_by
    courseId: order_by
    id: order_by
    name: order_by
    order: order_by
    role: order_by
}

"primary key columns input for table: \"testimonials\""
input testimonials_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"testimonials\""
input testimonials_set_input {
    avatarId: uuid
    content: String
    courseId: uuid
    id: Int
    name: String
    order: Int
    role: String
}

"order by stddev() on columns of table \"testimonials\""
input testimonials_stddev_order_by {
    id: order_by
    order: order_by
}

"order by stddev_pop() on columns of table \"testimonials\""
input testimonials_stddev_pop_order_by {
    id: order_by
    order: order_by
}

"order by stddev_samp() on columns of table \"testimonials\""
input testimonials_stddev_samp_order_by {
    id: order_by
    order: order_by
}

"order by sum() on columns of table \"testimonials\""
input testimonials_sum_order_by {
    id: order_by
    order: order_by
}

"order by var_pop() on columns of table \"testimonials\""
input testimonials_var_pop_order_by {
    id: order_by
    order: order_by
}

"order by var_samp() on columns of table \"testimonials\""
input testimonials_var_samp_order_by {
    id: order_by
    order: order_by
}

"order by variance() on columns of table \"testimonials\""
input testimonials_variance_order_by {
    id: order_by
    order: order_by
}

"expression to compare columns of type timestamptz. All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"order by aggregate values of table \"units\""
input units_aggregate_order_by {
    avg: units_avg_order_by
    count: order_by
    max: units_max_order_by
    min: units_min_order_by
    stddev: units_stddev_order_by
    stddev_pop: units_stddev_pop_order_by
    stddev_samp: units_stddev_samp_order_by
    sum: units_sum_order_by
    var_pop: units_var_pop_order_by
    var_samp: units_var_samp_order_by
    variance: units_variance_order_by
}

"input type for inserting array relation for remote table \"units\""
input units_arr_rel_insert_input {
    data: [units_insert_input!]!
    on_conflict: units_on_conflict
}

"order by avg() on columns of table \"units\""
input units_avg_order_by {
    capacity: order_by
    durationId: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"Boolean expression to filter rows from the table \"units\". All fields are combined with a logical 'AND'."
input units_bool_exp {
    _and: [units_bool_exp]
    _not: units_bool_exp
    _or: [units_bool_exp]
    capacity: Int_comparison_exp
    cohorts: instructor_enrollments_bool_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    description: String_comparison_exp
    duration: durations_bool_exp
    durationId: Int_comparison_exp
    frequency: frequency_types_bool_exp
    frequencyType: frequency_types_enum_comparison_exp
    id: uuid_comparison_exp
    name: String_comparison_exp
    order: Int_comparison_exp
    price: Int_comparison_exp
    totalSessions: Int_comparison_exp
}

"input type for incrementing integer column in table \"units\""
input units_inc_input {
    capacity: Int
    durationId: Int
    order: Int
    price: Int
    totalSessions: Int
}

"input type for inserting data into table \"units\""
input units_insert_input {
    capacity: Int
    cohorts: instructor_enrollments_arr_rel_insert_input
    course: courses_obj_rel_insert_input
    courseId: uuid
    description: String
    duration: durations_obj_rel_insert_input
    durationId: Int
    frequency: frequency_types_obj_rel_insert_input
    frequencyType: frequency_types_enum
    id: uuid
    name: String
    order: Int
    price: Int
    totalSessions: Int
}

"order by max() on columns of table \"units\""
input units_max_order_by {
    capacity: order_by
    courseId: order_by
    description: order_by
    durationId: order_by
    id: order_by
    name: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"order by min() on columns of table \"units\""
input units_min_order_by {
    capacity: order_by
    courseId: order_by
    description: order_by
    durationId: order_by
    id: order_by
    name: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"input type for inserting object relation for remote table \"units\""
input units_obj_rel_insert_input {
    data: units_insert_input!
    on_conflict: units_on_conflict
}

"on conflict condition type for table \"units\""
input units_on_conflict {
    constraint: units_constraint!
    update_columns: [units_update_column!]!
    where: units_bool_exp
}

"ordering options when selecting data from \"units\""
input units_order_by {
    capacity: order_by
    cohorts_aggregate: instructor_enrollments_aggregate_order_by
    course: courses_order_by
    courseId: order_by
    description: order_by
    duration: durations_order_by
    durationId: order_by
    frequency: frequency_types_order_by
    frequencyType: order_by
    id: order_by
    name: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"primary key columns input for table: \"units\""
input units_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"units\""
input units_set_input {
    capacity: Int
    courseId: uuid
    description: String
    durationId: Int
    frequencyType: frequency_types_enum
    id: uuid
    name: String
    order: Int
    price: Int
    totalSessions: Int
}

"order by stddev() on columns of table \"units\""
input units_stddev_order_by {
    capacity: order_by
    durationId: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"order by stddev_pop() on columns of table \"units\""
input units_stddev_pop_order_by {
    capacity: order_by
    durationId: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"order by stddev_samp() on columns of table \"units\""
input units_stddev_samp_order_by {
    capacity: order_by
    durationId: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"order by sum() on columns of table \"units\""
input units_sum_order_by {
    capacity: order_by
    durationId: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"order by var_pop() on columns of table \"units\""
input units_var_pop_order_by {
    capacity: order_by
    durationId: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"order by var_samp() on columns of table \"units\""
input units_var_samp_order_by {
    capacity: order_by
    durationId: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"order by variance() on columns of table \"units\""
input units_variance_order_by {
    capacity: order_by
    durationId: order_by
    order: order_by
    price: order_by
    totalSessions: order_by
}

"order by aggregate values of table \"uploads\""
input uploads_aggregate_order_by {
    avg: uploads_avg_order_by
    count: order_by
    max: uploads_max_order_by
    min: uploads_min_order_by
    stddev: uploads_stddev_order_by
    stddev_pop: uploads_stddev_pop_order_by
    stddev_samp: uploads_stddev_samp_order_by
    sum: uploads_sum_order_by
    var_pop: uploads_var_pop_order_by
    var_samp: uploads_var_samp_order_by
    variance: uploads_variance_order_by
}

"input type for inserting array relation for remote table \"uploads\""
input uploads_arr_rel_insert_input {
    data: [uploads_insert_input!]!
    on_conflict: uploads_on_conflict
}

"order by avg() on columns of table \"uploads\""
input uploads_avg_order_by {
    size: order_by
}

"Boolean expression to filter rows from the table \"uploads\". All fields are combined with a logical 'AND'."
input uploads_bool_exp {
    _and: [uploads_bool_exp]
    _not: uploads_bool_exp
    _or: [uploads_bool_exp]
    bucket: String_comparison_exp
    created_at: timestamptz_comparison_exp
    deletedAt: timestamptz_comparison_exp
    id: uuid_comparison_exp
    mediaType: String_comparison_exp
    name: String_comparison_exp
    size: Int_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"uploads\""
input uploads_inc_input {
    size: Int
}

"input type for inserting data into table \"uploads\""
input uploads_insert_input {
    bucket: String
    created_at: timestamptz
    deletedAt: timestamptz
    id: uuid
    mediaType: String
    name: String
    size: Int
    updated_at: timestamptz
}

"order by max() on columns of table \"uploads\""
input uploads_max_order_by {
    bucket: order_by
    created_at: order_by
    deletedAt: order_by
    id: order_by
    mediaType: order_by
    name: order_by
    size: order_by
    updated_at: order_by
}

"order by min() on columns of table \"uploads\""
input uploads_min_order_by {
    bucket: order_by
    created_at: order_by
    deletedAt: order_by
    id: order_by
    mediaType: order_by
    name: order_by
    size: order_by
    updated_at: order_by
}

"input type for inserting object relation for remote table \"uploads\""
input uploads_obj_rel_insert_input {
    data: uploads_insert_input!
    on_conflict: uploads_on_conflict
}

"on conflict condition type for table \"uploads\""
input uploads_on_conflict {
    constraint: uploads_constraint!
    update_columns: [uploads_update_column!]!
    where: uploads_bool_exp
}

"ordering options when selecting data from \"uploads\""
input uploads_order_by {
    bucket: order_by
    created_at: order_by
    deletedAt: order_by
    id: order_by
    mediaType: order_by
    name: order_by
    size: order_by
    updated_at: order_by
}

"primary key columns input for table: \"uploads\""
input uploads_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"uploads\""
input uploads_set_input {
    bucket: String
    created_at: timestamptz
    deletedAt: timestamptz
    id: uuid
    mediaType: String
    name: String
    size: Int
    updated_at: timestamptz
}

"order by stddev() on columns of table \"uploads\""
input uploads_stddev_order_by {
    size: order_by
}

"order by stddev_pop() on columns of table \"uploads\""
input uploads_stddev_pop_order_by {
    size: order_by
}

"order by stddev_samp() on columns of table \"uploads\""
input uploads_stddev_samp_order_by {
    size: order_by
}

"order by sum() on columns of table \"uploads\""
input uploads_sum_order_by {
    size: order_by
}

"order by var_pop() on columns of table \"uploads\""
input uploads_var_pop_order_by {
    size: order_by
}

"order by var_samp() on columns of table \"uploads\""
input uploads_var_samp_order_by {
    size: order_by
}

"order by variance() on columns of table \"uploads\""
input uploads_variance_order_by {
    size: order_by
}

"order by aggregate values of table \"user_roles\""
input user_roles_aggregate_order_by {
    count: order_by
    max: user_roles_max_order_by
    min: user_roles_min_order_by
}

"input type for inserting array relation for remote table \"user_roles\""
input user_roles_arr_rel_insert_input {
    data: [user_roles_insert_input!]!
    on_conflict: user_roles_on_conflict
}

"Boolean expression to filter rows from the table \"user_roles\". All fields are combined with a logical 'AND'."
input user_roles_bool_exp {
    _and: [user_roles_bool_exp]
    _not: user_roles_bool_exp
    _or: [user_roles_bool_exp]
    description: String_comparison_exp
    users: users_bool_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"user_roles\""
input user_roles_insert_input {
    description: String
    users: users_arr_rel_insert_input
    value: String
}

"order by max() on columns of table \"user_roles\""
input user_roles_max_order_by {
    description: order_by
    value: order_by
}

"order by min() on columns of table \"user_roles\""
input user_roles_min_order_by {
    description: order_by
    value: order_by
}

"input type for inserting object relation for remote table \"user_roles\""
input user_roles_obj_rel_insert_input {
    data: user_roles_insert_input!
    on_conflict: user_roles_on_conflict
}

"on conflict condition type for table \"user_roles\""
input user_roles_on_conflict {
    constraint: user_roles_constraint!
    update_columns: [user_roles_update_column!]!
    where: user_roles_bool_exp
}

"ordering options when selecting data from \"user_roles\""
input user_roles_order_by {
    description: order_by
    users_aggregate: users_aggregate_order_by
    value: order_by
}

"primary key columns input for table: \"user_roles\""
input user_roles_pk_columns_input {
    value: String!
}

"input type for updating data in table \"user_roles\""
input user_roles_set_input {
    description: String
    value: String
}

"order by aggregate values of table \"users\""
input users_aggregate_order_by {
    avg: users_avg_order_by
    count: order_by
    max: users_max_order_by
    min: users_min_order_by
    stddev: users_stddev_order_by
    stddev_pop: users_stddev_pop_order_by
    stddev_samp: users_stddev_samp_order_by
    sum: users_sum_order_by
    var_pop: users_var_pop_order_by
    var_samp: users_var_samp_order_by
    variance: users_variance_order_by
}

"input type for inserting array relation for remote table \"users\""
input users_arr_rel_insert_input {
    data: [users_insert_input!]!
    on_conflict: users_on_conflict
}

"order by avg() on columns of table \"users\""
input users_avg_order_by {
    thinkificId: order_by
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
    _and: [users_bool_exp]
    _not: users_bool_exp
    _or: [users_bool_exp]
    avatar: uploads_bool_exp
    avatarId: uuid_comparison_exp
    bio: String_comparison_exp
    created_at: timestamptz_comparison_exp
    email: String_comparison_exp
    emailAlias: String_comparison_exp
    firstName: String_comparison_exp
    fullName: citext_comparison_exp
    hasConfirmed: Boolean_comparison_exp
    id: uuid_comparison_exp
    instructor_enrollments: instructor_enrollments_bool_exp
    lastName: String_comparison_exp
    optInSms: Boolean_comparison_exp
    organization: schools_bool_exp
    organizationId: uuid_comparison_exp
    personal_zoom: Boolean_comparison_exp
    phone: String_comparison_exp
    provisioning: Boolean_comparison_exp
    role: String_comparison_exp
    schedules: schedules_bool_exp
    stripe: stripe_customers_bool_exp
    students: students_bool_exp
    subscriptions: subscriptions_bool_exp
    thinkificId: Int_comparison_exp
    user_role: user_roles_bool_exp
    zoomId: String_comparison_exp
}

"input type for incrementing integer column in table \"users\""
input users_inc_input {
    thinkificId: Int
}

"input type for inserting data into table \"users\""
input users_insert_input {
    avatar: uploads_obj_rel_insert_input
    avatarId: uuid
    bio: String
    created_at: timestamptz
    email: String
    emailAlias: String
    firstName: String
    fullName: citext
    hasConfirmed: Boolean
    id: uuid
    instructor_enrollments: instructor_enrollments_arr_rel_insert_input
    lastName: String
    optInSms: Boolean
    organization: schools_obj_rel_insert_input
    organizationId: uuid
    personal_zoom: Boolean
    phone: String
    provisioning: Boolean
    role: String
    schedules: schedules_arr_rel_insert_input
    stripe: stripe_customers_obj_rel_insert_input
    students: students_arr_rel_insert_input
    subscriptions: subscriptions_arr_rel_insert_input
    thinkificId: Int
    user_role: user_roles_obj_rel_insert_input
    zoomId: String
}

"order by max() on columns of table \"users\""
input users_max_order_by {
    avatarId: order_by
    bio: order_by
    created_at: order_by
    email: order_by
    emailAlias: order_by
    firstName: order_by
    fullName: order_by
    id: order_by
    lastName: order_by
    organizationId: order_by
    phone: order_by
    role: order_by
    thinkificId: order_by
    zoomId: order_by
}

"order by min() on columns of table \"users\""
input users_min_order_by {
    avatarId: order_by
    bio: order_by
    created_at: order_by
    email: order_by
    emailAlias: order_by
    firstName: order_by
    fullName: order_by
    id: order_by
    lastName: order_by
    organizationId: order_by
    phone: order_by
    role: order_by
    thinkificId: order_by
    zoomId: order_by
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
    data: users_insert_input!
    on_conflict: users_on_conflict
}

"on conflict condition type for table \"users\""
input users_on_conflict {
    constraint: users_constraint!
    update_columns: [users_update_column!]!
    where: users_bool_exp
}

"ordering options when selecting data from \"users\""
input users_order_by {
    avatar: uploads_order_by
    avatarId: order_by
    bio: order_by
    created_at: order_by
    email: order_by
    emailAlias: order_by
    firstName: order_by
    fullName: order_by
    hasConfirmed: order_by
    id: order_by
    instructor_enrollments_aggregate: instructor_enrollments_aggregate_order_by
    lastName: order_by
    optInSms: order_by
    organization: schools_order_by
    organizationId: order_by
    personal_zoom: order_by
    phone: order_by
    provisioning: order_by
    role: order_by
    schedules_aggregate: schedules_aggregate_order_by
    stripe: stripe_customers_order_by
    students_aggregate: students_aggregate_order_by
    subscriptions_aggregate: subscriptions_aggregate_order_by
    thinkificId: order_by
    user_role: user_roles_order_by
    zoomId: order_by
}

"primary key columns input for table: \"users\""
input users_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"users\""
input users_set_input {
    avatarId: uuid
    bio: String
    created_at: timestamptz
    email: String
    emailAlias: String
    firstName: String
    fullName: citext
    hasConfirmed: Boolean
    id: uuid
    lastName: String
    optInSms: Boolean
    organizationId: uuid
    personal_zoom: Boolean
    phone: String
    provisioning: Boolean
    role: String
    thinkificId: Int
    zoomId: String
    shopifyCustomerId: String
}

"order by stddev() on columns of table \"users\""
input users_stddev_order_by {
    thinkificId: order_by
}

"order by stddev_pop() on columns of table \"users\""
input users_stddev_pop_order_by {
    thinkificId: order_by
}

"order by stddev_samp() on columns of table \"users\""
input users_stddev_samp_order_by {
    thinkificId: order_by
}

"order by sum() on columns of table \"users\""
input users_sum_order_by {
    thinkificId: order_by
}

"order by var_pop() on columns of table \"users\""
input users_var_pop_order_by {
    thinkificId: order_by
}

"order by var_samp() on columns of table \"users\""
input users_var_samp_order_by {
    thinkificId: order_by
}

"order by variance() on columns of table \"users\""
input users_variance_order_by {
    thinkificId: order_by
}

"expression to compare columns of type uuid. All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}

"order by aggregate values of table \"view_search_courses\""
input view_search_courses_aggregate_order_by {
    avg: view_search_courses_avg_order_by
    count: order_by
    max: view_search_courses_max_order_by
    min: view_search_courses_min_order_by
    stddev: view_search_courses_stddev_order_by
    stddev_pop: view_search_courses_stddev_pop_order_by
    stddev_samp: view_search_courses_stddev_samp_order_by
    sum: view_search_courses_sum_order_by
    var_pop: view_search_courses_var_pop_order_by
    var_samp: view_search_courses_var_samp_order_by
    variance: view_search_courses_variance_order_by
}

"order by avg() on columns of table \"view_search_courses\""
input view_search_courses_avg_order_by {
    durationId: order_by
}

"Boolean expression to filter rows from the table \"view_search_courses\". All fields are combined with a logical 'AND'."
input view_search_courses_bool_exp {
    _and: [view_search_courses_bool_exp]
    _not: view_search_courses_bool_exp
    _or: [view_search_courses_bool_exp]
    academic: String_comparison_exp
    ages: course_ages_bool_exp
    description: String_comparison_exp
    duration: durations_bool_exp
    durationId: Int_comparison_exp
    headline: String_comparison_exp
    id: uuid_comparison_exp
    name: String_comparison_exp
    slug: String_comparison_exp
    startTime: timestamptz_comparison_exp
    subject: subjects_bool_exp
    subjectId: uuid_comparison_exp
}

"order by max() on columns of table \"view_search_courses\""
input view_search_courses_max_order_by {
    academic: order_by
    description: order_by
    durationId: order_by
    headline: order_by
    id: order_by
    name: order_by
    slug: order_by
    startTime: order_by
    subjectId: order_by
}

"order by min() on columns of table \"view_search_courses\""
input view_search_courses_min_order_by {
    academic: order_by
    description: order_by
    durationId: order_by
    headline: order_by
    id: order_by
    name: order_by
    slug: order_by
    startTime: order_by
    subjectId: order_by
}

"ordering options when selecting data from \"view_search_courses\""
input view_search_courses_order_by {
    academic: order_by
    ages_aggregate: course_ages_aggregate_order_by
    description: order_by
    duration: durations_order_by
    durationId: order_by
    headline: order_by
    id: order_by
    name: order_by
    slug: order_by
    startTime: order_by
    subject: subjects_order_by
    subjectId: order_by
}

"order by stddev() on columns of table \"view_search_courses\""
input view_search_courses_stddev_order_by {
    durationId: order_by
}

"order by stddev_pop() on columns of table \"view_search_courses\""
input view_search_courses_stddev_pop_order_by {
    durationId: order_by
}

"order by stddev_samp() on columns of table \"view_search_courses\""
input view_search_courses_stddev_samp_order_by {
    durationId: order_by
}

"order by sum() on columns of table \"view_search_courses\""
input view_search_courses_sum_order_by {
    durationId: order_by
}

"order by var_pop() on columns of table \"view_search_courses\""
input view_search_courses_var_pop_order_by {
    durationId: order_by
}

"order by var_samp() on columns of table \"view_search_courses\""
input view_search_courses_var_samp_order_by {
    durationId: order_by
}

"order by variance() on columns of table \"view_search_courses\""
input view_search_courses_variance_order_by {
    durationId: order_by
}

"order by aggregate values of table \"waitlists\""
input waitlists_aggregate_order_by {
    count: order_by
    max: waitlists_max_order_by
    min: waitlists_min_order_by
}

"input type for inserting array relation for remote table \"waitlists\""
input waitlists_arr_rel_insert_input {
    data: [waitlists_insert_input!]!
    on_conflict: waitlists_on_conflict
}

"Boolean expression to filter rows from the table \"waitlists\". All fields are combined with a logical 'AND'."
input waitlists_bool_exp {
    _and: [waitlists_bool_exp]
    _not: waitlists_bool_exp
    _or: [waitlists_bool_exp]
    email: String_comparison_exp
    id: uuid_comparison_exp
    profile: profile_bool_exp
    profileId: uuid_comparison_exp
    shouldNotify: Boolean_comparison_exp
    unit: units_bool_exp
    unitId: uuid_comparison_exp
}

"input type for inserting data into table \"waitlists\""
input waitlists_insert_input {
    email: String
    id: uuid
    profileId: uuid
    shouldNotify: Boolean
    unit: units_obj_rel_insert_input
    unitId: uuid
}

"order by max() on columns of table \"waitlists\""
input waitlists_max_order_by {
    email: order_by
    id: order_by
    profileId: order_by
    unitId: order_by
}

"order by min() on columns of table \"waitlists\""
input waitlists_min_order_by {
    email: order_by
    id: order_by
    profileId: order_by
    unitId: order_by
}

"input type for inserting object relation for remote table \"waitlists\""
input waitlists_obj_rel_insert_input {
    data: waitlists_insert_input!
    on_conflict: waitlists_on_conflict
}

"on conflict condition type for table \"waitlists\""
input waitlists_on_conflict {
    constraint: waitlists_constraint!
    update_columns: [waitlists_update_column!]!
    where: waitlists_bool_exp
}

"ordering options when selecting data from \"waitlists\""
input waitlists_order_by {
    email: order_by
    id: order_by
    profile: profile_order_by
    profileId: order_by
    shouldNotify: order_by
    unit: units_order_by
    unitId: order_by
}

"primary key columns input for table: \"waitlists\""
input waitlists_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"waitlists\""
input waitlists_set_input {
    email: String
    id: uuid
    profileId: uuid
    shouldNotify: Boolean
    unitId: uuid
}

"order by aggregate values of table \"zoom_meetings\""
input zoom_meetings_aggregate_order_by {
    count: order_by
    max: zoom_meetings_max_order_by
    min: zoom_meetings_min_order_by
}

"input type for inserting array relation for remote table \"zoom_meetings\""
input zoom_meetings_arr_rel_insert_input {
    data: [zoom_meetings_insert_input!]!
    on_conflict: zoom_meetings_on_conflict
}

"Boolean expression to filter rows from the table \"zoom_meetings\". All fields are combined with a logical 'AND'."
input zoom_meetings_bool_exp {
    _and: [zoom_meetings_bool_exp]
    _not: zoom_meetings_bool_exp
    _or: [zoom_meetings_bool_exp]
    cohort: instructor_enrollments_bool_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    created_at: timestamptz_comparison_exp
    endDate: date_comparison_exp
    id: uuid_comparison_exp
    instructor_enrollment_id: uuid_comparison_exp
    internalZoomMeetingId: String_comparison_exp
    password: String_comparison_exp
    schedules: schedules_bool_exp
    startDate: date_comparison_exp
    startUrl: String_comparison_exp
    studentMeetings: student_meeting_enrollments_bool_exp
    updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"zoom_meetings\""
input zoom_meetings_insert_input {
    cohort: instructor_enrollments_obj_rel_insert_input
    course: courses_obj_rel_insert_input
    courseId: uuid
    created_at: timestamptz
    endDate: date
    id: uuid
    instructor_enrollment_id: uuid
    internalZoomMeetingId: String
    password: String
    schedules: schedules_arr_rel_insert_input
    startDate: date
    startUrl: String
    studentMeetings: student_meeting_enrollments_arr_rel_insert_input
    updated_at: timestamptz
}

"order by max() on columns of table \"zoom_meetings\""
input zoom_meetings_max_order_by {
    courseId: order_by
    created_at: order_by
    endDate: order_by
    id: order_by
    instructor_enrollment_id: order_by
    internalZoomMeetingId: order_by
    password: order_by
    startDate: order_by
    startUrl: order_by
    updated_at: order_by
}

"order by min() on columns of table \"zoom_meetings\""
input zoom_meetings_min_order_by {
    courseId: order_by
    created_at: order_by
    endDate: order_by
    id: order_by
    instructor_enrollment_id: order_by
    internalZoomMeetingId: order_by
    password: order_by
    startDate: order_by
    startUrl: order_by
    updated_at: order_by
}

"input type for inserting object relation for remote table \"zoom_meetings\""
input zoom_meetings_obj_rel_insert_input {
    data: zoom_meetings_insert_input!
    on_conflict: zoom_meetings_on_conflict
}

"on conflict condition type for table \"zoom_meetings\""
input zoom_meetings_on_conflict {
    constraint: zoom_meetings_constraint!
    update_columns: [zoom_meetings_update_column!]!
    where: zoom_meetings_bool_exp
}

"ordering options when selecting data from \"zoom_meetings\""
input zoom_meetings_order_by {
    cohort: instructor_enrollments_order_by
    course: courses_order_by
    courseId: order_by
    created_at: order_by
    endDate: order_by
    id: order_by
    instructor_enrollment_id: order_by
    internalZoomMeetingId: order_by
    password: order_by
    schedules_aggregate: schedules_aggregate_order_by
    startDate: order_by
    startUrl: order_by
    studentMeetings_aggregate: student_meeting_enrollments_aggregate_order_by
    updated_at: order_by
}

"primary key columns input for table: \"zoom_meetings\""
input zoom_meetings_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"zoom_meetings\""
input zoom_meetings_set_input {
    courseId: uuid
    created_at: timestamptz
    endDate: date
    id: uuid
    instructor_enrollment_id: uuid
    internalZoomMeetingId: String
    password: String
    startDate: date
    startUrl: String
    updated_at: timestamptz
}


scalar StringOrInt

scalar Upload

scalar _json

scalar citext

scalar date

scalar json

scalar jsonb

scalar numeric

scalar schedules_for_survey_mark

scalar timestamptz

scalar uuid
